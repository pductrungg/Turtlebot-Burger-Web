import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField,
  __toESM
} from "./chunk-WOOG5QLI.js";

// node_modules/roslib/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/roslib/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i3 = 0, l6 = handlers.length, ee = new Array(l6); i3 < l6; i3++) {
        ee[i3] = handlers[i3].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a22, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i3;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a22), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a22, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a22, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a22, a3, a4, a5), true;
        }
        for (i3 = 1, args = new Array(len - 1); i3 < len; i3++) {
          args[i3 - 1] = arguments[i3];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j2;
        for (i3 = 0; i3 < length; i3++) {
          if (listeners[i3].once) this.removeListener(event, listeners[i3].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i3].fn.call(listeners[i3].context);
              break;
            case 2:
              listeners[i3].fn.call(listeners[i3].context, a1);
              break;
            case 3:
              listeners[i3].fn.call(listeners[i3].context, a1, a22);
              break;
            case 4:
              listeners[i3].fn.call(listeners[i3].context, a1, a22, a3);
              break;
            default:
              if (!args) for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                args[j2 - 1] = arguments[j2];
              }
              listeners[i3].fn.apply(listeners[i3].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i3 = 0, events = [], length = listeners.length; i3 < length; i3++) {
          if (listeners[i3].fn !== fn || once && !listeners[i3].once || context && listeners[i3].context !== context) {
            events.push(listeners[i3]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/roslib/node_modules/eventemitter3/index.mjs
var import_index = __toESM(require_eventemitter3(), 1);

// node_modules/uuid/dist/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

// node_modules/uuid/dist/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v2;
  return Uint8Array.of((v2 = parseInt(uuid.slice(0, 8), 16)) >>> 24, v2 >>> 16 & 255, v2 >>> 8 & 255, v2 & 255, (v2 = parseInt(uuid.slice(9, 13), 16)) >>> 8, v2 & 255, (v2 = parseInt(uuid.slice(14, 18), 16)) >>> 8, v2 & 255, (v2 = parseInt(uuid.slice(19, 23), 16)) >>> 8, v2 & 255, (v2 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, v2 / 4294967296 & 255, v2 >>> 24 & 255, v2 >>> 16 & 255, v2 >>> 8 & 255, v2 & 255);
}
var parse_default = parse;

// node_modules/uuid/dist/stringify.js
var byteToHex = [];
for (let i3 = 0; i3 < 256; ++i3) {
  byteToHex.push((i3 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/md5.js
function md5(bytes) {
  const words = uint8ToUint32(bytes);
  const md5Bytes = wordsToMd5(words, bytes.length * 8);
  return uint32ToUint8(md5Bytes);
}
function uint32ToUint8(input) {
  const bytes = new Uint8Array(input.length * 4);
  for (let i3 = 0; i3 < input.length * 4; i3++) {
    bytes[i3] = input[i3 >> 2] >>> i3 % 4 * 8 & 255;
  }
  return bytes;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x4, len) {
  const xpad = new Uint32Array(getOutputLength(len)).fill(0);
  xpad.set(x4);
  xpad[len >> 5] |= 128 << len % 32;
  xpad[xpad.length - 1] = len;
  x4 = xpad;
  let a3 = 1732584193;
  let b4 = -271733879;
  let c4 = -1732584194;
  let d5 = 271733878;
  for (let i3 = 0; i3 < x4.length; i3 += 16) {
    const olda = a3;
    const oldb = b4;
    const oldc = c4;
    const oldd = d5;
    a3 = md5ff(a3, b4, c4, d5, x4[i3], 7, -680876936);
    d5 = md5ff(d5, a3, b4, c4, x4[i3 + 1], 12, -389564586);
    c4 = md5ff(c4, d5, a3, b4, x4[i3 + 2], 17, 606105819);
    b4 = md5ff(b4, c4, d5, a3, x4[i3 + 3], 22, -1044525330);
    a3 = md5ff(a3, b4, c4, d5, x4[i3 + 4], 7, -176418897);
    d5 = md5ff(d5, a3, b4, c4, x4[i3 + 5], 12, 1200080426);
    c4 = md5ff(c4, d5, a3, b4, x4[i3 + 6], 17, -1473231341);
    b4 = md5ff(b4, c4, d5, a3, x4[i3 + 7], 22, -45705983);
    a3 = md5ff(a3, b4, c4, d5, x4[i3 + 8], 7, 1770035416);
    d5 = md5ff(d5, a3, b4, c4, x4[i3 + 9], 12, -1958414417);
    c4 = md5ff(c4, d5, a3, b4, x4[i3 + 10], 17, -42063);
    b4 = md5ff(b4, c4, d5, a3, x4[i3 + 11], 22, -1990404162);
    a3 = md5ff(a3, b4, c4, d5, x4[i3 + 12], 7, 1804603682);
    d5 = md5ff(d5, a3, b4, c4, x4[i3 + 13], 12, -40341101);
    c4 = md5ff(c4, d5, a3, b4, x4[i3 + 14], 17, -1502002290);
    b4 = md5ff(b4, c4, d5, a3, x4[i3 + 15], 22, 1236535329);
    a3 = md5gg(a3, b4, c4, d5, x4[i3 + 1], 5, -165796510);
    d5 = md5gg(d5, a3, b4, c4, x4[i3 + 6], 9, -1069501632);
    c4 = md5gg(c4, d5, a3, b4, x4[i3 + 11], 14, 643717713);
    b4 = md5gg(b4, c4, d5, a3, x4[i3], 20, -373897302);
    a3 = md5gg(a3, b4, c4, d5, x4[i3 + 5], 5, -701558691);
    d5 = md5gg(d5, a3, b4, c4, x4[i3 + 10], 9, 38016083);
    c4 = md5gg(c4, d5, a3, b4, x4[i3 + 15], 14, -660478335);
    b4 = md5gg(b4, c4, d5, a3, x4[i3 + 4], 20, -405537848);
    a3 = md5gg(a3, b4, c4, d5, x4[i3 + 9], 5, 568446438);
    d5 = md5gg(d5, a3, b4, c4, x4[i3 + 14], 9, -1019803690);
    c4 = md5gg(c4, d5, a3, b4, x4[i3 + 3], 14, -187363961);
    b4 = md5gg(b4, c4, d5, a3, x4[i3 + 8], 20, 1163531501);
    a3 = md5gg(a3, b4, c4, d5, x4[i3 + 13], 5, -1444681467);
    d5 = md5gg(d5, a3, b4, c4, x4[i3 + 2], 9, -51403784);
    c4 = md5gg(c4, d5, a3, b4, x4[i3 + 7], 14, 1735328473);
    b4 = md5gg(b4, c4, d5, a3, x4[i3 + 12], 20, -1926607734);
    a3 = md5hh(a3, b4, c4, d5, x4[i3 + 5], 4, -378558);
    d5 = md5hh(d5, a3, b4, c4, x4[i3 + 8], 11, -2022574463);
    c4 = md5hh(c4, d5, a3, b4, x4[i3 + 11], 16, 1839030562);
    b4 = md5hh(b4, c4, d5, a3, x4[i3 + 14], 23, -35309556);
    a3 = md5hh(a3, b4, c4, d5, x4[i3 + 1], 4, -1530992060);
    d5 = md5hh(d5, a3, b4, c4, x4[i3 + 4], 11, 1272893353);
    c4 = md5hh(c4, d5, a3, b4, x4[i3 + 7], 16, -155497632);
    b4 = md5hh(b4, c4, d5, a3, x4[i3 + 10], 23, -1094730640);
    a3 = md5hh(a3, b4, c4, d5, x4[i3 + 13], 4, 681279174);
    d5 = md5hh(d5, a3, b4, c4, x4[i3], 11, -358537222);
    c4 = md5hh(c4, d5, a3, b4, x4[i3 + 3], 16, -722521979);
    b4 = md5hh(b4, c4, d5, a3, x4[i3 + 6], 23, 76029189);
    a3 = md5hh(a3, b4, c4, d5, x4[i3 + 9], 4, -640364487);
    d5 = md5hh(d5, a3, b4, c4, x4[i3 + 12], 11, -421815835);
    c4 = md5hh(c4, d5, a3, b4, x4[i3 + 15], 16, 530742520);
    b4 = md5hh(b4, c4, d5, a3, x4[i3 + 2], 23, -995338651);
    a3 = md5ii(a3, b4, c4, d5, x4[i3], 6, -198630844);
    d5 = md5ii(d5, a3, b4, c4, x4[i3 + 7], 10, 1126891415);
    c4 = md5ii(c4, d5, a3, b4, x4[i3 + 14], 15, -1416354905);
    b4 = md5ii(b4, c4, d5, a3, x4[i3 + 5], 21, -57434055);
    a3 = md5ii(a3, b4, c4, d5, x4[i3 + 12], 6, 1700485571);
    d5 = md5ii(d5, a3, b4, c4, x4[i3 + 3], 10, -1894986606);
    c4 = md5ii(c4, d5, a3, b4, x4[i3 + 10], 15, -1051523);
    b4 = md5ii(b4, c4, d5, a3, x4[i3 + 1], 21, -2054922799);
    a3 = md5ii(a3, b4, c4, d5, x4[i3 + 8], 6, 1873313359);
    d5 = md5ii(d5, a3, b4, c4, x4[i3 + 15], 10, -30611744);
    c4 = md5ii(c4, d5, a3, b4, x4[i3 + 6], 15, -1560198380);
    b4 = md5ii(b4, c4, d5, a3, x4[i3 + 13], 21, 1309151649);
    a3 = md5ii(a3, b4, c4, d5, x4[i3 + 4], 6, -145523070);
    d5 = md5ii(d5, a3, b4, c4, x4[i3 + 11], 10, -1120210379);
    c4 = md5ii(c4, d5, a3, b4, x4[i3 + 2], 15, 718787259);
    b4 = md5ii(b4, c4, d5, a3, x4[i3 + 9], 21, -343485551);
    a3 = safeAdd(a3, olda);
    b4 = safeAdd(b4, oldb);
    c4 = safeAdd(c4, oldc);
    d5 = safeAdd(d5, oldd);
  }
  return Uint32Array.of(a3, b4, c4, d5);
}
function uint8ToUint32(input) {
  if (input.length === 0) {
    return new Uint32Array();
  }
  const output = new Uint32Array(getOutputLength(input.length * 8)).fill(0);
  for (let i3 = 0; i3 < input.length; i3++) {
    output[i3 >> 2] |= (input[i3] & 255) << i3 % 4 * 8;
  }
  return output;
}
function safeAdd(x4, y6) {
  const lsw = (x4 & 65535) + (y6 & 65535);
  const msw = (x4 >> 16) + (y6 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q3, a3, b4, x4, s4, t3) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a3, q3), safeAdd(x4, t3)), s4), b4);
}
function md5ff(a3, b4, c4, d5, x4, s4, t3) {
  return md5cmn(b4 & c4 | ~b4 & d5, a3, b4, x4, s4, t3);
}
function md5gg(a3, b4, c4, d5, x4, s4, t3) {
  return md5cmn(b4 & d5 | c4 & ~d5, a3, b4, x4, s4, t3);
}
function md5hh(a3, b4, c4, d5, x4, s4, t3) {
  return md5cmn(b4 ^ c4 ^ d5, a3, b4, x4, s4, t3);
}
function md5ii(a3, b4, c4, d5, x4, s4, t3) {
  return md5cmn(c4 ^ (b4 | ~d5), a3, b4, x4, s4, t3);
}
var md5_default = md5;

// node_modules/uuid/dist/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = new Uint8Array(str.length);
  for (let i3 = 0; i3 < str.length; ++i3) {
    bytes[i3] = str.charCodeAt(i3);
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(version, hash, value, namespace, buf, offset) {
  const valueBytes = typeof value === "string" ? stringToBytes(value) : value;
  const namespaceBytes = typeof namespace === "string" ? parse_default(namespace) : namespace;
  if (typeof namespace === "string") {
    namespace = parse_default(namespace);
  }
  if ((namespace == null ? void 0 : namespace.length) !== 16) {
    throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
  }
  let bytes = new Uint8Array(16 + valueBytes.length);
  bytes.set(namespaceBytes);
  bytes.set(valueBytes, namespaceBytes.length);
  bytes = hash(bytes);
  bytes[6] = bytes[6] & 15 | version;
  bytes[8] = bytes[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i3 = 0; i3 < 16; ++i3) {
      buf[offset + i3] = bytes[i3];
    }
    return buf;
  }
  return unsafeStringify(bytes);
}

// node_modules/uuid/dist/v3.js
function v3(value, namespace, buf, offset) {
  return v35(48, md5_default, value, namespace, buf, offset);
}
v3.DNS = DNS;
v3.URL = URL2;

// node_modules/uuid/dist/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

// node_modules/uuid/dist/v4.js
function _v4(options, buf, offset) {
  var _a4;
  options = options || {};
  const rnds = options.random ?? ((_a4 = options.rng) == null ? void 0 : _a4.call(options)) ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i3 = 0; i3 < 16; ++i3) {
      buf[offset + i3] = rnds[i3];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  return _v4(options, buf, offset);
}
var v4_default = v4;

// node_modules/uuid/dist/sha1.js
function f(s4, x4, y6, z2) {
  switch (s4) {
    case 0:
      return x4 & y6 ^ ~x4 & z2;
    case 1:
      return x4 ^ y6 ^ z2;
    case 2:
      return x4 & y6 ^ x4 & z2 ^ y6 & z2;
    case 3:
      return x4 ^ y6 ^ z2;
  }
}
function ROTL(x4, n2) {
  return x4 << n2 | x4 >>> 32 - n2;
}
function sha1(bytes) {
  const K3 = [1518500249, 1859775393, 2400959708, 3395469782];
  const H4 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  const newBytes = new Uint8Array(bytes.length + 1);
  newBytes.set(bytes);
  newBytes[bytes.length] = 128;
  bytes = newBytes;
  const l6 = bytes.length / 4 + 2;
  const N4 = Math.ceil(l6 / 16);
  const M2 = new Array(N4);
  for (let i3 = 0; i3 < N4; ++i3) {
    const arr = new Uint32Array(16);
    for (let j2 = 0; j2 < 16; ++j2) {
      arr[j2] = bytes[i3 * 64 + j2 * 4] << 24 | bytes[i3 * 64 + j2 * 4 + 1] << 16 | bytes[i3 * 64 + j2 * 4 + 2] << 8 | bytes[i3 * 64 + j2 * 4 + 3];
    }
    M2[i3] = arr;
  }
  M2[N4 - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M2[N4 - 1][14] = Math.floor(M2[N4 - 1][14]);
  M2[N4 - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i3 = 0; i3 < N4; ++i3) {
    const W = new Uint32Array(80);
    for (let t3 = 0; t3 < 16; ++t3) {
      W[t3] = M2[i3][t3];
    }
    for (let t3 = 16; t3 < 80; ++t3) {
      W[t3] = ROTL(W[t3 - 3] ^ W[t3 - 8] ^ W[t3 - 14] ^ W[t3 - 16], 1);
    }
    let a3 = H4[0];
    let b4 = H4[1];
    let c4 = H4[2];
    let d5 = H4[3];
    let e2 = H4[4];
    for (let t3 = 0; t3 < 80; ++t3) {
      const s4 = Math.floor(t3 / 20);
      const T4 = ROTL(a3, 5) + f(s4, b4, c4, d5) + e2 + K3[s4] + W[t3] >>> 0;
      e2 = d5;
      d5 = c4;
      c4 = ROTL(b4, 30) >>> 0;
      b4 = a3;
      a3 = T4;
    }
    H4[0] = H4[0] + a3 >>> 0;
    H4[1] = H4[1] + b4 >>> 0;
    H4[2] = H4[2] + c4 >>> 0;
    H4[3] = H4[3] + d5 >>> 0;
    H4[4] = H4[4] + e2 >>> 0;
  }
  return Uint8Array.of(H4[0] >> 24, H4[0] >> 16, H4[0] >> 8, H4[0], H4[1] >> 24, H4[1] >> 16, H4[1] >> 8, H4[1], H4[2] >> 24, H4[2] >> 16, H4[2] >> 8, H4[2], H4[3] >> 24, H4[3] >> 16, H4[3] >> 8, H4[3], H4[4] >> 24, H4[4] >> 16, H4[4] >> 8, H4[4]);
}
var sha1_default = sha1;

// node_modules/uuid/dist/v5.js
function v5(value, namespace, buf, offset) {
  return v35(80, sha1_default, value, namespace, buf, offset);
}
v5.DNS = DNS;
v5.URL = URL2;

// node_modules/bson/lib/bson.mjs
var TypedArrayPrototypeGetSymbolToStringTag = (() => {
  const g4 = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Uint8Array.prototype), Symbol.toStringTag).get;
  return (value) => g4.call(value);
})();
function isUint8Array(value) {
  return TypedArrayPrototypeGetSymbolToStringTag(value) === "Uint8Array";
}
function isAnyArrayBuffer(value) {
  return typeof value === "object" && value != null && Symbol.toStringTag in value && (value[Symbol.toStringTag] === "ArrayBuffer" || value[Symbol.toStringTag] === "SharedArrayBuffer");
}
function isRegExp(regexp2) {
  return regexp2 instanceof RegExp || Object.prototype.toString.call(regexp2) === "[object RegExp]";
}
function isMap(value) {
  return typeof value === "object" && value != null && Symbol.toStringTag in value && value[Symbol.toStringTag] === "Map";
}
function isDate(date) {
  return date instanceof Date || Object.prototype.toString.call(date) === "[object Date]";
}
function defaultInspect(x4, _options) {
  return JSON.stringify(x4, (k4, v2) => {
    if (typeof v2 === "bigint") {
      return { $numberLong: `${v2}` };
    } else if (isMap(v2)) {
      return Object.fromEntries(v2);
    }
    return v2;
  });
}
function getStylizeFunction(options) {
  const stylizeExists = options != null && typeof options === "object" && "stylize" in options && typeof options.stylize === "function";
  if (stylizeExists) {
    return options.stylize;
  }
}
var BSON_MAJOR_VERSION = 7;
var BSON_VERSION_SYMBOL = Symbol.for("@@mdb.bson.version");
var BSON_INT32_MAX = 2147483647;
var BSON_INT32_MIN = -2147483648;
var BSON_INT64_MAX = Math.pow(2, 63) - 1;
var BSON_INT64_MIN = -Math.pow(2, 63);
var JS_INT_MAX = Math.pow(2, 53);
var JS_INT_MIN = -Math.pow(2, 53);
var BSON_DATA_NUMBER = 1;
var BSON_DATA_STRING = 2;
var BSON_DATA_OBJECT = 3;
var BSON_DATA_ARRAY = 4;
var BSON_DATA_BINARY = 5;
var BSON_DATA_UNDEFINED = 6;
var BSON_DATA_OID = 7;
var BSON_DATA_BOOLEAN = 8;
var BSON_DATA_DATE = 9;
var BSON_DATA_NULL = 10;
var BSON_DATA_REGEXP = 11;
var BSON_DATA_DBPOINTER = 12;
var BSON_DATA_CODE = 13;
var BSON_DATA_SYMBOL = 14;
var BSON_DATA_CODE_W_SCOPE = 15;
var BSON_DATA_INT = 16;
var BSON_DATA_TIMESTAMP = 17;
var BSON_DATA_LONG = 18;
var BSON_DATA_DECIMAL128 = 19;
var BSON_DATA_MIN_KEY = 255;
var BSON_DATA_MAX_KEY = 127;
var BSON_BINARY_SUBTYPE_DEFAULT = 0;
var BSON_BINARY_SUBTYPE_UUID_NEW = 4;
var BSONType = Object.freeze({
  double: 1,
  string: 2,
  object: 3,
  array: 4,
  binData: 5,
  undefined: 6,
  objectId: 7,
  bool: 8,
  date: 9,
  null: 10,
  regex: 11,
  dbPointer: 12,
  javascript: 13,
  symbol: 14,
  javascriptWithScope: 15,
  int: 16,
  timestamp: 17,
  long: 18,
  decimal: 19,
  minKey: -1,
  maxKey: 127
});
var BSONError = class extends Error {
  get bsonError() {
    return true;
  }
  get name() {
    return "BSONError";
  }
  constructor(message, options) {
    super(message, options);
  }
  static isBSONError(value) {
    return value != null && typeof value === "object" && "bsonError" in value && value.bsonError === true && "name" in value && "message" in value && "stack" in value;
  }
};
var BSONVersionError = class extends BSONError {
  get name() {
    return "BSONVersionError";
  }
  constructor() {
    super(`Unsupported BSON version, bson types must be from bson ${BSON_MAJOR_VERSION}.x.x`);
  }
};
var BSONRuntimeError = class extends BSONError {
  get name() {
    return "BSONRuntimeError";
  }
  constructor(message) {
    super(message);
  }
};
var BSONOffsetError = class extends BSONError {
  constructor(message, offset, options) {
    super(`${message}. offset: ${offset}`, options);
    __publicField(this, "offset");
    this.offset = offset;
  }
  get name() {
    return "BSONOffsetError";
  }
};
var TextDecoderFatal;
var TextDecoderNonFatal;
function parseUtf8(buffer2, start, end, fatal) {
  if (fatal) {
    TextDecoderFatal ?? (TextDecoderFatal = new TextDecoder("utf8", { fatal: true }));
    try {
      return TextDecoderFatal.decode(buffer2.subarray(start, end));
    } catch (cause) {
      throw new BSONError("Invalid UTF-8 string in BSON document", { cause });
    }
  }
  TextDecoderNonFatal ?? (TextDecoderNonFatal = new TextDecoder("utf8", { fatal: false }));
  return TextDecoderNonFatal.decode(buffer2.subarray(start, end));
}
function tryReadBasicLatin(uint8array, start, end) {
  if (uint8array.length === 0) {
    return "";
  }
  const stringByteLength = end - start;
  if (stringByteLength === 0) {
    return "";
  }
  if (stringByteLength > 20) {
    return null;
  }
  if (stringByteLength === 1 && uint8array[start] < 128) {
    return String.fromCharCode(uint8array[start]);
  }
  if (stringByteLength === 2 && uint8array[start] < 128 && uint8array[start + 1] < 128) {
    return String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]);
  }
  if (stringByteLength === 3 && uint8array[start] < 128 && uint8array[start + 1] < 128 && uint8array[start + 2] < 128) {
    return String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]) + String.fromCharCode(uint8array[start + 2]);
  }
  const latinBytes = [];
  for (let i3 = start; i3 < end; i3++) {
    const byte = uint8array[i3];
    if (byte > 127) {
      return null;
    }
    latinBytes.push(byte);
  }
  return String.fromCharCode(...latinBytes);
}
function tryWriteBasicLatin(destination, source, offset) {
  if (source.length === 0)
    return 0;
  if (source.length > 25)
    return null;
  if (destination.length - offset < source.length)
    return null;
  for (let charOffset = 0, destinationOffset = offset; charOffset < source.length; charOffset++, destinationOffset++) {
    const char = source.charCodeAt(charOffset);
    if (char > 127)
      return null;
    destination[destinationOffset] = char;
  }
  return source.length;
}
function nodejsMathRandomBytes(byteLength) {
  return nodeJsByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));
}
function nodejsSecureRandomBytes(byteLength) {
  return crypto.getRandomValues(nodeJsByteUtils.allocate(byteLength));
}
var nodejsRandomBytes = (() => {
  const { crypto: crypto2 } = globalThis;
  if (crypto2 != null && typeof crypto2.getRandomValues === "function") {
    return nodejsSecureRandomBytes;
  } else {
    return nodejsMathRandomBytes;
  }
})();
var nodeJsByteUtils = {
  toLocalBufferType(potentialBuffer) {
    if (Buffer.isBuffer(potentialBuffer)) {
      return potentialBuffer;
    }
    if (ArrayBuffer.isView(potentialBuffer)) {
      return Buffer.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);
    }
    const stringTag = (potentialBuffer == null ? void 0 : potentialBuffer[Symbol.toStringTag]) ?? Object.prototype.toString.call(potentialBuffer);
    if (stringTag === "ArrayBuffer" || stringTag === "SharedArrayBuffer" || stringTag === "[object ArrayBuffer]" || stringTag === "[object SharedArrayBuffer]") {
      return Buffer.from(potentialBuffer);
    }
    throw new BSONError(`Cannot create Buffer from the passed potentialBuffer.`);
  },
  allocate(size) {
    return Buffer.alloc(size);
  },
  allocateUnsafe(size) {
    return Buffer.allocUnsafe(size);
  },
  equals(a3, b4) {
    return nodeJsByteUtils.toLocalBufferType(a3).equals(b4);
  },
  fromNumberArray(array) {
    return Buffer.from(array);
  },
  fromBase64(base64) {
    return Buffer.from(base64, "base64");
  },
  toBase64(buffer2) {
    return nodeJsByteUtils.toLocalBufferType(buffer2).toString("base64");
  },
  fromISO88591(codePoints) {
    return Buffer.from(codePoints, "binary");
  },
  toISO88591(buffer2) {
    return nodeJsByteUtils.toLocalBufferType(buffer2).toString("binary");
  },
  fromHex(hex) {
    return Buffer.from(hex, "hex");
  },
  toHex(buffer2) {
    return nodeJsByteUtils.toLocalBufferType(buffer2).toString("hex");
  },
  toUTF8(buffer2, start, end, fatal) {
    const basicLatin = end - start <= 20 ? tryReadBasicLatin(buffer2, start, end) : null;
    if (basicLatin != null) {
      return basicLatin;
    }
    const string = nodeJsByteUtils.toLocalBufferType(buffer2).toString("utf8", start, end);
    if (fatal) {
      for (let i3 = 0; i3 < string.length; i3++) {
        if (string.charCodeAt(i3) === 65533) {
          parseUtf8(buffer2, start, end, true);
          break;
        }
      }
    }
    return string;
  },
  utf8ByteLength(input) {
    return Buffer.byteLength(input, "utf8");
  },
  encodeUTF8Into(buffer2, source, byteOffset) {
    const latinBytesWritten = tryWriteBasicLatin(buffer2, source, byteOffset);
    if (latinBytesWritten != null) {
      return latinBytesWritten;
    }
    return nodeJsByteUtils.toLocalBufferType(buffer2).write(source, byteOffset, void 0, "utf8");
  },
  randomBytes: nodejsRandomBytes,
  swap32(buffer2) {
    return nodeJsByteUtils.toLocalBufferType(buffer2).swap32();
  }
};
function isReactNative() {
  const { navigator } = globalThis;
  return typeof navigator === "object" && navigator.product === "ReactNative";
}
function webMathRandomBytes(byteLength) {
  if (byteLength < 0) {
    throw new RangeError(`The argument 'byteLength' is invalid. Received ${byteLength}`);
  }
  return webByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));
}
var webRandomBytes = (() => {
  var _a4;
  const { crypto: crypto2 } = globalThis;
  if (crypto2 != null && typeof crypto2.getRandomValues === "function") {
    return (byteLength) => {
      return crypto2.getRandomValues(webByteUtils.allocate(byteLength));
    };
  } else {
    if (isReactNative()) {
      const { console: console2 } = globalThis;
      (_a4 = console2 == null ? void 0 : console2.warn) == null ? void 0 : _a4.call(console2, "BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.");
    }
    return webMathRandomBytes;
  }
})();
var HEX_DIGIT = /(\d|[a-f])/i;
var webByteUtils = {
  toLocalBufferType(potentialUint8array) {
    const stringTag = (potentialUint8array == null ? void 0 : potentialUint8array[Symbol.toStringTag]) ?? Object.prototype.toString.call(potentialUint8array);
    if (stringTag === "Uint8Array") {
      return potentialUint8array;
    }
    if (ArrayBuffer.isView(potentialUint8array)) {
      return new Uint8Array(potentialUint8array.buffer.slice(potentialUint8array.byteOffset, potentialUint8array.byteOffset + potentialUint8array.byteLength));
    }
    if (stringTag === "ArrayBuffer" || stringTag === "SharedArrayBuffer" || stringTag === "[object ArrayBuffer]" || stringTag === "[object SharedArrayBuffer]") {
      return new Uint8Array(potentialUint8array);
    }
    throw new BSONError(`Cannot make a Uint8Array from passed potentialBuffer.`);
  },
  allocate(size) {
    if (typeof size !== "number") {
      throw new TypeError(`The "size" argument must be of type number. Received ${String(size)}`);
    }
    return new Uint8Array(size);
  },
  allocateUnsafe(size) {
    return webByteUtils.allocate(size);
  },
  equals(a3, b4) {
    if (a3.byteLength !== b4.byteLength) {
      return false;
    }
    for (let i3 = 0; i3 < a3.byteLength; i3++) {
      if (a3[i3] !== b4[i3]) {
        return false;
      }
    }
    return true;
  },
  fromNumberArray(array) {
    return Uint8Array.from(array);
  },
  fromBase64(base64) {
    return Uint8Array.from(atob(base64), (c4) => c4.charCodeAt(0));
  },
  toBase64(uint8array) {
    return btoa(webByteUtils.toISO88591(uint8array));
  },
  fromISO88591(codePoints) {
    return Uint8Array.from(codePoints, (c4) => c4.charCodeAt(0) & 255);
  },
  toISO88591(uint8array) {
    return Array.from(Uint16Array.from(uint8array), (b4) => String.fromCharCode(b4)).join("");
  },
  fromHex(hex) {
    const evenLengthHex = hex.length % 2 === 0 ? hex : hex.slice(0, hex.length - 1);
    const buffer2 = [];
    for (let i3 = 0; i3 < evenLengthHex.length; i3 += 2) {
      const firstDigit = evenLengthHex[i3];
      const secondDigit = evenLengthHex[i3 + 1];
      if (!HEX_DIGIT.test(firstDigit)) {
        break;
      }
      if (!HEX_DIGIT.test(secondDigit)) {
        break;
      }
      const hexDigit = Number.parseInt(`${firstDigit}${secondDigit}`, 16);
      buffer2.push(hexDigit);
    }
    return Uint8Array.from(buffer2);
  },
  toHex(uint8array) {
    return Array.from(uint8array, (byte) => byte.toString(16).padStart(2, "0")).join("");
  },
  toUTF8(uint8array, start, end, fatal) {
    const basicLatin = end - start <= 20 ? tryReadBasicLatin(uint8array, start, end) : null;
    if (basicLatin != null) {
      return basicLatin;
    }
    return parseUtf8(uint8array, start, end, fatal);
  },
  utf8ByteLength(input) {
    return new TextEncoder().encode(input).byteLength;
  },
  encodeUTF8Into(uint8array, source, byteOffset) {
    const bytes = new TextEncoder().encode(source);
    uint8array.set(bytes, byteOffset);
    return bytes.byteLength;
  },
  randomBytes: webRandomBytes,
  swap32(buffer2) {
    if (buffer2.length % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i3 = 0; i3 < buffer2.length; i3 += 4) {
      const byte0 = buffer2[i3];
      const byte1 = buffer2[i3 + 1];
      const byte2 = buffer2[i3 + 2];
      const byte3 = buffer2[i3 + 3];
      buffer2[i3] = byte3;
      buffer2[i3 + 1] = byte2;
      buffer2[i3 + 2] = byte1;
      buffer2[i3 + 3] = byte0;
    }
    return buffer2;
  }
};
var _a;
var hasGlobalBuffer = typeof Buffer === "function" && ((_a = Buffer.prototype) == null ? void 0 : _a._isBuffer) !== true;
var ByteUtils = hasGlobalBuffer ? nodeJsByteUtils : webByteUtils;
var bsonType = Symbol.for("@@mdb.bson.type");
var BSONValue = class {
  get [bsonType]() {
    return this._bsontype;
  }
  get [BSON_VERSION_SYMBOL]() {
    return BSON_MAJOR_VERSION;
  }
  [Symbol.for("nodejs.util.inspect.custom")](depth, options, inspect) {
    return this.inspect(depth, options, inspect);
  }
};
var FLOAT = new Float64Array(1);
var FLOAT_BYTES = new Uint8Array(FLOAT.buffer, 0, 8);
FLOAT[0] = -1;
var isBigEndian = FLOAT_BYTES[7] === 0;
var NumberUtils = {
  isBigEndian,
  getNonnegativeInt32LE(source, offset) {
    if (source[offset + 3] > 127) {
      throw new RangeError(`Size cannot be negative at offset: ${offset}`);
    }
    return source[offset] | source[offset + 1] << 8 | source[offset + 2] << 16 | source[offset + 3] << 24;
  },
  getInt32LE(source, offset) {
    return source[offset] | source[offset + 1] << 8 | source[offset + 2] << 16 | source[offset + 3] << 24;
  },
  getUint32LE(source, offset) {
    return source[offset] + source[offset + 1] * 256 + source[offset + 2] * 65536 + source[offset + 3] * 16777216;
  },
  getUint32BE(source, offset) {
    return source[offset + 3] + source[offset + 2] * 256 + source[offset + 1] * 65536 + source[offset] * 16777216;
  },
  getBigInt64LE(source, offset) {
    const hi = BigInt(source[offset + 4] + source[offset + 5] * 256 + source[offset + 6] * 65536 + (source[offset + 7] << 24));
    const lo = BigInt(source[offset] + source[offset + 1] * 256 + source[offset + 2] * 65536 + source[offset + 3] * 16777216);
    return (hi << 32n) + lo;
  },
  getFloat64LE: isBigEndian ? (source, offset) => {
    FLOAT_BYTES[7] = source[offset];
    FLOAT_BYTES[6] = source[offset + 1];
    FLOAT_BYTES[5] = source[offset + 2];
    FLOAT_BYTES[4] = source[offset + 3];
    FLOAT_BYTES[3] = source[offset + 4];
    FLOAT_BYTES[2] = source[offset + 5];
    FLOAT_BYTES[1] = source[offset + 6];
    FLOAT_BYTES[0] = source[offset + 7];
    return FLOAT[0];
  } : (source, offset) => {
    FLOAT_BYTES[0] = source[offset];
    FLOAT_BYTES[1] = source[offset + 1];
    FLOAT_BYTES[2] = source[offset + 2];
    FLOAT_BYTES[3] = source[offset + 3];
    FLOAT_BYTES[4] = source[offset + 4];
    FLOAT_BYTES[5] = source[offset + 5];
    FLOAT_BYTES[6] = source[offset + 6];
    FLOAT_BYTES[7] = source[offset + 7];
    return FLOAT[0];
  },
  setInt32BE(destination, offset, value) {
    destination[offset + 3] = value;
    value >>>= 8;
    destination[offset + 2] = value;
    value >>>= 8;
    destination[offset + 1] = value;
    value >>>= 8;
    destination[offset] = value;
    return 4;
  },
  setInt32LE(destination, offset, value) {
    destination[offset] = value;
    value >>>= 8;
    destination[offset + 1] = value;
    value >>>= 8;
    destination[offset + 2] = value;
    value >>>= 8;
    destination[offset + 3] = value;
    return 4;
  },
  setBigInt64LE(destination, offset, value) {
    const mask32bits = 0xffffffffn;
    let lo = Number(value & mask32bits);
    destination[offset] = lo;
    lo >>= 8;
    destination[offset + 1] = lo;
    lo >>= 8;
    destination[offset + 2] = lo;
    lo >>= 8;
    destination[offset + 3] = lo;
    let hi = Number(value >> 32n & mask32bits);
    destination[offset + 4] = hi;
    hi >>= 8;
    destination[offset + 5] = hi;
    hi >>= 8;
    destination[offset + 6] = hi;
    hi >>= 8;
    destination[offset + 7] = hi;
    return 8;
  },
  setFloat64LE: isBigEndian ? (destination, offset, value) => {
    FLOAT[0] = value;
    destination[offset] = FLOAT_BYTES[7];
    destination[offset + 1] = FLOAT_BYTES[6];
    destination[offset + 2] = FLOAT_BYTES[5];
    destination[offset + 3] = FLOAT_BYTES[4];
    destination[offset + 4] = FLOAT_BYTES[3];
    destination[offset + 5] = FLOAT_BYTES[2];
    destination[offset + 6] = FLOAT_BYTES[1];
    destination[offset + 7] = FLOAT_BYTES[0];
    return 8;
  } : (destination, offset, value) => {
    FLOAT[0] = value;
    destination[offset] = FLOAT_BYTES[0];
    destination[offset + 1] = FLOAT_BYTES[1];
    destination[offset + 2] = FLOAT_BYTES[2];
    destination[offset + 3] = FLOAT_BYTES[3];
    destination[offset + 4] = FLOAT_BYTES[4];
    destination[offset + 5] = FLOAT_BYTES[5];
    destination[offset + 6] = FLOAT_BYTES[6];
    destination[offset + 7] = FLOAT_BYTES[7];
    return 8;
  }
};
var _Binary = class _Binary extends BSONValue {
  constructor(buffer2, subType) {
    super();
    __publicField(this, "buffer");
    __publicField(this, "sub_type");
    __publicField(this, "position");
    if (!(buffer2 == null) && typeof buffer2 === "string" && !ArrayBuffer.isView(buffer2) && !isAnyArrayBuffer(buffer2) && !Array.isArray(buffer2)) {
      throw new BSONError("Binary can only be constructed from Uint8Array or number[]");
    }
    this.sub_type = subType ?? _Binary.BSON_BINARY_SUBTYPE_DEFAULT;
    if (buffer2 == null) {
      this.buffer = ByteUtils.allocate(_Binary.BUFFER_SIZE);
      this.position = 0;
    } else {
      this.buffer = Array.isArray(buffer2) ? ByteUtils.fromNumberArray(buffer2) : ByteUtils.toLocalBufferType(buffer2);
      this.position = this.buffer.byteLength;
    }
  }
  get _bsontype() {
    return "Binary";
  }
  put(byteValue) {
    if (typeof byteValue === "string" && byteValue.length !== 1) {
      throw new BSONError("only accepts single character String");
    } else if (typeof byteValue !== "number" && byteValue.length !== 1)
      throw new BSONError("only accepts single character Uint8Array or Array");
    let decodedByte;
    if (typeof byteValue === "string") {
      decodedByte = byteValue.charCodeAt(0);
    } else if (typeof byteValue === "number") {
      decodedByte = byteValue;
    } else {
      decodedByte = byteValue[0];
    }
    if (decodedByte < 0 || decodedByte > 255) {
      throw new BSONError("only accepts number in a valid unsigned byte range 0-255");
    }
    if (this.buffer.byteLength > this.position) {
      this.buffer[this.position++] = decodedByte;
    } else {
      const newSpace = ByteUtils.allocate(_Binary.BUFFER_SIZE + this.buffer.length);
      newSpace.set(this.buffer, 0);
      this.buffer = newSpace;
      this.buffer[this.position++] = decodedByte;
    }
  }
  write(sequence, offset) {
    offset = typeof offset === "number" ? offset : this.position;
    if (this.buffer.byteLength < offset + sequence.length) {
      const newSpace = ByteUtils.allocate(this.buffer.byteLength + sequence.length);
      newSpace.set(this.buffer, 0);
      this.buffer = newSpace;
    }
    if (ArrayBuffer.isView(sequence)) {
      this.buffer.set(ByteUtils.toLocalBufferType(sequence), offset);
      this.position = offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;
    } else if (typeof sequence === "string") {
      throw new BSONError("input cannot be string");
    }
  }
  read(position, length) {
    length = length && length > 0 ? length : this.position;
    const end = position + length;
    return this.buffer.subarray(position, end > this.position ? this.position : end);
  }
  value() {
    return this.buffer.length === this.position ? this.buffer : this.buffer.subarray(0, this.position);
  }
  length() {
    return this.position;
  }
  toJSON() {
    return ByteUtils.toBase64(this.buffer.subarray(0, this.position));
  }
  toString(encoding) {
    if (encoding === "hex")
      return ByteUtils.toHex(this.buffer.subarray(0, this.position));
    if (encoding === "base64")
      return ByteUtils.toBase64(this.buffer.subarray(0, this.position));
    if (encoding === "utf8" || encoding === "utf-8")
      return ByteUtils.toUTF8(this.buffer, 0, this.position, false);
    return ByteUtils.toUTF8(this.buffer, 0, this.position, false);
  }
  toExtendedJSON(options) {
    options = options || {};
    if (this.sub_type === _Binary.SUBTYPE_VECTOR) {
      validateBinaryVector(this);
    }
    const base64String = ByteUtils.toBase64(this.buffer);
    const subType = Number(this.sub_type).toString(16);
    if (options.legacy) {
      return {
        $binary: base64String,
        $type: subType.length === 1 ? "0" + subType : subType
      };
    }
    return {
      $binary: {
        base64: base64String,
        subType: subType.length === 1 ? "0" + subType : subType
      }
    };
  }
  toUUID() {
    if (this.sub_type === _Binary.SUBTYPE_UUID) {
      return new UUID(this.buffer.subarray(0, this.position));
    }
    throw new BSONError(`Binary sub_type "${this.sub_type}" is not supported for converting to UUID. Only "${_Binary.SUBTYPE_UUID}" is currently supported.`);
  }
  static createFromHexString(hex, subType) {
    return new _Binary(ByteUtils.fromHex(hex), subType);
  }
  static createFromBase64(base64, subType) {
    return new _Binary(ByteUtils.fromBase64(base64), subType);
  }
  static fromExtendedJSON(doc, options) {
    options = options || {};
    let data;
    let type;
    if ("$binary" in doc) {
      if (options.legacy && typeof doc.$binary === "string" && "$type" in doc) {
        type = doc.$type ? parseInt(doc.$type, 16) : 0;
        data = ByteUtils.fromBase64(doc.$binary);
      } else {
        if (typeof doc.$binary !== "string") {
          type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;
          data = ByteUtils.fromBase64(doc.$binary.base64);
        }
      }
    } else if ("$uuid" in doc) {
      type = 4;
      data = UUID.bytesFromString(doc.$uuid);
    }
    if (!data) {
      throw new BSONError(`Unexpected Binary Extended JSON format ${JSON.stringify(doc)}`);
    }
    return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new _Binary(data, type);
  }
  inspect(depth, options, inspect) {
    inspect ?? (inspect = defaultInspect);
    const base64 = ByteUtils.toBase64(this.buffer.subarray(0, this.position));
    const base64Arg = inspect(base64, options);
    const subTypeArg = inspect(this.sub_type, options);
    return `Binary.createFromBase64(${base64Arg}, ${subTypeArg})`;
  }
  toInt8Array() {
    if (this.sub_type !== _Binary.SUBTYPE_VECTOR) {
      throw new BSONError("Binary sub_type is not Vector");
    }
    if (this.buffer[0] !== _Binary.VECTOR_TYPE.Int8) {
      throw new BSONError("Binary datatype field is not Int8");
    }
    validateBinaryVector(this);
    return new Int8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));
  }
  toFloat32Array() {
    if (this.sub_type !== _Binary.SUBTYPE_VECTOR) {
      throw new BSONError("Binary sub_type is not Vector");
    }
    if (this.buffer[0] !== _Binary.VECTOR_TYPE.Float32) {
      throw new BSONError("Binary datatype field is not Float32");
    }
    validateBinaryVector(this);
    const floatBytes = new Uint8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));
    if (NumberUtils.isBigEndian)
      ByteUtils.swap32(floatBytes);
    return new Float32Array(floatBytes.buffer);
  }
  toPackedBits() {
    if (this.sub_type !== _Binary.SUBTYPE_VECTOR) {
      throw new BSONError("Binary sub_type is not Vector");
    }
    if (this.buffer[0] !== _Binary.VECTOR_TYPE.PackedBit) {
      throw new BSONError("Binary datatype field is not packed bit");
    }
    validateBinaryVector(this);
    return new Uint8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));
  }
  toBits() {
    if (this.sub_type !== _Binary.SUBTYPE_VECTOR) {
      throw new BSONError("Binary sub_type is not Vector");
    }
    if (this.buffer[0] !== _Binary.VECTOR_TYPE.PackedBit) {
      throw new BSONError("Binary datatype field is not packed bit");
    }
    validateBinaryVector(this);
    const byteCount = this.length() - 2;
    const bitCount = byteCount * 8 - this.buffer[1];
    const bits = new Int8Array(bitCount);
    for (let bitOffset = 0; bitOffset < bits.length; bitOffset++) {
      const byteOffset = bitOffset / 8 | 0;
      const byte = this.buffer[byteOffset + 2];
      const shift = 7 - bitOffset % 8;
      const bit = byte >> shift & 1;
      bits[bitOffset] = bit;
    }
    return bits;
  }
  static fromInt8Array(array) {
    const buffer2 = ByteUtils.allocate(array.byteLength + 2);
    buffer2[0] = _Binary.VECTOR_TYPE.Int8;
    buffer2[1] = 0;
    const intBytes = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
    buffer2.set(intBytes, 2);
    const bin = new this(buffer2, this.SUBTYPE_VECTOR);
    validateBinaryVector(bin);
    return bin;
  }
  static fromFloat32Array(array) {
    const binaryBytes = ByteUtils.allocate(array.byteLength + 2);
    binaryBytes[0] = _Binary.VECTOR_TYPE.Float32;
    binaryBytes[1] = 0;
    const floatBytes = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
    binaryBytes.set(floatBytes, 2);
    if (NumberUtils.isBigEndian)
      ByteUtils.swap32(new Uint8Array(binaryBytes.buffer, 2));
    const bin = new this(binaryBytes, this.SUBTYPE_VECTOR);
    validateBinaryVector(bin);
    return bin;
  }
  static fromPackedBits(array, padding = 0) {
    const buffer2 = ByteUtils.allocate(array.byteLength + 2);
    buffer2[0] = _Binary.VECTOR_TYPE.PackedBit;
    buffer2[1] = padding;
    buffer2.set(array, 2);
    const bin = new this(buffer2, this.SUBTYPE_VECTOR);
    validateBinaryVector(bin);
    return bin;
  }
  static fromBits(bits) {
    const byteLength = bits.length + 7 >>> 3;
    const bytes = new Uint8Array(byteLength + 2);
    bytes[0] = _Binary.VECTOR_TYPE.PackedBit;
    const remainder = bits.length % 8;
    bytes[1] = remainder === 0 ? 0 : 8 - remainder;
    for (let bitOffset = 0; bitOffset < bits.length; bitOffset++) {
      const byteOffset = bitOffset >>> 3;
      const bit = bits[bitOffset];
      if (bit !== 0 && bit !== 1) {
        throw new BSONError(`Invalid bit value at ${bitOffset}: must be 0 or 1, found ${bits[bitOffset]}`);
      }
      if (bit === 0)
        continue;
      const shift = 7 - bitOffset % 8;
      bytes[byteOffset + 2] |= bit << shift;
    }
    return new this(bytes, _Binary.SUBTYPE_VECTOR);
  }
};
__publicField(_Binary, "BSON_BINARY_SUBTYPE_DEFAULT", 0);
__publicField(_Binary, "BUFFER_SIZE", 256);
__publicField(_Binary, "SUBTYPE_DEFAULT", 0);
__publicField(_Binary, "SUBTYPE_FUNCTION", 1);
__publicField(_Binary, "SUBTYPE_BYTE_ARRAY", 2);
__publicField(_Binary, "SUBTYPE_UUID_OLD", 3);
__publicField(_Binary, "SUBTYPE_UUID", 4);
__publicField(_Binary, "SUBTYPE_MD5", 5);
__publicField(_Binary, "SUBTYPE_ENCRYPTED", 6);
__publicField(_Binary, "SUBTYPE_COLUMN", 7);
__publicField(_Binary, "SUBTYPE_SENSITIVE", 8);
__publicField(_Binary, "SUBTYPE_VECTOR", 9);
__publicField(_Binary, "SUBTYPE_USER_DEFINED", 128);
__publicField(_Binary, "VECTOR_TYPE", Object.freeze({
  Int8: 3,
  Float32: 39,
  PackedBit: 16
}));
var Binary = _Binary;
function validateBinaryVector(vector) {
  if (vector.sub_type !== Binary.SUBTYPE_VECTOR)
    return;
  const size = vector.position;
  const datatype = vector.buffer[0];
  const padding = vector.buffer[1];
  if ((datatype === Binary.VECTOR_TYPE.Float32 || datatype === Binary.VECTOR_TYPE.Int8) && padding !== 0) {
    throw new BSONError("Invalid Vector: padding must be zero for int8 and float32 vectors");
  }
  if (datatype === Binary.VECTOR_TYPE.Float32) {
    if (size !== 0 && size - 2 !== 0 && (size - 2) % 4 !== 0) {
      throw new BSONError("Invalid Vector: Float32 vector must contain a multiple of 4 bytes");
    }
  }
  if (datatype === Binary.VECTOR_TYPE.PackedBit && padding !== 0 && size === 2) {
    throw new BSONError("Invalid Vector: padding must be zero for packed bit vectors that are empty");
  }
  if (datatype === Binary.VECTOR_TYPE.PackedBit && padding > 7) {
    throw new BSONError(`Invalid Vector: padding must be a value between 0 and 7. found: ${padding}`);
  }
}
var UUID_BYTE_LENGTH = 16;
var UUID_WITHOUT_DASHES = /^[0-9A-F]{32}$/i;
var UUID_WITH_DASHES = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;
var UUID = class _UUID extends Binary {
  constructor(input) {
    let bytes;
    if (input == null) {
      bytes = _UUID.generate();
    } else if (input instanceof _UUID) {
      bytes = ByteUtils.toLocalBufferType(new Uint8Array(input.buffer));
    } else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {
      bytes = ByteUtils.toLocalBufferType(input);
    } else if (typeof input === "string") {
      bytes = _UUID.bytesFromString(input);
    } else {
      throw new BSONError("Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).");
    }
    super(bytes, BSON_BINARY_SUBTYPE_UUID_NEW);
  }
  get id() {
    return this.buffer;
  }
  set id(value) {
    this.buffer = value;
  }
  toHexString(includeDashes = true) {
    if (includeDashes) {
      return [
        ByteUtils.toHex(this.buffer.subarray(0, 4)),
        ByteUtils.toHex(this.buffer.subarray(4, 6)),
        ByteUtils.toHex(this.buffer.subarray(6, 8)),
        ByteUtils.toHex(this.buffer.subarray(8, 10)),
        ByteUtils.toHex(this.buffer.subarray(10, 16))
      ].join("-");
    }
    return ByteUtils.toHex(this.buffer);
  }
  toString(encoding) {
    if (encoding === "hex")
      return ByteUtils.toHex(this.id);
    if (encoding === "base64")
      return ByteUtils.toBase64(this.id);
    return this.toHexString();
  }
  toJSON() {
    return this.toHexString();
  }
  equals(otherId) {
    if (!otherId) {
      return false;
    }
    if (otherId instanceof _UUID) {
      return ByteUtils.equals(otherId.id, this.id);
    }
    try {
      return ByteUtils.equals(new _UUID(otherId).id, this.id);
    } catch {
      return false;
    }
  }
  toBinary() {
    return new Binary(this.id, Binary.SUBTYPE_UUID);
  }
  static generate() {
    const bytes = ByteUtils.randomBytes(UUID_BYTE_LENGTH);
    bytes[6] = bytes[6] & 15 | 64;
    bytes[8] = bytes[8] & 63 | 128;
    return bytes;
  }
  static isValid(input) {
    if (!input) {
      return false;
    }
    if (typeof input === "string") {
      return _UUID.isValidUUIDString(input);
    }
    if (isUint8Array(input)) {
      return input.byteLength === UUID_BYTE_LENGTH;
    }
    return input._bsontype === "Binary" && input.sub_type === this.SUBTYPE_UUID && input.buffer.byteLength === 16;
  }
  static createFromHexString(hexString) {
    const buffer2 = _UUID.bytesFromString(hexString);
    return new _UUID(buffer2);
  }
  static createFromBase64(base64) {
    return new _UUID(ByteUtils.fromBase64(base64));
  }
  static bytesFromString(representation) {
    if (!_UUID.isValidUUIDString(representation)) {
      throw new BSONError("UUID string representation must be 32 hex digits or canonical hyphenated representation");
    }
    return ByteUtils.fromHex(representation.replace(/-/g, ""));
  }
  static isValidUUIDString(representation) {
    return UUID_WITHOUT_DASHES.test(representation) || UUID_WITH_DASHES.test(representation);
  }
  inspect(depth, options, inspect) {
    inspect ?? (inspect = defaultInspect);
    return `new UUID(${inspect(this.toHexString(), options)})`;
  }
};
var Code = class _Code extends BSONValue {
  constructor(code, scope) {
    super();
    __publicField(this, "code");
    __publicField(this, "scope");
    this.code = code.toString();
    this.scope = scope ?? null;
  }
  get _bsontype() {
    return "Code";
  }
  toJSON() {
    if (this.scope != null) {
      return { code: this.code, scope: this.scope };
    }
    return { code: this.code };
  }
  toExtendedJSON() {
    if (this.scope) {
      return { $code: this.code, $scope: this.scope };
    }
    return { $code: this.code };
  }
  static fromExtendedJSON(doc) {
    return new _Code(doc.$code, doc.$scope);
  }
  inspect(depth, options, inspect) {
    inspect ?? (inspect = defaultInspect);
    let parametersString = inspect(this.code, options);
    const multiLineFn = parametersString.includes("\n");
    if (this.scope != null) {
      parametersString += `,${multiLineFn ? "\n" : " "}${inspect(this.scope, options)}`;
    }
    const endingNewline = multiLineFn && this.scope === null;
    return `new Code(${multiLineFn ? "\n" : ""}${parametersString}${endingNewline ? "\n" : ""})`;
  }
};
function isDBRefLike(value) {
  return value != null && typeof value === "object" && "$id" in value && value.$id != null && "$ref" in value && typeof value.$ref === "string" && (!("$db" in value) || "$db" in value && typeof value.$db === "string");
}
var DBRef = class _DBRef extends BSONValue {
  constructor(collection, oid, db, fields) {
    super();
    __publicField(this, "collection");
    __publicField(this, "oid");
    __publicField(this, "db");
    __publicField(this, "fields");
    const parts = collection.split(".");
    if (parts.length === 2) {
      db = parts.shift();
      collection = parts.shift();
    }
    this.collection = collection;
    this.oid = oid;
    this.db = db;
    this.fields = fields || {};
  }
  get _bsontype() {
    return "DBRef";
  }
  get namespace() {
    return this.collection;
  }
  set namespace(value) {
    this.collection = value;
  }
  toJSON() {
    const o5 = Object.assign({
      $ref: this.collection,
      $id: this.oid
    }, this.fields);
    if (this.db != null)
      o5.$db = this.db;
    return o5;
  }
  toExtendedJSON(options) {
    options = options || {};
    let o5 = {
      $ref: this.collection,
      $id: this.oid
    };
    if (options.legacy) {
      return o5;
    }
    if (this.db)
      o5.$db = this.db;
    o5 = Object.assign(o5, this.fields);
    return o5;
  }
  static fromExtendedJSON(doc) {
    const copy = Object.assign({}, doc);
    delete copy.$ref;
    delete copy.$id;
    delete copy.$db;
    return new _DBRef(doc.$ref, doc.$id, doc.$db, copy);
  }
  inspect(depth, options, inspect) {
    inspect ?? (inspect = defaultInspect);
    const args = [
      inspect(this.namespace, options),
      inspect(this.oid, options),
      ...this.db ? [inspect(this.db, options)] : [],
      ...Object.keys(this.fields).length > 0 ? [inspect(this.fields, options)] : []
    ];
    args[1] = inspect === defaultInspect ? `new ObjectId(${args[1]})` : args[1];
    return `new DBRef(${args.join(", ")})`;
  }
};
function removeLeadingZerosAndExplicitPlus(str) {
  if (str === "") {
    return str;
  }
  let startIndex = 0;
  const isNegative = str[startIndex] === "-";
  const isExplicitlyPositive = str[startIndex] === "+";
  if (isExplicitlyPositive || isNegative) {
    startIndex += 1;
  }
  let foundInsignificantZero = false;
  for (; startIndex < str.length && str[startIndex] === "0"; ++startIndex) {
    foundInsignificantZero = true;
  }
  if (!foundInsignificantZero) {
    return isExplicitlyPositive ? str.slice(1) : str;
  }
  return `${isNegative ? "-" : ""}${str.length === startIndex ? "0" : str.slice(startIndex)}`;
}
function validateStringCharacters(str, radix) {
  radix = radix ?? 10;
  const validCharacters = "0123456789abcdefghijklmnopqrstuvwxyz".slice(0, radix);
  const regex = new RegExp(`[^-+${validCharacters}]`, "i");
  return regex.test(str) ? false : str;
}
var wasm = void 0;
try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
} catch {
}
var TWO_PWR_16_DBL = 1 << 16;
var TWO_PWR_24_DBL = 1 << 24;
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
var INT_CACHE = {};
var UINT_CACHE = {};
var MAX_INT64_STRING_LENGTH = 20;
var DECIMAL_REG_EX = /^(\+?0|(\+|-)?[1-9][0-9]*)$/;
var _Long = class _Long extends BSONValue {
  constructor(lowOrValue = 0, highOrUnsigned, unsigned) {
    super();
    __publicField(this, "high");
    __publicField(this, "low");
    __publicField(this, "unsigned");
    const unsignedBool = typeof highOrUnsigned === "boolean" ? highOrUnsigned : Boolean(unsigned);
    const high = typeof highOrUnsigned === "number" ? highOrUnsigned : 0;
    const res = typeof lowOrValue === "string" ? _Long.fromString(lowOrValue, unsignedBool) : typeof lowOrValue === "bigint" ? _Long.fromBigInt(lowOrValue, unsignedBool) : { low: lowOrValue | 0, high: high | 0, unsigned: unsignedBool };
    this.low = res.low;
    this.high = res.high;
    this.unsigned = res.unsigned;
  }
  get _bsontype() {
    return "Long";
  }
  get __isLong__() {
    return true;
  }
  static fromBits(lowBits, highBits, unsigned) {
    return new _Long(lowBits, highBits, unsigned);
  }
  static fromInt(value, unsigned) {
    let obj, cachedObj, cache;
    if (unsigned) {
      value >>>= 0;
      if (cache = 0 <= value && value < 256) {
        cachedObj = UINT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = _Long.fromBits(value, (value | 0) < 0 ? -1 : 0, true);
      if (cache)
        UINT_CACHE[value] = obj;
      return obj;
    } else {
      value |= 0;
      if (cache = -128 <= value && value < 128) {
        cachedObj = INT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = _Long.fromBits(value, value < 0 ? -1 : 0, false);
      if (cache)
        INT_CACHE[value] = obj;
      return obj;
    }
  }
  static fromNumber(value, unsigned) {
    if (isNaN(value))
      return unsigned ? _Long.UZERO : _Long.ZERO;
    if (unsigned) {
      if (value < 0)
        return _Long.UZERO;
      if (value >= TWO_PWR_64_DBL)
        return _Long.MAX_UNSIGNED_VALUE;
    } else {
      if (value <= -TWO_PWR_63_DBL)
        return _Long.MIN_VALUE;
      if (value + 1 >= TWO_PWR_63_DBL)
        return _Long.MAX_VALUE;
    }
    if (value < 0)
      return _Long.fromNumber(-value, unsigned).neg();
    return _Long.fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
  }
  static fromBigInt(value, unsigned) {
    const FROM_BIGINT_BIT_MASK = 0xffffffffn;
    const FROM_BIGINT_BIT_SHIFT = 32n;
    return new _Long(Number(value & FROM_BIGINT_BIT_MASK), Number(value >> FROM_BIGINT_BIT_SHIFT & FROM_BIGINT_BIT_MASK), unsigned);
  }
  static _fromString(str, unsigned, radix) {
    if (str.length === 0)
      throw new BSONError("empty string");
    if (radix < 2 || 36 < radix)
      throw new BSONError("radix");
    let p4;
    if ((p4 = str.indexOf("-")) > 0)
      throw new BSONError("interior hyphen");
    else if (p4 === 0) {
      return _Long._fromString(str.substring(1), unsigned, radix).neg();
    }
    const radixToPower = _Long.fromNumber(Math.pow(radix, 8));
    let result = _Long.ZERO;
    for (let i3 = 0; i3 < str.length; i3 += 8) {
      const size = Math.min(8, str.length - i3), value = parseInt(str.substring(i3, i3 + size), radix);
      if (size < 8) {
        const power = _Long.fromNumber(Math.pow(radix, size));
        result = result.mul(power).add(_Long.fromNumber(value));
      } else {
        result = result.mul(radixToPower);
        result = result.add(_Long.fromNumber(value));
      }
    }
    result.unsigned = unsigned;
    return result;
  }
  static fromStringStrict(str, unsignedOrRadix, radix) {
    let unsigned = false;
    if (typeof unsignedOrRadix === "number") {
      radix = unsignedOrRadix, unsignedOrRadix = false;
    } else {
      unsigned = !!unsignedOrRadix;
    }
    radix ?? (radix = 10);
    if (str.trim() !== str) {
      throw new BSONError(`Input: '${str}' contains leading and/or trailing whitespace`);
    }
    if (!validateStringCharacters(str, radix)) {
      throw new BSONError(`Input: '${str}' contains invalid characters for radix: ${radix}`);
    }
    const cleanedStr = removeLeadingZerosAndExplicitPlus(str);
    const result = _Long._fromString(cleanedStr, unsigned, radix);
    if (result.toString(radix).toLowerCase() !== cleanedStr.toLowerCase()) {
      throw new BSONError(`Input: ${str} is not representable as ${result.unsigned ? "an unsigned" : "a signed"} 64-bit Long ${radix != null ? `with radix: ${radix}` : ""}`);
    }
    return result;
  }
  static fromString(str, unsignedOrRadix, radix) {
    let unsigned = false;
    if (typeof unsignedOrRadix === "number") {
      radix = unsignedOrRadix, unsignedOrRadix = false;
    } else {
      unsigned = !!unsignedOrRadix;
    }
    radix ?? (radix = 10);
    if (str === "NaN" && radix < 24) {
      return _Long.ZERO;
    } else if ((str === "Infinity" || str === "+Infinity" || str === "-Infinity") && radix < 35) {
      return _Long.ZERO;
    }
    return _Long._fromString(str, unsigned, radix);
  }
  static fromBytes(bytes, unsigned, le) {
    return le ? _Long.fromBytesLE(bytes, unsigned) : _Long.fromBytesBE(bytes, unsigned);
  }
  static fromBytesLE(bytes, unsigned) {
    return new _Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
  }
  static fromBytesBE(bytes, unsigned) {
    return new _Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
  }
  static isLong(value) {
    return value != null && typeof value === "object" && "__isLong__" in value && value.__isLong__ === true;
  }
  static fromValue(val, unsigned) {
    if (typeof val === "number")
      return _Long.fromNumber(val, unsigned);
    if (typeof val === "string")
      return _Long.fromString(val, unsigned);
    return _Long.fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
  }
  add(addend) {
    if (!_Long.isLong(addend))
      addend = _Long.fromValue(addend);
    const a48 = this.high >>> 16;
    const a32 = this.high & 65535;
    const a16 = this.low >>> 16;
    const a00 = this.low & 65535;
    const b48 = addend.high >>> 16;
    const b32 = addend.high & 65535;
    const b16 = addend.low >>> 16;
    const b00 = addend.low & 65535;
    let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 + b48;
    c48 &= 65535;
    return _Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  }
  and(other) {
    if (!_Long.isLong(other))
      other = _Long.fromValue(other);
    return _Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);
  }
  compare(other) {
    if (!_Long.isLong(other))
      other = _Long.fromValue(other);
    if (this.eq(other))
      return 0;
    const thisNeg = this.isNegative(), otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
      return -1;
    if (!thisNeg && otherNeg)
      return 1;
    if (!this.unsigned)
      return this.sub(other).isNegative() ? -1 : 1;
    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
  }
  comp(other) {
    return this.compare(other);
  }
  divide(divisor) {
    if (!_Long.isLong(divisor))
      divisor = _Long.fromValue(divisor);
    if (divisor.isZero())
      throw new BSONError("division by zero");
    if (wasm) {
      if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
        return this;
      }
      const low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
      return _Long.fromBits(low, wasm.get_high(), this.unsigned);
    }
    if (this.isZero())
      return this.unsigned ? _Long.UZERO : _Long.ZERO;
    let approx, rem, res;
    if (!this.unsigned) {
      if (this.eq(_Long.MIN_VALUE)) {
        if (divisor.eq(_Long.ONE) || divisor.eq(_Long.NEG_ONE))
          return _Long.MIN_VALUE;
        else if (divisor.eq(_Long.MIN_VALUE))
          return _Long.ONE;
        else {
          const halfThis = this.shr(1);
          approx = halfThis.div(divisor).shl(1);
          if (approx.eq(_Long.ZERO)) {
            return divisor.isNegative() ? _Long.ONE : _Long.NEG_ONE;
          } else {
            rem = this.sub(divisor.mul(approx));
            res = approx.add(rem.div(divisor));
            return res;
          }
        }
      } else if (divisor.eq(_Long.MIN_VALUE))
        return this.unsigned ? _Long.UZERO : _Long.ZERO;
      if (this.isNegative()) {
        if (divisor.isNegative())
          return this.neg().div(divisor.neg());
        return this.neg().div(divisor).neg();
      } else if (divisor.isNegative())
        return this.div(divisor.neg()).neg();
      res = _Long.ZERO;
    } else {
      if (!divisor.unsigned)
        divisor = divisor.toUnsigned();
      if (divisor.gt(this))
        return _Long.UZERO;
      if (divisor.gt(this.shru(1)))
        return _Long.UONE;
      res = _Long.UZERO;
    }
    rem = this;
    while (rem.gte(divisor)) {
      approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
      const log2 = Math.ceil(Math.log(approx) / Math.LN2);
      const delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
      let approxRes = _Long.fromNumber(approx);
      let approxRem = approxRes.mul(divisor);
      while (approxRem.isNegative() || approxRem.gt(rem)) {
        approx -= delta;
        approxRes = _Long.fromNumber(approx, this.unsigned);
        approxRem = approxRes.mul(divisor);
      }
      if (approxRes.isZero())
        approxRes = _Long.ONE;
      res = res.add(approxRes);
      rem = rem.sub(approxRem);
    }
    return res;
  }
  div(divisor) {
    return this.divide(divisor);
  }
  equals(other) {
    if (!_Long.isLong(other))
      other = _Long.fromValue(other);
    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
      return false;
    return this.high === other.high && this.low === other.low;
  }
  eq(other) {
    return this.equals(other);
  }
  getHighBits() {
    return this.high;
  }
  getHighBitsUnsigned() {
    return this.high >>> 0;
  }
  getLowBits() {
    return this.low;
  }
  getLowBitsUnsigned() {
    return this.low >>> 0;
  }
  getNumBitsAbs() {
    if (this.isNegative()) {
      return this.eq(_Long.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    }
    const val = this.high !== 0 ? this.high : this.low;
    let bit;
    for (bit = 31; bit > 0; bit--)
      if ((val & 1 << bit) !== 0)
        break;
    return this.high !== 0 ? bit + 33 : bit + 1;
  }
  greaterThan(other) {
    return this.comp(other) > 0;
  }
  gt(other) {
    return this.greaterThan(other);
  }
  greaterThanOrEqual(other) {
    return this.comp(other) >= 0;
  }
  gte(other) {
    return this.greaterThanOrEqual(other);
  }
  ge(other) {
    return this.greaterThanOrEqual(other);
  }
  isEven() {
    return (this.low & 1) === 0;
  }
  isNegative() {
    return !this.unsigned && this.high < 0;
  }
  isOdd() {
    return (this.low & 1) === 1;
  }
  isPositive() {
    return this.unsigned || this.high >= 0;
  }
  isZero() {
    return this.high === 0 && this.low === 0;
  }
  lessThan(other) {
    return this.comp(other) < 0;
  }
  lt(other) {
    return this.lessThan(other);
  }
  lessThanOrEqual(other) {
    return this.comp(other) <= 0;
  }
  lte(other) {
    return this.lessThanOrEqual(other);
  }
  modulo(divisor) {
    if (!_Long.isLong(divisor))
      divisor = _Long.fromValue(divisor);
    if (wasm) {
      const low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
      return _Long.fromBits(low, wasm.get_high(), this.unsigned);
    }
    return this.sub(this.div(divisor).mul(divisor));
  }
  mod(divisor) {
    return this.modulo(divisor);
  }
  rem(divisor) {
    return this.modulo(divisor);
  }
  multiply(multiplier) {
    if (this.isZero())
      return _Long.ZERO;
    if (!_Long.isLong(multiplier))
      multiplier = _Long.fromValue(multiplier);
    if (wasm) {
      const low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
      return _Long.fromBits(low, wasm.get_high(), this.unsigned);
    }
    if (multiplier.isZero())
      return _Long.ZERO;
    if (this.eq(_Long.MIN_VALUE))
      return multiplier.isOdd() ? _Long.MIN_VALUE : _Long.ZERO;
    if (multiplier.eq(_Long.MIN_VALUE))
      return this.isOdd() ? _Long.MIN_VALUE : _Long.ZERO;
    if (this.isNegative()) {
      if (multiplier.isNegative())
        return this.neg().mul(multiplier.neg());
      else
        return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
      return this.mul(multiplier.neg()).neg();
    if (this.lt(_Long.TWO_PWR_24) && multiplier.lt(_Long.TWO_PWR_24))
      return _Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
    const a48 = this.high >>> 16;
    const a32 = this.high & 65535;
    const a16 = this.low >>> 16;
    const a00 = this.low & 65535;
    const b48 = multiplier.high >>> 16;
    const b32 = multiplier.high & 65535;
    const b16 = multiplier.low >>> 16;
    const b00 = multiplier.low & 65535;
    let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 65535;
    return _Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  }
  mul(multiplier) {
    return this.multiply(multiplier);
  }
  negate() {
    if (!this.unsigned && this.eq(_Long.MIN_VALUE))
      return _Long.MIN_VALUE;
    return this.not().add(_Long.ONE);
  }
  neg() {
    return this.negate();
  }
  not() {
    return _Long.fromBits(~this.low, ~this.high, this.unsigned);
  }
  notEquals(other) {
    return !this.equals(other);
  }
  neq(other) {
    return this.notEquals(other);
  }
  ne(other) {
    return this.notEquals(other);
  }
  or(other) {
    if (!_Long.isLong(other))
      other = _Long.fromValue(other);
    return _Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);
  }
  shiftLeft(numBits) {
    if (_Long.isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    else if (numBits < 32)
      return _Long.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
    else
      return _Long.fromBits(0, this.low << numBits - 32, this.unsigned);
  }
  shl(numBits) {
    return this.shiftLeft(numBits);
  }
  shiftRight(numBits) {
    if (_Long.isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    else if (numBits < 32)
      return _Long.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
    else
      return _Long.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
  }
  shr(numBits) {
    return this.shiftRight(numBits);
  }
  shiftRightUnsigned(numBits) {
    if (_Long.isLong(numBits))
      numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
      return this;
    else {
      const high = this.high;
      if (numBits < 32) {
        const low = this.low;
        return _Long.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
      } else if (numBits === 32)
        return _Long.fromBits(high, 0, this.unsigned);
      else
        return _Long.fromBits(high >>> numBits - 32, 0, this.unsigned);
    }
  }
  shr_u(numBits) {
    return this.shiftRightUnsigned(numBits);
  }
  shru(numBits) {
    return this.shiftRightUnsigned(numBits);
  }
  subtract(subtrahend) {
    if (!_Long.isLong(subtrahend))
      subtrahend = _Long.fromValue(subtrahend);
    return this.add(subtrahend.neg());
  }
  sub(subtrahend) {
    return this.subtract(subtrahend);
  }
  toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
  }
  toNumber() {
    if (this.unsigned)
      return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
  }
  toBigInt() {
    return BigInt(this.toString());
  }
  toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
  }
  toBytesLE() {
    const hi = this.high, lo = this.low;
    return [
      lo & 255,
      lo >>> 8 & 255,
      lo >>> 16 & 255,
      lo >>> 24,
      hi & 255,
      hi >>> 8 & 255,
      hi >>> 16 & 255,
      hi >>> 24
    ];
  }
  toBytesBE() {
    const hi = this.high, lo = this.low;
    return [
      hi >>> 24,
      hi >>> 16 & 255,
      hi >>> 8 & 255,
      hi & 255,
      lo >>> 24,
      lo >>> 16 & 255,
      lo >>> 8 & 255,
      lo & 255
    ];
  }
  toSigned() {
    if (!this.unsigned)
      return this;
    return _Long.fromBits(this.low, this.high, false);
  }
  toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
      throw new BSONError("radix");
    if (this.isZero())
      return "0";
    if (this.isNegative()) {
      if (this.eq(_Long.MIN_VALUE)) {
        const radixLong = _Long.fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
        return div.toString(radix) + rem1.toInt().toString(radix);
      } else
        return "-" + this.neg().toString(radix);
    }
    const radixToPower = _Long.fromNumber(Math.pow(radix, 6), this.unsigned);
    let rem = this;
    let result = "";
    while (true) {
      const remDiv = rem.div(radixToPower);
      const intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;
      let digits = intval.toString(radix);
      rem = remDiv;
      if (rem.isZero()) {
        return digits + result;
      } else {
        while (digits.length < 6)
          digits = "0" + digits;
        result = "" + digits + result;
      }
    }
  }
  toUnsigned() {
    if (this.unsigned)
      return this;
    return _Long.fromBits(this.low, this.high, true);
  }
  xor(other) {
    if (!_Long.isLong(other))
      other = _Long.fromValue(other);
    return _Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
  }
  eqz() {
    return this.isZero();
  }
  le(other) {
    return this.lessThanOrEqual(other);
  }
  toExtendedJSON(options) {
    if (options && options.relaxed)
      return this.toNumber();
    return { $numberLong: this.toString() };
  }
  static fromExtendedJSON(doc, options) {
    const { useBigInt64 = false, relaxed = true } = { ...options };
    if (doc.$numberLong.length > MAX_INT64_STRING_LENGTH) {
      throw new BSONError("$numberLong string is too long");
    }
    if (!DECIMAL_REG_EX.test(doc.$numberLong)) {
      throw new BSONError(`$numberLong string "${doc.$numberLong}" is in an invalid format`);
    }
    if (useBigInt64) {
      const bigIntResult = BigInt(doc.$numberLong);
      return BigInt.asIntN(64, bigIntResult);
    }
    const longResult = _Long.fromString(doc.$numberLong);
    if (relaxed) {
      return longResult.toNumber();
    }
    return longResult;
  }
  inspect(depth, options, inspect) {
    inspect ?? (inspect = defaultInspect);
    const longVal = inspect(this.toString(), options);
    const unsignedVal = this.unsigned ? `, ${inspect(this.unsigned, options)}` : "";
    return `new Long(${longVal}${unsignedVal})`;
  }
};
__publicField(_Long, "TWO_PWR_24", _Long.fromInt(TWO_PWR_24_DBL));
__publicField(_Long, "MAX_UNSIGNED_VALUE", _Long.fromBits(4294967295 | 0, 4294967295 | 0, true));
__publicField(_Long, "ZERO", _Long.fromInt(0));
__publicField(_Long, "UZERO", _Long.fromInt(0, true));
__publicField(_Long, "ONE", _Long.fromInt(1));
__publicField(_Long, "UONE", _Long.fromInt(1, true));
__publicField(_Long, "NEG_ONE", _Long.fromInt(-1));
__publicField(_Long, "MAX_VALUE", _Long.fromBits(4294967295 | 0, 2147483647 | 0, false));
__publicField(_Long, "MIN_VALUE", _Long.fromBits(0, 2147483648 | 0, false));
var Long = _Long;
var PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;
var PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i;
var PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i;
var EXPONENT_MAX = 6111;
var EXPONENT_MIN = -6176;
var EXPONENT_BIAS = 6176;
var MAX_DIGITS = 34;
var NAN_BUFFER = ByteUtils.fromNumberArray([
  124,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
].reverse());
var INF_NEGATIVE_BUFFER = ByteUtils.fromNumberArray([
  248,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
].reverse());
var INF_POSITIVE_BUFFER = ByteUtils.fromNumberArray([
  120,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
].reverse());
var EXPONENT_REGEX = /^([-+])?(\d+)?$/;
var COMBINATION_MASK = 31;
var EXPONENT_MASK = 16383;
var COMBINATION_INFINITY = 30;
var COMBINATION_NAN = 31;
function isDigit(value) {
  return !isNaN(parseInt(value, 10));
}
function divideu128(value) {
  const DIVISOR = Long.fromNumber(1e3 * 1e3 * 1e3);
  let _rem = Long.fromNumber(0);
  if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {
    return { quotient: value, rem: _rem };
  }
  for (let i3 = 0; i3 <= 3; i3++) {
    _rem = _rem.shiftLeft(32);
    _rem = _rem.add(new Long(value.parts[i3], 0));
    value.parts[i3] = _rem.div(DIVISOR).low;
    _rem = _rem.modulo(DIVISOR);
  }
  return { quotient: value, rem: _rem };
}
function multiply64x2(left, right) {
  if (!left && !right) {
    return { high: Long.fromNumber(0), low: Long.fromNumber(0) };
  }
  const leftHigh = left.shiftRightUnsigned(32);
  const leftLow = new Long(left.getLowBits(), 0);
  const rightHigh = right.shiftRightUnsigned(32);
  const rightLow = new Long(right.getLowBits(), 0);
  let productHigh = leftHigh.multiply(rightHigh);
  let productMid = leftHigh.multiply(rightLow);
  const productMid2 = leftLow.multiply(rightHigh);
  let productLow = leftLow.multiply(rightLow);
  productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
  productMid = new Long(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));
  productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
  productLow = productMid.shiftLeft(32).add(new Long(productLow.getLowBits(), 0));
  return { high: productHigh, low: productLow };
}
function lessThan(left, right) {
  const uhleft = left.high >>> 0;
  const uhright = right.high >>> 0;
  if (uhleft < uhright) {
    return true;
  } else if (uhleft === uhright) {
    const ulleft = left.low >>> 0;
    const ulright = right.low >>> 0;
    if (ulleft < ulright)
      return true;
  }
  return false;
}
function invalidErr(string, message) {
  throw new BSONError(`"${string}" is not a valid Decimal128 string - ${message}`);
}
var Decimal128 = class _Decimal128 extends BSONValue {
  constructor(bytes) {
    super();
    __publicField(this, "bytes");
    if (typeof bytes === "string") {
      this.bytes = _Decimal128.fromString(bytes).bytes;
    } else if (bytes instanceof Uint8Array || isUint8Array(bytes)) {
      if (bytes.byteLength !== 16) {
        throw new BSONError("Decimal128 must take a Buffer of 16 bytes");
      }
      this.bytes = bytes;
    } else {
      throw new BSONError("Decimal128 must take a Buffer or string");
    }
  }
  get _bsontype() {
    return "Decimal128";
  }
  static fromString(representation) {
    return _Decimal128._fromString(representation, { allowRounding: false });
  }
  static fromStringWithRounding(representation) {
    return _Decimal128._fromString(representation, { allowRounding: true });
  }
  static _fromString(representation, options) {
    let isNegative = false;
    let sawSign = false;
    let sawRadix = false;
    let foundNonZero = false;
    let significantDigits = 0;
    let nDigitsRead = 0;
    let nDigits = 0;
    let radixPosition = 0;
    let firstNonZero = 0;
    const digits = [0];
    let nDigitsStored = 0;
    let digitsInsert = 0;
    let lastDigit = 0;
    let exponent = 0;
    let significandHigh = new Long(0, 0);
    let significandLow = new Long(0, 0);
    let biasedExponent = 0;
    let index = 0;
    if (representation.length >= 7e3) {
      throw new BSONError("" + representation + " not a valid Decimal128 string");
    }
    const stringMatch = representation.match(PARSE_STRING_REGEXP);
    const infMatch = representation.match(PARSE_INF_REGEXP);
    const nanMatch = representation.match(PARSE_NAN_REGEXP);
    if (!stringMatch && !infMatch && !nanMatch || representation.length === 0) {
      throw new BSONError("" + representation + " not a valid Decimal128 string");
    }
    if (stringMatch) {
      const unsignedNumber = stringMatch[2];
      const e2 = stringMatch[4];
      const expSign = stringMatch[5];
      const expNumber = stringMatch[6];
      if (e2 && expNumber === void 0)
        invalidErr(representation, "missing exponent power");
      if (e2 && unsignedNumber === void 0)
        invalidErr(representation, "missing exponent base");
      if (e2 === void 0 && (expSign || expNumber)) {
        invalidErr(representation, "missing e before exponent");
      }
    }
    if (representation[index] === "+" || representation[index] === "-") {
      sawSign = true;
      isNegative = representation[index++] === "-";
    }
    if (!isDigit(representation[index]) && representation[index] !== ".") {
      if (representation[index] === "i" || representation[index] === "I") {
        return new _Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);
      } else if (representation[index] === "N") {
        return new _Decimal128(NAN_BUFFER);
      }
    }
    while (isDigit(representation[index]) || representation[index] === ".") {
      if (representation[index] === ".") {
        if (sawRadix)
          invalidErr(representation, "contains multiple periods");
        sawRadix = true;
        index = index + 1;
        continue;
      }
      if (nDigitsStored < MAX_DIGITS) {
        if (representation[index] !== "0" || foundNonZero) {
          if (!foundNonZero) {
            firstNonZero = nDigitsRead;
          }
          foundNonZero = true;
          digits[digitsInsert++] = parseInt(representation[index], 10);
          nDigitsStored = nDigitsStored + 1;
        }
      }
      if (foundNonZero)
        nDigits = nDigits + 1;
      if (sawRadix)
        radixPosition = radixPosition + 1;
      nDigitsRead = nDigitsRead + 1;
      index = index + 1;
    }
    if (sawRadix && !nDigitsRead)
      throw new BSONError("" + representation + " not a valid Decimal128 string");
    if (representation[index] === "e" || representation[index] === "E") {
      const match = representation.substr(++index).match(EXPONENT_REGEX);
      if (!match || !match[2])
        return new _Decimal128(NAN_BUFFER);
      exponent = parseInt(match[0], 10);
      index = index + match[0].length;
    }
    if (representation[index])
      return new _Decimal128(NAN_BUFFER);
    if (!nDigitsStored) {
      digits[0] = 0;
      nDigits = 1;
      nDigitsStored = 1;
      significantDigits = 0;
    } else {
      lastDigit = nDigitsStored - 1;
      significantDigits = nDigits;
      if (significantDigits !== 1) {
        while (representation[firstNonZero + significantDigits - 1 + Number(sawSign) + Number(sawRadix)] === "0") {
          significantDigits = significantDigits - 1;
        }
      }
    }
    if (exponent <= radixPosition && radixPosition > exponent + (1 << 14)) {
      exponent = EXPONENT_MIN;
    } else {
      exponent = exponent - radixPosition;
    }
    while (exponent > EXPONENT_MAX) {
      lastDigit = lastDigit + 1;
      if (lastDigit >= MAX_DIGITS) {
        if (significantDigits === 0) {
          exponent = EXPONENT_MAX;
          break;
        }
        invalidErr(representation, "overflow");
      }
      exponent = exponent - 1;
    }
    if (options.allowRounding) {
      while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
        if (lastDigit === 0 && significantDigits < nDigitsStored) {
          exponent = EXPONENT_MIN;
          significantDigits = 0;
          break;
        }
        if (nDigitsStored < nDigits) {
          nDigits = nDigits - 1;
        } else {
          lastDigit = lastDigit - 1;
        }
        if (exponent < EXPONENT_MAX) {
          exponent = exponent + 1;
        } else {
          const digitsString = digits.join("");
          if (digitsString.match(/^0+$/)) {
            exponent = EXPONENT_MAX;
            break;
          }
          invalidErr(representation, "overflow");
        }
      }
      if (lastDigit + 1 < significantDigits) {
        let endOfString = nDigitsRead;
        if (sawRadix) {
          firstNonZero = firstNonZero + 1;
          endOfString = endOfString + 1;
        }
        if (sawSign) {
          firstNonZero = firstNonZero + 1;
          endOfString = endOfString + 1;
        }
        const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);
        let roundBit = 0;
        if (roundDigit >= 5) {
          roundBit = 1;
          if (roundDigit === 5) {
            roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;
            for (let i3 = firstNonZero + lastDigit + 2; i3 < endOfString; i3++) {
              if (parseInt(representation[i3], 10)) {
                roundBit = 1;
                break;
              }
            }
          }
        }
        if (roundBit) {
          let dIdx = lastDigit;
          for (; dIdx >= 0; dIdx--) {
            if (++digits[dIdx] > 9) {
              digits[dIdx] = 0;
              if (dIdx === 0) {
                if (exponent < EXPONENT_MAX) {
                  exponent = exponent + 1;
                  digits[dIdx] = 1;
                } else {
                  return new _Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);
                }
              }
            } else {
              break;
            }
          }
        }
      }
    } else {
      while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
        if (lastDigit === 0) {
          if (significantDigits === 0) {
            exponent = EXPONENT_MIN;
            break;
          }
          invalidErr(representation, "exponent underflow");
        }
        if (nDigitsStored < nDigits) {
          if (representation[nDigits - 1 + Number(sawSign) + Number(sawRadix)] !== "0" && significantDigits !== 0) {
            invalidErr(representation, "inexact rounding");
          }
          nDigits = nDigits - 1;
        } else {
          if (digits[lastDigit] !== 0) {
            invalidErr(representation, "inexact rounding");
          }
          lastDigit = lastDigit - 1;
        }
        if (exponent < EXPONENT_MAX) {
          exponent = exponent + 1;
        } else {
          invalidErr(representation, "overflow");
        }
      }
      if (lastDigit + 1 < significantDigits) {
        if (sawRadix) {
          firstNonZero = firstNonZero + 1;
        }
        if (sawSign) {
          firstNonZero = firstNonZero + 1;
        }
        const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);
        if (roundDigit !== 0) {
          invalidErr(representation, "inexact rounding");
        }
      }
    }
    significandHigh = Long.fromNumber(0);
    significandLow = Long.fromNumber(0);
    if (significantDigits === 0) {
      significandHigh = Long.fromNumber(0);
      significandLow = Long.fromNumber(0);
    } else if (lastDigit < 17) {
      let dIdx = 0;
      significandLow = Long.fromNumber(digits[dIdx++]);
      significandHigh = new Long(0, 0);
      for (; dIdx <= lastDigit; dIdx++) {
        significandLow = significandLow.multiply(Long.fromNumber(10));
        significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
      }
    } else {
      let dIdx = 0;
      significandHigh = Long.fromNumber(digits[dIdx++]);
      for (; dIdx <= lastDigit - 17; dIdx++) {
        significandHigh = significandHigh.multiply(Long.fromNumber(10));
        significandHigh = significandHigh.add(Long.fromNumber(digits[dIdx]));
      }
      significandLow = Long.fromNumber(digits[dIdx++]);
      for (; dIdx <= lastDigit; dIdx++) {
        significandLow = significandLow.multiply(Long.fromNumber(10));
        significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
      }
    }
    const significand = multiply64x2(significandHigh, Long.fromString("100000000000000000"));
    significand.low = significand.low.add(significandLow);
    if (lessThan(significand.low, significandLow)) {
      significand.high = significand.high.add(Long.fromNumber(1));
    }
    biasedExponent = exponent + EXPONENT_BIAS;
    const dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) };
    if (significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber(1))) {
      dec.high = dec.high.or(Long.fromNumber(3).shiftLeft(61));
      dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(16383).shiftLeft(47)));
      dec.high = dec.high.or(significand.high.and(Long.fromNumber(140737488355327)));
    } else {
      dec.high = dec.high.or(Long.fromNumber(biasedExponent & 16383).shiftLeft(49));
      dec.high = dec.high.or(significand.high.and(Long.fromNumber(562949953421311)));
    }
    dec.low = significand.low;
    if (isNegative) {
      dec.high = dec.high.or(Long.fromString("9223372036854775808"));
    }
    const buffer2 = ByteUtils.allocateUnsafe(16);
    index = 0;
    buffer2[index++] = dec.low.low & 255;
    buffer2[index++] = dec.low.low >> 8 & 255;
    buffer2[index++] = dec.low.low >> 16 & 255;
    buffer2[index++] = dec.low.low >> 24 & 255;
    buffer2[index++] = dec.low.high & 255;
    buffer2[index++] = dec.low.high >> 8 & 255;
    buffer2[index++] = dec.low.high >> 16 & 255;
    buffer2[index++] = dec.low.high >> 24 & 255;
    buffer2[index++] = dec.high.low & 255;
    buffer2[index++] = dec.high.low >> 8 & 255;
    buffer2[index++] = dec.high.low >> 16 & 255;
    buffer2[index++] = dec.high.low >> 24 & 255;
    buffer2[index++] = dec.high.high & 255;
    buffer2[index++] = dec.high.high >> 8 & 255;
    buffer2[index++] = dec.high.high >> 16 & 255;
    buffer2[index++] = dec.high.high >> 24 & 255;
    return new _Decimal128(buffer2);
  }
  toString() {
    let biased_exponent;
    let significand_digits = 0;
    const significand = new Array(36);
    for (let i3 = 0; i3 < significand.length; i3++)
      significand[i3] = 0;
    let index = 0;
    let is_zero = false;
    let significand_msb;
    let significand128 = { parts: [0, 0, 0, 0] };
    let j2, k4;
    const string = [];
    index = 0;
    const buffer2 = this.bytes;
    const low = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
    const midl = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
    const midh = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
    const high = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
    index = 0;
    const dec = {
      low: new Long(low, midl),
      high: new Long(midh, high)
    };
    if (dec.high.lessThan(Long.ZERO)) {
      string.push("-");
    }
    const combination = high >> 26 & COMBINATION_MASK;
    if (combination >> 3 === 3) {
      if (combination === COMBINATION_INFINITY) {
        return string.join("") + "Infinity";
      } else if (combination === COMBINATION_NAN) {
        return "NaN";
      } else {
        biased_exponent = high >> 15 & EXPONENT_MASK;
        significand_msb = 8 + (high >> 14 & 1);
      }
    } else {
      significand_msb = high >> 14 & 7;
      biased_exponent = high >> 17 & EXPONENT_MASK;
    }
    const exponent = biased_exponent - EXPONENT_BIAS;
    significand128.parts[0] = (high & 16383) + ((significand_msb & 15) << 14);
    significand128.parts[1] = midh;
    significand128.parts[2] = midl;
    significand128.parts[3] = low;
    if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {
      is_zero = true;
    } else {
      for (k4 = 3; k4 >= 0; k4--) {
        let least_digits = 0;
        const result = divideu128(significand128);
        significand128 = result.quotient;
        least_digits = result.rem.low;
        if (!least_digits)
          continue;
        for (j2 = 8; j2 >= 0; j2--) {
          significand[k4 * 9 + j2] = least_digits % 10;
          least_digits = Math.floor(least_digits / 10);
        }
      }
    }
    if (is_zero) {
      significand_digits = 1;
      significand[index] = 0;
    } else {
      significand_digits = 36;
      while (!significand[index]) {
        significand_digits = significand_digits - 1;
        index = index + 1;
      }
    }
    const scientific_exponent = significand_digits - 1 + exponent;
    if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {
      if (significand_digits > 34) {
        string.push(`${0}`);
        if (exponent > 0)
          string.push(`E+${exponent}`);
        else if (exponent < 0)
          string.push(`E${exponent}`);
        return string.join("");
      }
      string.push(`${significand[index++]}`);
      significand_digits = significand_digits - 1;
      if (significand_digits) {
        string.push(".");
      }
      for (let i3 = 0; i3 < significand_digits; i3++) {
        string.push(`${significand[index++]}`);
      }
      string.push("E");
      if (scientific_exponent > 0) {
        string.push(`+${scientific_exponent}`);
      } else {
        string.push(`${scientific_exponent}`);
      }
    } else {
      if (exponent >= 0) {
        for (let i3 = 0; i3 < significand_digits; i3++) {
          string.push(`${significand[index++]}`);
        }
      } else {
        let radix_position = significand_digits + exponent;
        if (radix_position > 0) {
          for (let i3 = 0; i3 < radix_position; i3++) {
            string.push(`${significand[index++]}`);
          }
        } else {
          string.push("0");
        }
        string.push(".");
        while (radix_position++ < 0) {
          string.push("0");
        }
        for (let i3 = 0; i3 < significand_digits - Math.max(radix_position - 1, 0); i3++) {
          string.push(`${significand[index++]}`);
        }
      }
    }
    return string.join("");
  }
  toJSON() {
    return { $numberDecimal: this.toString() };
  }
  toExtendedJSON() {
    return { $numberDecimal: this.toString() };
  }
  static fromExtendedJSON(doc) {
    return _Decimal128.fromString(doc.$numberDecimal);
  }
  inspect(depth, options, inspect) {
    inspect ?? (inspect = defaultInspect);
    const d128string = inspect(this.toString(), options);
    return `new Decimal128(${d128string})`;
  }
};
var Double = class _Double extends BSONValue {
  constructor(value) {
    super();
    __publicField(this, "value");
    if (value instanceof Number) {
      value = value.valueOf();
    }
    this.value = +value;
  }
  get _bsontype() {
    return "Double";
  }
  static fromString(value) {
    const coercedValue = Number(value);
    if (value === "NaN")
      return new _Double(NaN);
    if (value === "Infinity")
      return new _Double(Infinity);
    if (value === "-Infinity")
      return new _Double(-Infinity);
    if (!Number.isFinite(coercedValue)) {
      throw new BSONError(`Input: ${value} is not representable as a Double`);
    }
    if (value.trim() !== value) {
      throw new BSONError(`Input: '${value}' contains whitespace`);
    }
    if (value === "") {
      throw new BSONError(`Input is an empty string`);
    }
    if (/[^-0-9.+eE]/.test(value)) {
      throw new BSONError(`Input: '${value}' is not in decimal or exponential notation`);
    }
    return new _Double(coercedValue);
  }
  valueOf() {
    return this.value;
  }
  toJSON() {
    return this.value;
  }
  toString(radix) {
    return this.value.toString(radix);
  }
  toExtendedJSON(options) {
    if (options && (options.legacy || options.relaxed && isFinite(this.value))) {
      return this.value;
    }
    if (Object.is(Math.sign(this.value), -0)) {
      return { $numberDouble: "-0.0" };
    }
    return {
      $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()
    };
  }
  static fromExtendedJSON(doc, options) {
    const doubleValue = parseFloat(doc.$numberDouble);
    return options && options.relaxed ? doubleValue : new _Double(doubleValue);
  }
  inspect(depth, options, inspect) {
    inspect ?? (inspect = defaultInspect);
    return `new Double(${inspect(this.value, options)})`;
  }
};
var Int32 = class _Int32 extends BSONValue {
  constructor(value) {
    super();
    __publicField(this, "value");
    if (value instanceof Number) {
      value = value.valueOf();
    }
    this.value = +value | 0;
  }
  get _bsontype() {
    return "Int32";
  }
  static fromString(value) {
    const cleanedValue = removeLeadingZerosAndExplicitPlus(value);
    const coercedValue = Number(value);
    if (BSON_INT32_MAX < coercedValue) {
      throw new BSONError(`Input: '${value}' is larger than the maximum value for Int32`);
    } else if (BSON_INT32_MIN > coercedValue) {
      throw new BSONError(`Input: '${value}' is smaller than the minimum value for Int32`);
    } else if (!Number.isSafeInteger(coercedValue)) {
      throw new BSONError(`Input: '${value}' is not a safe integer`);
    } else if (coercedValue.toString() !== cleanedValue) {
      throw new BSONError(`Input: '${value}' is not a valid Int32 string`);
    }
    return new _Int32(coercedValue);
  }
  valueOf() {
    return this.value;
  }
  toString(radix) {
    return this.value.toString(radix);
  }
  toJSON() {
    return this.value;
  }
  toExtendedJSON(options) {
    if (options && (options.relaxed || options.legacy))
      return this.value;
    return { $numberInt: this.value.toString() };
  }
  static fromExtendedJSON(doc, options) {
    return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new _Int32(doc.$numberInt);
  }
  inspect(depth, options, inspect) {
    inspect ?? (inspect = defaultInspect);
    return `new Int32(${inspect(this.value, options)})`;
  }
};
var MaxKey = class _MaxKey extends BSONValue {
  get _bsontype() {
    return "MaxKey";
  }
  toExtendedJSON() {
    return { $maxKey: 1 };
  }
  static fromExtendedJSON() {
    return new _MaxKey();
  }
  inspect() {
    return "new MaxKey()";
  }
};
var MinKey = class _MinKey extends BSONValue {
  get _bsontype() {
    return "MinKey";
  }
  toExtendedJSON() {
    return { $minKey: 1 };
  }
  static fromExtendedJSON() {
    return new _MinKey();
  }
  inspect() {
    return "new MinKey()";
  }
};
var PROCESS_UNIQUE = null;
var __idCache = /* @__PURE__ */ new WeakMap();
var _ObjectId = class _ObjectId extends BSONValue {
  constructor(inputId) {
    super();
    __publicField(this, "buffer");
    let workingId;
    if (typeof inputId === "object" && inputId && "id" in inputId) {
      if (typeof inputId.id !== "string" && !ArrayBuffer.isView(inputId.id)) {
        throw new BSONError("Argument passed in must have an id that is of type string or Buffer");
      }
      if ("toHexString" in inputId && typeof inputId.toHexString === "function") {
        workingId = ByteUtils.fromHex(inputId.toHexString());
      } else {
        workingId = inputId.id;
      }
    } else {
      workingId = inputId;
    }
    if (workingId == null) {
      this.buffer = _ObjectId.generate();
    } else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {
      this.buffer = ByteUtils.toLocalBufferType(workingId);
    } else if (typeof workingId === "string") {
      if (_ObjectId.validateHexString(workingId)) {
        this.buffer = ByteUtils.fromHex(workingId);
        if (_ObjectId.cacheHexString) {
          __idCache.set(this, workingId);
        }
      } else {
        throw new BSONError("input must be a 24 character hex string, 12 byte Uint8Array, or an integer");
      }
    } else {
      throw new BSONError("Argument passed in does not match the accepted types");
    }
  }
  get _bsontype() {
    return "ObjectId";
  }
  get id() {
    return this.buffer;
  }
  set id(value) {
    this.buffer = value;
    if (_ObjectId.cacheHexString) {
      __idCache.set(this, ByteUtils.toHex(value));
    }
  }
  static validateHexString(string) {
    if ((string == null ? void 0 : string.length) !== 24)
      return false;
    for (let i3 = 0; i3 < 24; i3++) {
      const char = string.charCodeAt(i3);
      if (char >= 48 && char <= 57 || char >= 97 && char <= 102 || char >= 65 && char <= 70) {
        continue;
      }
      return false;
    }
    return true;
  }
  toHexString() {
    if (_ObjectId.cacheHexString) {
      const __id = __idCache.get(this);
      if (__id)
        return __id;
    }
    const hexString = ByteUtils.toHex(this.id);
    if (_ObjectId.cacheHexString) {
      __idCache.set(this, hexString);
    }
    return hexString;
  }
  static getInc() {
    return _ObjectId.index = (_ObjectId.index + 1) % 16777215;
  }
  static generate(time) {
    if ("number" !== typeof time) {
      time = Math.floor(Date.now() / 1e3);
    }
    const inc = _ObjectId.getInc();
    const buffer2 = ByteUtils.allocateUnsafe(12);
    NumberUtils.setInt32BE(buffer2, 0, time);
    if (PROCESS_UNIQUE === null) {
      PROCESS_UNIQUE = ByteUtils.randomBytes(5);
    }
    buffer2[4] = PROCESS_UNIQUE[0];
    buffer2[5] = PROCESS_UNIQUE[1];
    buffer2[6] = PROCESS_UNIQUE[2];
    buffer2[7] = PROCESS_UNIQUE[3];
    buffer2[8] = PROCESS_UNIQUE[4];
    buffer2[11] = inc & 255;
    buffer2[10] = inc >> 8 & 255;
    buffer2[9] = inc >> 16 & 255;
    return buffer2;
  }
  toString(encoding) {
    if (encoding === "base64")
      return ByteUtils.toBase64(this.id);
    if (encoding === "hex")
      return this.toHexString();
    return this.toHexString();
  }
  toJSON() {
    return this.toHexString();
  }
  static is(variable) {
    return variable != null && typeof variable === "object" && "_bsontype" in variable && variable._bsontype === "ObjectId";
  }
  equals(otherId) {
    if (otherId === void 0 || otherId === null) {
      return false;
    }
    if (_ObjectId.is(otherId)) {
      return this.buffer[11] === otherId.buffer[11] && ByteUtils.equals(this.buffer, otherId.buffer);
    }
    if (typeof otherId === "string") {
      return otherId.toLowerCase() === this.toHexString();
    }
    if (typeof otherId === "object" && typeof otherId.toHexString === "function") {
      const otherIdString = otherId.toHexString();
      const thisIdString = this.toHexString();
      return typeof otherIdString === "string" && otherIdString.toLowerCase() === thisIdString;
    }
    return false;
  }
  getTimestamp() {
    const timestamp = /* @__PURE__ */ new Date();
    const time = NumberUtils.getUint32BE(this.buffer, 0);
    timestamp.setTime(Math.floor(time) * 1e3);
    return timestamp;
  }
  static createPk() {
    return new _ObjectId();
  }
  serializeInto(uint8array, index) {
    uint8array[index] = this.buffer[0];
    uint8array[index + 1] = this.buffer[1];
    uint8array[index + 2] = this.buffer[2];
    uint8array[index + 3] = this.buffer[3];
    uint8array[index + 4] = this.buffer[4];
    uint8array[index + 5] = this.buffer[5];
    uint8array[index + 6] = this.buffer[6];
    uint8array[index + 7] = this.buffer[7];
    uint8array[index + 8] = this.buffer[8];
    uint8array[index + 9] = this.buffer[9];
    uint8array[index + 10] = this.buffer[10];
    uint8array[index + 11] = this.buffer[11];
    return 12;
  }
  static createFromTime(time) {
    const buffer2 = ByteUtils.allocate(12);
    for (let i3 = 11; i3 >= 4; i3--)
      buffer2[i3] = 0;
    NumberUtils.setInt32BE(buffer2, 0, time);
    return new _ObjectId(buffer2);
  }
  static createFromHexString(hexString) {
    if ((hexString == null ? void 0 : hexString.length) !== 24) {
      throw new BSONError("hex string must be 24 characters");
    }
    return new _ObjectId(ByteUtils.fromHex(hexString));
  }
  static createFromBase64(base64) {
    if ((base64 == null ? void 0 : base64.length) !== 16) {
      throw new BSONError("base64 string must be 16 characters");
    }
    return new _ObjectId(ByteUtils.fromBase64(base64));
  }
  static isValid(id) {
    if (id == null)
      return false;
    if (typeof id === "string")
      return _ObjectId.validateHexString(id);
    try {
      new _ObjectId(id);
      return true;
    } catch {
      return false;
    }
  }
  toExtendedJSON() {
    if (this.toHexString)
      return { $oid: this.toHexString() };
    return { $oid: this.toString("hex") };
  }
  static fromExtendedJSON(doc) {
    return new _ObjectId(doc.$oid);
  }
  isCached() {
    return _ObjectId.cacheHexString && __idCache.has(this);
  }
  inspect(depth, options, inspect) {
    inspect ?? (inspect = defaultInspect);
    return `new ObjectId(${inspect(this.toHexString(), options)})`;
  }
};
__publicField(_ObjectId, "index", Math.floor(Math.random() * 16777215));
__publicField(_ObjectId, "cacheHexString");
var ObjectId = _ObjectId;
function internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined) {
  let totalLength = 4 + 1;
  if (Array.isArray(object)) {
    for (let i3 = 0; i3 < object.length; i3++) {
      totalLength += calculateElement(i3.toString(), object[i3], serializeFunctions, true, ignoreUndefined);
    }
  } else {
    if (typeof (object == null ? void 0 : object.toBSON) === "function") {
      object = object.toBSON();
    }
    for (const key of Object.keys(object)) {
      totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);
    }
  }
  return totalLength;
}
function calculateElement(name, value, serializeFunctions = false, isArray = false, ignoreUndefined = false) {
  if (typeof (value == null ? void 0 : value.toBSON) === "function") {
    value = value.toBSON();
  }
  switch (typeof value) {
    case "string":
      return 1 + ByteUtils.utf8ByteLength(name) + 1 + 4 + ByteUtils.utf8ByteLength(value) + 1;
    case "number":
      if (Math.floor(value) === value && value >= JS_INT_MIN && value <= JS_INT_MAX) {
        if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (4 + 1);
        } else {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
        }
      } else {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
      }
    case "undefined":
      if (isArray || !ignoreUndefined)
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;
      return 0;
    case "boolean":
      return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 1);
    case "object":
      if (value != null && typeof value._bsontype === "string" && value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
        throw new BSONVersionError();
      } else if (value == null || value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;
      } else if (value._bsontype === "ObjectId") {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (12 + 1);
      } else if (value instanceof Date || isDate(value)) {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
      } else if (ArrayBuffer.isView(value) || value instanceof ArrayBuffer || isAnyArrayBuffer(value)) {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 4 + 1) + value.byteLength;
      } else if (value._bsontype === "Long" || value._bsontype === "Double" || value._bsontype === "Timestamp") {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
      } else if (value._bsontype === "Decimal128") {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (16 + 1);
      } else if (value._bsontype === "Code") {
        if (value.scope != null && Object.keys(value.scope).length > 0) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1 + internalCalculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
        } else {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1;
        }
      } else if (value._bsontype === "Binary") {
        const binary = value;
        if (binary.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1 + 4);
        } else {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1);
        }
      } else if (value._bsontype === "Symbol") {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + ByteUtils.utf8ByteLength(value.value) + 4 + 1 + 1;
      } else if (value._bsontype === "DBRef") {
        const ordered_values = Object.assign({
          $ref: value.collection,
          $id: value.oid
        }, value.fields);
        if (value.db != null) {
          ordered_values["$db"] = value.db;
        }
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + internalCalculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);
      } else if (value instanceof RegExp || isRegExp(value)) {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.source) + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
      } else if (value._bsontype === "BSONRegExp") {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.pattern) + 1 + ByteUtils.utf8ByteLength(value.options) + 1;
      } else {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + internalCalculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;
      }
    case "function":
      if (serializeFunctions) {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.toString()) + 1;
      }
      return 0;
    case "bigint":
      return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
    case "symbol":
      return 0;
    default:
      throw new BSONError(`Unrecognized JS type: ${typeof value}`);
  }
}
function alphabetize(str) {
  return str.split("").sort().join("");
}
var BSONRegExp = class _BSONRegExp extends BSONValue {
  constructor(pattern, options) {
    super();
    __publicField(this, "pattern");
    __publicField(this, "options");
    this.pattern = pattern;
    this.options = alphabetize(options ?? "");
    if (this.pattern.indexOf("\0") !== -1) {
      throw new BSONError(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);
    }
    if (this.options.indexOf("\0") !== -1) {
      throw new BSONError(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);
    }
    for (let i3 = 0; i3 < this.options.length; i3++) {
      if (!(this.options[i3] === "i" || this.options[i3] === "m" || this.options[i3] === "x" || this.options[i3] === "l" || this.options[i3] === "s" || this.options[i3] === "u")) {
        throw new BSONError(`The regular expression option [${this.options[i3]}] is not supported`);
      }
    }
  }
  get _bsontype() {
    return "BSONRegExp";
  }
  static parseOptions(options) {
    return options ? options.split("").sort().join("") : "";
  }
  toExtendedJSON(options) {
    options = options || {};
    if (options.legacy) {
      return { $regex: this.pattern, $options: this.options };
    }
    return { $regularExpression: { pattern: this.pattern, options: this.options } };
  }
  static fromExtendedJSON(doc) {
    if ("$regex" in doc) {
      if (typeof doc.$regex !== "string") {
        if (doc.$regex._bsontype === "BSONRegExp") {
          return doc;
        }
      } else {
        return new _BSONRegExp(doc.$regex, _BSONRegExp.parseOptions(doc.$options));
      }
    }
    if ("$regularExpression" in doc) {
      return new _BSONRegExp(doc.$regularExpression.pattern, _BSONRegExp.parseOptions(doc.$regularExpression.options));
    }
    throw new BSONError(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(doc)}`);
  }
  inspect(depth, options, inspect) {
    const stylize = getStylizeFunction(options) ?? ((v2) => v2);
    inspect ?? (inspect = defaultInspect);
    const pattern = stylize(inspect(this.pattern), "regexp");
    const flags = stylize(inspect(this.options), "regexp");
    return `new BSONRegExp(${pattern}, ${flags})`;
  }
};
var BSONSymbol = class _BSONSymbol extends BSONValue {
  constructor(value) {
    super();
    __publicField(this, "value");
    this.value = value;
  }
  get _bsontype() {
    return "BSONSymbol";
  }
  valueOf() {
    return this.value;
  }
  toString() {
    return this.value;
  }
  toJSON() {
    return this.value;
  }
  toExtendedJSON() {
    return { $symbol: this.value };
  }
  static fromExtendedJSON(doc) {
    return new _BSONSymbol(doc.$symbol);
  }
  inspect(depth, options, inspect) {
    inspect ?? (inspect = defaultInspect);
    return `new BSONSymbol(${inspect(this.value, options)})`;
  }
};
var LongWithoutOverridesClass = Long;
var _Timestamp = class _Timestamp extends LongWithoutOverridesClass {
  get _bsontype() {
    return "Timestamp";
  }
  get [bsonType]() {
    return "Timestamp";
  }
  get i() {
    return this.low >>> 0;
  }
  get t() {
    return this.high >>> 0;
  }
  constructor(low) {
    if (low == null) {
      super(0, 0, true);
    } else if (typeof low === "bigint") {
      super(low, true);
    } else if (Long.isLong(low)) {
      super(low.low, low.high, true);
    } else if (typeof low === "object" && "t" in low && "i" in low) {
      if (typeof low.t !== "number" && (typeof low.t !== "object" || low.t._bsontype !== "Int32")) {
        throw new BSONError("Timestamp constructed from { t, i } must provide t as a number");
      }
      if (typeof low.i !== "number" && (typeof low.i !== "object" || low.i._bsontype !== "Int32")) {
        throw new BSONError("Timestamp constructed from { t, i } must provide i as a number");
      }
      const t3 = Number(low.t);
      const i3 = Number(low.i);
      if (t3 < 0 || Number.isNaN(t3)) {
        throw new BSONError("Timestamp constructed from { t, i } must provide a positive t");
      }
      if (i3 < 0 || Number.isNaN(i3)) {
        throw new BSONError("Timestamp constructed from { t, i } must provide a positive i");
      }
      if (t3 > 4294967295) {
        throw new BSONError("Timestamp constructed from { t, i } must provide t equal or less than uint32 max");
      }
      if (i3 > 4294967295) {
        throw new BSONError("Timestamp constructed from { t, i } must provide i equal or less than uint32 max");
      }
      super(i3, t3, true);
    } else {
      throw new BSONError("A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }");
    }
  }
  toJSON() {
    return {
      $timestamp: this.toString()
    };
  }
  static fromInt(value) {
    return new _Timestamp(Long.fromInt(value, true));
  }
  static fromNumber(value) {
    return new _Timestamp(Long.fromNumber(value, true));
  }
  static fromBits(lowBits, highBits) {
    return new _Timestamp({ i: lowBits, t: highBits });
  }
  static fromString(str, optRadix) {
    return new _Timestamp(Long.fromString(str, true, optRadix));
  }
  toExtendedJSON() {
    return { $timestamp: { t: this.t, i: this.i } };
  }
  static fromExtendedJSON(doc) {
    const i3 = Long.isLong(doc.$timestamp.i) ? doc.$timestamp.i.getLowBitsUnsigned() : doc.$timestamp.i;
    const t3 = Long.isLong(doc.$timestamp.t) ? doc.$timestamp.t.getLowBitsUnsigned() : doc.$timestamp.t;
    return new _Timestamp({ t: t3, i: i3 });
  }
  inspect(depth, options, inspect) {
    inspect ?? (inspect = defaultInspect);
    const t3 = inspect(this.t, options);
    const i3 = inspect(this.i, options);
    return `new Timestamp({ t: ${t3}, i: ${i3} })`;
  }
};
__publicField(_Timestamp, "MAX_VALUE", Long.MAX_UNSIGNED_VALUE);
var Timestamp = _Timestamp;
var JS_INT_MAX_LONG = Long.fromNumber(JS_INT_MAX);
var JS_INT_MIN_LONG = Long.fromNumber(JS_INT_MIN);
function internalDeserialize(buffer2, options, isArray) {
  options = options == null ? {} : options;
  const index = options && options.index ? options.index : 0;
  const size = NumberUtils.getInt32LE(buffer2, index);
  if (size < 5) {
    throw new BSONError(`bson size must be >= 5, is ${size}`);
  }
  if (options.allowObjectSmallerThanBufferSize && buffer2.length < size) {
    throw new BSONError(`buffer length ${buffer2.length} must be >= bson size ${size}`);
  }
  if (!options.allowObjectSmallerThanBufferSize && buffer2.length !== size) {
    throw new BSONError(`buffer length ${buffer2.length} must === bson size ${size}`);
  }
  if (size + index > buffer2.byteLength) {
    throw new BSONError(`(bson size ${size} + options.index ${index} must be <= buffer length ${buffer2.byteLength})`);
  }
  if (buffer2[index + size - 1] !== 0) {
    throw new BSONError("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
  }
  return deserializeObject(buffer2, index, options, isArray);
}
var allowedDBRefKeys = /^\$ref$|^\$id$|^\$db$/;
function deserializeObject(buffer2, index, options, isArray = false) {
  const fieldsAsRaw = options["fieldsAsRaw"] == null ? null : options["fieldsAsRaw"];
  const raw = options["raw"] == null ? false : options["raw"];
  const bsonRegExp = typeof options["bsonRegExp"] === "boolean" ? options["bsonRegExp"] : false;
  const promoteBuffers = options.promoteBuffers ?? false;
  const promoteLongs = options.promoteLongs ?? true;
  const promoteValues = options.promoteValues ?? true;
  const useBigInt64 = options.useBigInt64 ?? false;
  if (useBigInt64 && !promoteValues) {
    throw new BSONError("Must either request bigint or Long for int64 deserialization");
  }
  if (useBigInt64 && !promoteLongs) {
    throw new BSONError("Must either request bigint or Long for int64 deserialization");
  }
  const validation = options.validation == null ? { utf8: true } : options.validation;
  let globalUTFValidation = true;
  let validationSetting;
  let utf8KeysSet;
  const utf8ValidatedKeys = validation.utf8;
  if (typeof utf8ValidatedKeys === "boolean") {
    validationSetting = utf8ValidatedKeys;
  } else {
    globalUTFValidation = false;
    const utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function(key) {
      return utf8ValidatedKeys[key];
    });
    if (utf8ValidationValues.length === 0) {
      throw new BSONError("UTF-8 validation setting cannot be empty");
    }
    if (typeof utf8ValidationValues[0] !== "boolean") {
      throw new BSONError("Invalid UTF-8 validation option, must specify boolean values");
    }
    validationSetting = utf8ValidationValues[0];
    if (!utf8ValidationValues.every((item) => item === validationSetting)) {
      throw new BSONError("Invalid UTF-8 validation option - keys must be all true or all false");
    }
  }
  if (!globalUTFValidation) {
    utf8KeysSet = /* @__PURE__ */ new Set();
    for (const key of Object.keys(utf8ValidatedKeys)) {
      utf8KeysSet.add(key);
    }
  }
  const startIndex = index;
  if (buffer2.length < 5)
    throw new BSONError("corrupt bson message < 5 bytes long");
  const size = NumberUtils.getInt32LE(buffer2, index);
  index += 4;
  if (size < 5 || size > buffer2.length)
    throw new BSONError("corrupt bson message");
  const object = isArray ? [] : {};
  let arrayIndex = 0;
  let isPossibleDBRef = isArray ? false : null;
  while (true) {
    const elementType = buffer2[index++];
    if (elementType === 0)
      break;
    let i3 = index;
    while (buffer2[i3] !== 0 && i3 < buffer2.length) {
      i3++;
    }
    if (i3 >= buffer2.byteLength)
      throw new BSONError("Bad BSON Document: illegal CString");
    const name = isArray ? arrayIndex++ : ByteUtils.toUTF8(buffer2, index, i3, false);
    let shouldValidateKey = true;
    if (globalUTFValidation || (utf8KeysSet == null ? void 0 : utf8KeysSet.has(name))) {
      shouldValidateKey = validationSetting;
    } else {
      shouldValidateKey = !validationSetting;
    }
    if (isPossibleDBRef !== false && name[0] === "$") {
      isPossibleDBRef = allowedDBRefKeys.test(name);
    }
    let value;
    index = i3 + 1;
    if (elementType === BSON_DATA_STRING) {
      const stringSize = NumberUtils.getInt32LE(buffer2, index);
      index += 4;
      if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
        throw new BSONError("bad string length in bson");
      }
      value = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
      index = index + stringSize;
    } else if (elementType === BSON_DATA_OID) {
      const oid = ByteUtils.allocateUnsafe(12);
      for (let i4 = 0; i4 < 12; i4++)
        oid[i4] = buffer2[index + i4];
      value = new ObjectId(oid);
      index = index + 12;
    } else if (elementType === BSON_DATA_INT && promoteValues === false) {
      value = new Int32(NumberUtils.getInt32LE(buffer2, index));
      index += 4;
    } else if (elementType === BSON_DATA_INT) {
      value = NumberUtils.getInt32LE(buffer2, index);
      index += 4;
    } else if (elementType === BSON_DATA_NUMBER) {
      value = NumberUtils.getFloat64LE(buffer2, index);
      index += 8;
      if (promoteValues === false)
        value = new Double(value);
    } else if (elementType === BSON_DATA_DATE) {
      const lowBits = NumberUtils.getInt32LE(buffer2, index);
      const highBits = NumberUtils.getInt32LE(buffer2, index + 4);
      index += 8;
      value = new Date(new Long(lowBits, highBits).toNumber());
    } else if (elementType === BSON_DATA_BOOLEAN) {
      if (buffer2[index] !== 0 && buffer2[index] !== 1)
        throw new BSONError("illegal boolean type value");
      value = buffer2[index++] === 1;
    } else if (elementType === BSON_DATA_OBJECT) {
      const _index = index;
      const objectSize = NumberUtils.getInt32LE(buffer2, index);
      if (objectSize <= 0 || objectSize > buffer2.length - index)
        throw new BSONError("bad embedded document length in bson");
      if (raw) {
        value = buffer2.subarray(index, index + objectSize);
      } else {
        let objectOptions = options;
        if (!globalUTFValidation) {
          objectOptions = { ...options, validation: { utf8: shouldValidateKey } };
        }
        value = deserializeObject(buffer2, _index, objectOptions, false);
      }
      index = index + objectSize;
    } else if (elementType === BSON_DATA_ARRAY) {
      const _index = index;
      const objectSize = NumberUtils.getInt32LE(buffer2, index);
      let arrayOptions = options;
      const stopIndex = index + objectSize;
      if (fieldsAsRaw && fieldsAsRaw[name]) {
        arrayOptions = { ...options, raw: true };
      }
      if (!globalUTFValidation) {
        arrayOptions = { ...arrayOptions, validation: { utf8: shouldValidateKey } };
      }
      value = deserializeObject(buffer2, _index, arrayOptions, true);
      index = index + objectSize;
      if (buffer2[index - 1] !== 0)
        throw new BSONError("invalid array terminator byte");
      if (index !== stopIndex)
        throw new BSONError("corrupted array bson");
    } else if (elementType === BSON_DATA_UNDEFINED) {
      value = void 0;
    } else if (elementType === BSON_DATA_NULL) {
      value = null;
    } else if (elementType === BSON_DATA_LONG) {
      if (useBigInt64) {
        value = NumberUtils.getBigInt64LE(buffer2, index);
        index += 8;
      } else {
        const lowBits = NumberUtils.getInt32LE(buffer2, index);
        const highBits = NumberUtils.getInt32LE(buffer2, index + 4);
        index += 8;
        const long = new Long(lowBits, highBits);
        if (promoteLongs && promoteValues === true) {
          value = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;
        } else {
          value = long;
        }
      }
    } else if (elementType === BSON_DATA_DECIMAL128) {
      const bytes = ByteUtils.allocateUnsafe(16);
      for (let i4 = 0; i4 < 16; i4++)
        bytes[i4] = buffer2[index + i4];
      index = index + 16;
      value = new Decimal128(bytes);
    } else if (elementType === BSON_DATA_BINARY) {
      let binarySize = NumberUtils.getInt32LE(buffer2, index);
      index += 4;
      const totalBinarySize = binarySize;
      const subType = buffer2[index++];
      if (binarySize < 0)
        throw new BSONError("Negative binary type element size found");
      if (binarySize > buffer2.byteLength)
        throw new BSONError("Binary type size larger than document size");
      if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
        binarySize = NumberUtils.getInt32LE(buffer2, index);
        index += 4;
        if (binarySize < 0)
          throw new BSONError("Negative binary type element size found for subtype 0x02");
        if (binarySize > totalBinarySize - 4)
          throw new BSONError("Binary type with subtype 0x02 contains too long binary size");
        if (binarySize < totalBinarySize - 4)
          throw new BSONError("Binary type with subtype 0x02 contains too short binary size");
      }
      if (promoteBuffers && promoteValues) {
        value = ByteUtils.toLocalBufferType(buffer2.subarray(index, index + binarySize));
      } else {
        value = new Binary(buffer2.subarray(index, index + binarySize), subType);
        if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {
          value = value.toUUID();
        }
      }
      index = index + binarySize;
    } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === false) {
      i3 = index;
      while (buffer2[i3] !== 0 && i3 < buffer2.length) {
        i3++;
      }
      if (i3 >= buffer2.length)
        throw new BSONError("Bad BSON Document: illegal CString");
      const source = ByteUtils.toUTF8(buffer2, index, i3, false);
      index = i3 + 1;
      i3 = index;
      while (buffer2[i3] !== 0 && i3 < buffer2.length) {
        i3++;
      }
      if (i3 >= buffer2.length)
        throw new BSONError("Bad BSON Document: illegal CString");
      const regExpOptions = ByteUtils.toUTF8(buffer2, index, i3, false);
      index = i3 + 1;
      const optionsArray = new Array(regExpOptions.length);
      for (i3 = 0; i3 < regExpOptions.length; i3++) {
        switch (regExpOptions[i3]) {
          case "m":
            optionsArray[i3] = "m";
            break;
          case "s":
            optionsArray[i3] = "g";
            break;
          case "i":
            optionsArray[i3] = "i";
            break;
        }
      }
      value = new RegExp(source, optionsArray.join(""));
    } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === true) {
      i3 = index;
      while (buffer2[i3] !== 0 && i3 < buffer2.length) {
        i3++;
      }
      if (i3 >= buffer2.length)
        throw new BSONError("Bad BSON Document: illegal CString");
      const source = ByteUtils.toUTF8(buffer2, index, i3, false);
      index = i3 + 1;
      i3 = index;
      while (buffer2[i3] !== 0 && i3 < buffer2.length) {
        i3++;
      }
      if (i3 >= buffer2.length)
        throw new BSONError("Bad BSON Document: illegal CString");
      const regExpOptions = ByteUtils.toUTF8(buffer2, index, i3, false);
      index = i3 + 1;
      value = new BSONRegExp(source, regExpOptions);
    } else if (elementType === BSON_DATA_SYMBOL) {
      const stringSize = NumberUtils.getInt32LE(buffer2, index);
      index += 4;
      if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
        throw new BSONError("bad string length in bson");
      }
      const symbol = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
      value = promoteValues ? symbol : new BSONSymbol(symbol);
      index = index + stringSize;
    } else if (elementType === BSON_DATA_TIMESTAMP) {
      value = new Timestamp({
        i: NumberUtils.getUint32LE(buffer2, index),
        t: NumberUtils.getUint32LE(buffer2, index + 4)
      });
      index += 8;
    } else if (elementType === BSON_DATA_MIN_KEY) {
      value = new MinKey();
    } else if (elementType === BSON_DATA_MAX_KEY) {
      value = new MaxKey();
    } else if (elementType === BSON_DATA_CODE) {
      const stringSize = NumberUtils.getInt32LE(buffer2, index);
      index += 4;
      if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
        throw new BSONError("bad string length in bson");
      }
      const functionString = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
      value = new Code(functionString);
      index = index + stringSize;
    } else if (elementType === BSON_DATA_CODE_W_SCOPE) {
      const totalSize = NumberUtils.getInt32LE(buffer2, index);
      index += 4;
      if (totalSize < 4 + 4 + 4 + 1) {
        throw new BSONError("code_w_scope total size shorter minimum expected length");
      }
      const stringSize = NumberUtils.getInt32LE(buffer2, index);
      index += 4;
      if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
        throw new BSONError("bad string length in bson");
      }
      const functionString = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
      index = index + stringSize;
      const _index = index;
      const objectSize = NumberUtils.getInt32LE(buffer2, index);
      const scopeObject = deserializeObject(buffer2, _index, options, false);
      index = index + objectSize;
      if (totalSize < 4 + 4 + objectSize + stringSize) {
        throw new BSONError("code_w_scope total size is too short, truncating scope");
      }
      if (totalSize > 4 + 4 + objectSize + stringSize) {
        throw new BSONError("code_w_scope total size is too long, clips outer document");
      }
      value = new Code(functionString, scopeObject);
    } else if (elementType === BSON_DATA_DBPOINTER) {
      const stringSize = NumberUtils.getInt32LE(buffer2, index);
      index += 4;
      if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0)
        throw new BSONError("bad string length in bson");
      const namespace = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
      index = index + stringSize;
      const oidBuffer = ByteUtils.allocateUnsafe(12);
      for (let i4 = 0; i4 < 12; i4++)
        oidBuffer[i4] = buffer2[index + i4];
      const oid = new ObjectId(oidBuffer);
      index = index + 12;
      value = new DBRef(namespace, oid);
    } else {
      throw new BSONError(`Detected unknown BSON type ${elementType.toString(16)} for fieldname "${name}"`);
    }
    if (name === "__proto__") {
      Object.defineProperty(object, name, {
        value,
        writable: true,
        enumerable: true,
        configurable: true
      });
    } else {
      object[name] = value;
    }
  }
  if (size !== index - startIndex) {
    if (isArray)
      throw new BSONError("corrupt array bson");
    throw new BSONError("corrupt object bson");
  }
  if (!isPossibleDBRef)
    return object;
  if (isDBRefLike(object)) {
    const copy = Object.assign({}, object);
    delete copy.$ref;
    delete copy.$id;
    delete copy.$db;
    return new DBRef(object.$ref, object.$id, object.$db, copy);
  }
  return object;
}
var regexp = /\x00/;
var ignoreKeys = /* @__PURE__ */ new Set(["$db", "$ref", "$id", "$clusterTime"]);
function serializeString(buffer2, key, value, index) {
  buffer2[index++] = BSON_DATA_STRING;
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
  index = index + numberOfWrittenBytes + 1;
  buffer2[index - 1] = 0;
  const size = ByteUtils.encodeUTF8Into(buffer2, value, index + 4);
  NumberUtils.setInt32LE(buffer2, index, size + 1);
  index = index + 4 + size;
  buffer2[index++] = 0;
  return index;
}
function serializeNumber(buffer2, key, value, index) {
  const isNegativeZero = Object.is(value, -0);
  const type = !isNegativeZero && Number.isSafeInteger(value) && value <= BSON_INT32_MAX && value >= BSON_INT32_MIN ? BSON_DATA_INT : BSON_DATA_NUMBER;
  buffer2[index++] = type;
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  if (type === BSON_DATA_INT) {
    index += NumberUtils.setInt32LE(buffer2, index, value);
  } else {
    index += NumberUtils.setFloat64LE(buffer2, index, value);
  }
  return index;
}
function serializeBigInt(buffer2, key, value, index) {
  buffer2[index++] = BSON_DATA_LONG;
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
  index += numberOfWrittenBytes;
  buffer2[index++] = 0;
  index += NumberUtils.setBigInt64LE(buffer2, index, value);
  return index;
}
function serializeNull(buffer2, key, _2, index) {
  buffer2[index++] = BSON_DATA_NULL;
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  return index;
}
function serializeBoolean(buffer2, key, value, index) {
  buffer2[index++] = BSON_DATA_BOOLEAN;
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  buffer2[index++] = value ? 1 : 0;
  return index;
}
function serializeDate(buffer2, key, value, index) {
  buffer2[index++] = BSON_DATA_DATE;
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  const dateInMilis = Long.fromNumber(value.getTime());
  const lowBits = dateInMilis.getLowBits();
  const highBits = dateInMilis.getHighBits();
  index += NumberUtils.setInt32LE(buffer2, index, lowBits);
  index += NumberUtils.setInt32LE(buffer2, index, highBits);
  return index;
}
function serializeRegExp(buffer2, key, value, index) {
  buffer2[index++] = BSON_DATA_REGEXP;
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  if (value.source && value.source.match(regexp) != null) {
    throw new BSONError("value " + value.source + " must not contain null bytes");
  }
  index = index + ByteUtils.encodeUTF8Into(buffer2, value.source, index);
  buffer2[index++] = 0;
  if (value.ignoreCase)
    buffer2[index++] = 105;
  if (value.global)
    buffer2[index++] = 115;
  if (value.multiline)
    buffer2[index++] = 109;
  buffer2[index++] = 0;
  return index;
}
function serializeBSONRegExp(buffer2, key, value, index) {
  buffer2[index++] = BSON_DATA_REGEXP;
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  if (value.pattern.match(regexp) != null) {
    throw new BSONError("pattern " + value.pattern + " must not contain null bytes");
  }
  index = index + ByteUtils.encodeUTF8Into(buffer2, value.pattern, index);
  buffer2[index++] = 0;
  const sortedOptions = value.options.split("").sort().join("");
  index = index + ByteUtils.encodeUTF8Into(buffer2, sortedOptions, index);
  buffer2[index++] = 0;
  return index;
}
function serializeMinMax(buffer2, key, value, index) {
  if (value === null) {
    buffer2[index++] = BSON_DATA_NULL;
  } else if (value._bsontype === "MinKey") {
    buffer2[index++] = BSON_DATA_MIN_KEY;
  } else {
    buffer2[index++] = BSON_DATA_MAX_KEY;
  }
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  return index;
}
function serializeObjectId(buffer2, key, value, index) {
  buffer2[index++] = BSON_DATA_OID;
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  index += value.serializeInto(buffer2, index);
  return index;
}
function serializeBuffer(buffer2, key, value, index) {
  buffer2[index++] = BSON_DATA_BINARY;
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  const size = value.length;
  index += NumberUtils.setInt32LE(buffer2, index, size);
  buffer2[index++] = BSON_BINARY_SUBTYPE_DEFAULT;
  if (size <= 16) {
    for (let i3 = 0; i3 < size; i3++)
      buffer2[index + i3] = value[i3];
  } else {
    buffer2.set(value, index);
  }
  index = index + size;
  return index;
}
function serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path) {
  if (path.has(value)) {
    throw new BSONError("Cannot convert circular structure to BSON");
  }
  path.add(value);
  buffer2[index++] = Array.isArray(value) ? BSON_DATA_ARRAY : BSON_DATA_OBJECT;
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  const endIndex = serializeInto(buffer2, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
  path.delete(value);
  return endIndex;
}
function serializeDecimal128(buffer2, key, value, index) {
  buffer2[index++] = BSON_DATA_DECIMAL128;
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  for (let i3 = 0; i3 < 16; i3++)
    buffer2[index + i3] = value.bytes[i3];
  return index + 16;
}
function serializeLong(buffer2, key, value, index) {
  buffer2[index++] = value._bsontype === "Long" ? BSON_DATA_LONG : BSON_DATA_TIMESTAMP;
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  const lowBits = value.getLowBits();
  const highBits = value.getHighBits();
  index += NumberUtils.setInt32LE(buffer2, index, lowBits);
  index += NumberUtils.setInt32LE(buffer2, index, highBits);
  return index;
}
function serializeInt32(buffer2, key, value, index) {
  value = value.valueOf();
  buffer2[index++] = BSON_DATA_INT;
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  index += NumberUtils.setInt32LE(buffer2, index, value);
  return index;
}
function serializeDouble(buffer2, key, value, index) {
  buffer2[index++] = BSON_DATA_NUMBER;
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  index += NumberUtils.setFloat64LE(buffer2, index, value.value);
  return index;
}
function serializeFunction(buffer2, key, value, index) {
  buffer2[index++] = BSON_DATA_CODE;
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  const functionString = value.toString();
  const size = ByteUtils.encodeUTF8Into(buffer2, functionString, index + 4) + 1;
  NumberUtils.setInt32LE(buffer2, index, size);
  index = index + 4 + size - 1;
  buffer2[index++] = 0;
  return index;
}
function serializeCode(buffer2, key, value, index, checkKeys = false, depth = 0, serializeFunctions = false, ignoreUndefined = true, path) {
  if (value.scope && typeof value.scope === "object") {
    buffer2[index++] = BSON_DATA_CODE_W_SCOPE;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    let startIndex = index;
    const functionString = value.code;
    index = index + 4;
    const codeSize = ByteUtils.encodeUTF8Into(buffer2, functionString, index + 4) + 1;
    NumberUtils.setInt32LE(buffer2, index, codeSize);
    buffer2[index + 4 + codeSize - 1] = 0;
    index = index + codeSize + 4;
    const endIndex = serializeInto(buffer2, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
    index = endIndex - 1;
    const totalSize = endIndex - startIndex;
    startIndex += NumberUtils.setInt32LE(buffer2, startIndex, totalSize);
    buffer2[index++] = 0;
  } else {
    buffer2[index++] = BSON_DATA_CODE;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const functionString = value.code.toString();
    const size = ByteUtils.encodeUTF8Into(buffer2, functionString, index + 4) + 1;
    NumberUtils.setInt32LE(buffer2, index, size);
    index = index + 4 + size - 1;
    buffer2[index++] = 0;
  }
  return index;
}
function serializeBinary(buffer2, key, value, index) {
  buffer2[index++] = BSON_DATA_BINARY;
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  const data = value.buffer;
  let size = value.position;
  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY)
    size = size + 4;
  index += NumberUtils.setInt32LE(buffer2, index, size);
  buffer2[index++] = value.sub_type;
  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {
    size = size - 4;
    index += NumberUtils.setInt32LE(buffer2, index, size);
  }
  if (value.sub_type === Binary.SUBTYPE_VECTOR) {
    validateBinaryVector(value);
  }
  if (size <= 16) {
    for (let i3 = 0; i3 < size; i3++)
      buffer2[index + i3] = data[i3];
  } else {
    buffer2.set(data, index);
  }
  index = index + value.position;
  return index;
}
function serializeSymbol(buffer2, key, value, index) {
  buffer2[index++] = BSON_DATA_SYMBOL;
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  const size = ByteUtils.encodeUTF8Into(buffer2, value.value, index + 4) + 1;
  NumberUtils.setInt32LE(buffer2, index, size);
  index = index + 4 + size - 1;
  buffer2[index++] = 0;
  return index;
}
function serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path) {
  buffer2[index++] = BSON_DATA_OBJECT;
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  let startIndex = index;
  let output = {
    $ref: value.collection || value.namespace,
    $id: value.oid
  };
  if (value.db != null) {
    output.$db = value.db;
  }
  output = Object.assign(output, value.fields);
  const endIndex = serializeInto(buffer2, output, false, index, depth + 1, serializeFunctions, true, path);
  const size = endIndex - startIndex;
  startIndex += NumberUtils.setInt32LE(buffer2, index, size);
  return endIndex;
}
function serializeInto(buffer2, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {
  if (path == null) {
    if (object == null) {
      buffer2[0] = 5;
      buffer2[1] = 0;
      buffer2[2] = 0;
      buffer2[3] = 0;
      buffer2[4] = 0;
      return 5;
    }
    if (Array.isArray(object)) {
      throw new BSONError("serialize does not support an array as the root input");
    }
    if (typeof object !== "object") {
      throw new BSONError("serialize does not support non-object as the root input");
    } else if ("_bsontype" in object && typeof object._bsontype === "string") {
      throw new BSONError(`BSON types cannot be serialized as a document`);
    } else if (isDate(object) || isRegExp(object) || isUint8Array(object) || isAnyArrayBuffer(object)) {
      throw new BSONError(`date, regexp, typedarray, and arraybuffer cannot be BSON documents`);
    }
    path = /* @__PURE__ */ new Set();
  }
  path.add(object);
  let index = startingIndex + 4;
  if (Array.isArray(object)) {
    for (let i3 = 0; i3 < object.length; i3++) {
      const key = `${i3}`;
      let value = object[i3];
      if (typeof (value == null ? void 0 : value.toBSON) === "function") {
        value = value.toBSON();
      }
      const type = typeof value;
      if (value === void 0) {
        index = serializeNull(buffer2, key, value, index);
      } else if (value === null) {
        index = serializeNull(buffer2, key, value, index);
      } else if (type === "string") {
        index = serializeString(buffer2, key, value, index);
      } else if (type === "number") {
        index = serializeNumber(buffer2, key, value, index);
      } else if (type === "bigint") {
        index = serializeBigInt(buffer2, key, value, index);
      } else if (type === "boolean") {
        index = serializeBoolean(buffer2, key, value, index);
      } else if (type === "object" && value._bsontype == null) {
        if (value instanceof Date || isDate(value)) {
          index = serializeDate(buffer2, key, value, index);
        } else if (value instanceof Uint8Array || isUint8Array(value)) {
          index = serializeBuffer(buffer2, key, value, index);
        } else if (value instanceof RegExp || isRegExp(value)) {
          index = serializeRegExp(buffer2, key, value, index);
        } else {
          index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
        }
      } else if (type === "object") {
        if (value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
          throw new BSONVersionError();
        } else if (value._bsontype === "ObjectId") {
          index = serializeObjectId(buffer2, key, value, index);
        } else if (value._bsontype === "Decimal128") {
          index = serializeDecimal128(buffer2, key, value, index);
        } else if (value._bsontype === "Long" || value._bsontype === "Timestamp") {
          index = serializeLong(buffer2, key, value, index);
        } else if (value._bsontype === "Double") {
          index = serializeDouble(buffer2, key, value, index);
        } else if (value._bsontype === "Code") {
          index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
        } else if (value._bsontype === "Binary") {
          index = serializeBinary(buffer2, key, value, index);
        } else if (value._bsontype === "BSONSymbol") {
          index = serializeSymbol(buffer2, key, value, index);
        } else if (value._bsontype === "DBRef") {
          index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path);
        } else if (value._bsontype === "BSONRegExp") {
          index = serializeBSONRegExp(buffer2, key, value, index);
        } else if (value._bsontype === "Int32") {
          index = serializeInt32(buffer2, key, value, index);
        } else if (value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
          index = serializeMinMax(buffer2, key, value, index);
        } else if (typeof value._bsontype !== "undefined") {
          throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
        }
      } else if (type === "function" && serializeFunctions) {
        index = serializeFunction(buffer2, key, value, index);
      }
    }
  } else if (object instanceof Map || isMap(object)) {
    const iterator = object.entries();
    let done = false;
    while (!done) {
      const entry = iterator.next();
      done = !!entry.done;
      if (done)
        continue;
      const key = entry.value ? entry.value[0] : void 0;
      let value = entry.value ? entry.value[1] : void 0;
      if (typeof (value == null ? void 0 : value.toBSON) === "function") {
        value = value.toBSON();
      }
      const type = typeof value;
      if (typeof key === "string" && !ignoreKeys.has(key)) {
        if (key.match(regexp) != null) {
          throw new BSONError("key " + key + " must not contain null bytes");
        }
        if (checkKeys) {
          if ("$" === key[0]) {
            throw new BSONError("key " + key + " must not start with '$'");
          } else if (key.includes(".")) {
            throw new BSONError("key " + key + " must not contain '.'");
          }
        }
      }
      if (value === void 0) {
        if (ignoreUndefined === false)
          index = serializeNull(buffer2, key, value, index);
      } else if (value === null) {
        index = serializeNull(buffer2, key, value, index);
      } else if (type === "string") {
        index = serializeString(buffer2, key, value, index);
      } else if (type === "number") {
        index = serializeNumber(buffer2, key, value, index);
      } else if (type === "bigint") {
        index = serializeBigInt(buffer2, key, value, index);
      } else if (type === "boolean") {
        index = serializeBoolean(buffer2, key, value, index);
      } else if (type === "object" && value._bsontype == null) {
        if (value instanceof Date || isDate(value)) {
          index = serializeDate(buffer2, key, value, index);
        } else if (value instanceof Uint8Array || isUint8Array(value)) {
          index = serializeBuffer(buffer2, key, value, index);
        } else if (value instanceof RegExp || isRegExp(value)) {
          index = serializeRegExp(buffer2, key, value, index);
        } else {
          index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
        }
      } else if (type === "object") {
        if (value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
          throw new BSONVersionError();
        } else if (value._bsontype === "ObjectId") {
          index = serializeObjectId(buffer2, key, value, index);
        } else if (value._bsontype === "Decimal128") {
          index = serializeDecimal128(buffer2, key, value, index);
        } else if (value._bsontype === "Long" || value._bsontype === "Timestamp") {
          index = serializeLong(buffer2, key, value, index);
        } else if (value._bsontype === "Double") {
          index = serializeDouble(buffer2, key, value, index);
        } else if (value._bsontype === "Code") {
          index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
        } else if (value._bsontype === "Binary") {
          index = serializeBinary(buffer2, key, value, index);
        } else if (value._bsontype === "BSONSymbol") {
          index = serializeSymbol(buffer2, key, value, index);
        } else if (value._bsontype === "DBRef") {
          index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path);
        } else if (value._bsontype === "BSONRegExp") {
          index = serializeBSONRegExp(buffer2, key, value, index);
        } else if (value._bsontype === "Int32") {
          index = serializeInt32(buffer2, key, value, index);
        } else if (value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
          index = serializeMinMax(buffer2, key, value, index);
        } else if (typeof value._bsontype !== "undefined") {
          throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
        }
      } else if (type === "function" && serializeFunctions) {
        index = serializeFunction(buffer2, key, value, index);
      }
    }
  } else {
    if (typeof (object == null ? void 0 : object.toBSON) === "function") {
      object = object.toBSON();
      if (object != null && typeof object !== "object") {
        throw new BSONError("toBSON function did not return an object");
      }
    }
    for (const key of Object.keys(object)) {
      let value = object[key];
      if (typeof (value == null ? void 0 : value.toBSON) === "function") {
        value = value.toBSON();
      }
      const type = typeof value;
      if (typeof key === "string" && !ignoreKeys.has(key)) {
        if (key.match(regexp) != null) {
          throw new BSONError("key " + key + " must not contain null bytes");
        }
        if (checkKeys) {
          if ("$" === key[0]) {
            throw new BSONError("key " + key + " must not start with '$'");
          } else if (key.includes(".")) {
            throw new BSONError("key " + key + " must not contain '.'");
          }
        }
      }
      if (value === void 0) {
        if (ignoreUndefined === false)
          index = serializeNull(buffer2, key, value, index);
      } else if (value === null) {
        index = serializeNull(buffer2, key, value, index);
      } else if (type === "string") {
        index = serializeString(buffer2, key, value, index);
      } else if (type === "number") {
        index = serializeNumber(buffer2, key, value, index);
      } else if (type === "bigint") {
        index = serializeBigInt(buffer2, key, value, index);
      } else if (type === "boolean") {
        index = serializeBoolean(buffer2, key, value, index);
      } else if (type === "object" && value._bsontype == null) {
        if (value instanceof Date || isDate(value)) {
          index = serializeDate(buffer2, key, value, index);
        } else if (value instanceof Uint8Array || isUint8Array(value)) {
          index = serializeBuffer(buffer2, key, value, index);
        } else if (value instanceof RegExp || isRegExp(value)) {
          index = serializeRegExp(buffer2, key, value, index);
        } else {
          index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
        }
      } else if (type === "object") {
        if (value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
          throw new BSONVersionError();
        } else if (value._bsontype === "ObjectId") {
          index = serializeObjectId(buffer2, key, value, index);
        } else if (value._bsontype === "Decimal128") {
          index = serializeDecimal128(buffer2, key, value, index);
        } else if (value._bsontype === "Long" || value._bsontype === "Timestamp") {
          index = serializeLong(buffer2, key, value, index);
        } else if (value._bsontype === "Double") {
          index = serializeDouble(buffer2, key, value, index);
        } else if (value._bsontype === "Code") {
          index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
        } else if (value._bsontype === "Binary") {
          index = serializeBinary(buffer2, key, value, index);
        } else if (value._bsontype === "BSONSymbol") {
          index = serializeSymbol(buffer2, key, value, index);
        } else if (value._bsontype === "DBRef") {
          index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path);
        } else if (value._bsontype === "BSONRegExp") {
          index = serializeBSONRegExp(buffer2, key, value, index);
        } else if (value._bsontype === "Int32") {
          index = serializeInt32(buffer2, key, value, index);
        } else if (value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
          index = serializeMinMax(buffer2, key, value, index);
        } else if (typeof value._bsontype !== "undefined") {
          throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
        }
      } else if (type === "function" && serializeFunctions) {
        index = serializeFunction(buffer2, key, value, index);
      }
    }
  }
  path.delete(object);
  buffer2[index++] = 0;
  const size = index - startingIndex;
  startingIndex += NumberUtils.setInt32LE(buffer2, startingIndex, size);
  return index;
}
function isBSONType(value) {
  return value != null && typeof value === "object" && "_bsontype" in value && typeof value._bsontype === "string";
}
var keysToCodecs = {
  $oid: ObjectId,
  $binary: Binary,
  $uuid: Binary,
  $symbol: BSONSymbol,
  $numberInt: Int32,
  $numberDecimal: Decimal128,
  $numberDouble: Double,
  $numberLong: Long,
  $minKey: MinKey,
  $maxKey: MaxKey,
  $regex: BSONRegExp,
  $regularExpression: BSONRegExp,
  $timestamp: Timestamp
};
function deserializeValue(value, options = {}) {
  if (typeof value === "number") {
    const in32BitRange = value <= BSON_INT32_MAX && value >= BSON_INT32_MIN;
    const in64BitRange = value <= BSON_INT64_MAX && value >= BSON_INT64_MIN;
    if (options.relaxed || options.legacy) {
      return value;
    }
    if (Number.isInteger(value) && !Object.is(value, -0)) {
      if (in32BitRange) {
        return new Int32(value);
      }
      if (in64BitRange) {
        if (options.useBigInt64) {
          return BigInt(value);
        }
        return Long.fromNumber(value);
      }
    }
    return new Double(value);
  }
  if (value == null || typeof value !== "object")
    return value;
  if (value.$undefined)
    return null;
  const keys = Object.keys(value).filter((k4) => k4.startsWith("$") && value[k4] != null);
  for (let i3 = 0; i3 < keys.length; i3++) {
    const c4 = keysToCodecs[keys[i3]];
    if (c4)
      return c4.fromExtendedJSON(value, options);
  }
  if (value.$date != null) {
    const d5 = value.$date;
    const date = /* @__PURE__ */ new Date();
    if (options.legacy) {
      if (typeof d5 === "number")
        date.setTime(d5);
      else if (typeof d5 === "string")
        date.setTime(Date.parse(d5));
      else if (typeof d5 === "bigint")
        date.setTime(Number(d5));
      else
        throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d5}`);
    } else {
      if (typeof d5 === "string")
        date.setTime(Date.parse(d5));
      else if (Long.isLong(d5))
        date.setTime(d5.toNumber());
      else if (typeof d5 === "number" && options.relaxed)
        date.setTime(d5);
      else if (typeof d5 === "bigint")
        date.setTime(Number(d5));
      else
        throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d5}`);
    }
    return date;
  }
  if (value.$code != null) {
    const copy = Object.assign({}, value);
    if (value.$scope) {
      copy.$scope = deserializeValue(value.$scope);
    }
    return Code.fromExtendedJSON(value);
  }
  if (isDBRefLike(value) || value.$dbPointer) {
    const v2 = value.$ref ? value : value.$dbPointer;
    if (v2 instanceof DBRef)
      return v2;
    const dollarKeys = Object.keys(v2).filter((k4) => k4.startsWith("$"));
    let valid = true;
    dollarKeys.forEach((k4) => {
      if (["$ref", "$id", "$db"].indexOf(k4) === -1)
        valid = false;
    });
    if (valid)
      return DBRef.fromExtendedJSON(v2);
  }
  return value;
}
function serializeArray(array, options) {
  return array.map((v2, index) => {
    options.seenObjects.push({ propertyName: `index ${index}`, obj: null });
    try {
      return serializeValue(v2, options);
    } finally {
      options.seenObjects.pop();
    }
  });
}
function getISOString(date) {
  const isoStr = date.toISOString();
  return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + "Z";
}
function serializeValue(value, options) {
  if (value instanceof Map || isMap(value)) {
    const obj = /* @__PURE__ */ Object.create(null);
    for (const [k4, v2] of value) {
      if (typeof k4 !== "string") {
        throw new BSONError("Can only serialize maps with string keys");
      }
      obj[k4] = v2;
    }
    return serializeValue(obj, options);
  }
  if ((typeof value === "object" || typeof value === "function") && value !== null) {
    const index = options.seenObjects.findIndex((entry) => entry.obj === value);
    if (index !== -1) {
      const props = options.seenObjects.map((entry) => entry.propertyName);
      const leadingPart = props.slice(0, index).map((prop) => `${prop} -> `).join("");
      const alreadySeen = props[index];
      const circularPart = " -> " + props.slice(index + 1, props.length - 1).map((prop) => `${prop} -> `).join("");
      const current = props[props.length - 1];
      const leadingSpace = " ".repeat(leadingPart.length + alreadySeen.length / 2);
      const dashes = "-".repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);
      throw new BSONError(`Converting circular structure to EJSON:
    ${leadingPart}${alreadySeen}${circularPart}${current}
    ${leadingSpace}\\${dashes}/`);
    }
    options.seenObjects[options.seenObjects.length - 1].obj = value;
  }
  if (Array.isArray(value))
    return serializeArray(value, options);
  if (value === void 0)
    return null;
  if (value instanceof Date || isDate(value)) {
    const dateNum = value.getTime(), inRange = dateNum > -1 && dateNum < 2534023188e5;
    if (options.legacy) {
      return options.relaxed && inRange ? { $date: value.getTime() } : { $date: getISOString(value) };
    }
    return options.relaxed && inRange ? { $date: getISOString(value) } : { $date: { $numberLong: value.getTime().toString() } };
  }
  if (typeof value === "number" && (!options.relaxed || !isFinite(value))) {
    if (Number.isInteger(value) && !Object.is(value, -0)) {
      if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {
        return { $numberInt: value.toString() };
      }
      if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX) {
        return { $numberLong: value.toString() };
      }
    }
    return { $numberDouble: Object.is(value, -0) ? "-0.0" : value.toString() };
  }
  if (typeof value === "bigint") {
    if (!options.relaxed) {
      return { $numberLong: BigInt.asIntN(64, value).toString() };
    }
    return Number(BigInt.asIntN(64, value));
  }
  if (value instanceof RegExp || isRegExp(value)) {
    let flags = value.flags;
    if (flags === void 0) {
      const match = value.toString().match(/[gimuy]*$/);
      if (match) {
        flags = match[0];
      }
    }
    const rx = new BSONRegExp(value.source, flags);
    return rx.toExtendedJSON(options);
  }
  if (value != null && typeof value === "object")
    return serializeDocument(value, options);
  return value;
}
var BSON_TYPE_MAPPINGS = {
  Binary: (o5) => new Binary(o5.value(), o5.sub_type),
  Code: (o5) => new Code(o5.code, o5.scope),
  DBRef: (o5) => new DBRef(o5.collection || o5.namespace, o5.oid, o5.db, o5.fields),
  Decimal128: (o5) => new Decimal128(o5.bytes),
  Double: (o5) => new Double(o5.value),
  Int32: (o5) => new Int32(o5.value),
  Long: (o5) => Long.fromBits(o5.low != null ? o5.low : o5.low_, o5.low != null ? o5.high : o5.high_, o5.low != null ? o5.unsigned : o5.unsigned_),
  MaxKey: () => new MaxKey(),
  MinKey: () => new MinKey(),
  ObjectId: (o5) => new ObjectId(o5),
  BSONRegExp: (o5) => new BSONRegExp(o5.pattern, o5.options),
  BSONSymbol: (o5) => new BSONSymbol(o5.value),
  Timestamp: (o5) => Timestamp.fromBits(o5.low, o5.high)
};
function serializeDocument(doc, options) {
  if (doc == null || typeof doc !== "object")
    throw new BSONError("not an object instance");
  const bsontype = doc._bsontype;
  if (typeof bsontype === "undefined") {
    const _doc = {};
    for (const name of Object.keys(doc)) {
      options.seenObjects.push({ propertyName: name, obj: null });
      try {
        const value = serializeValue(doc[name], options);
        if (name === "__proto__") {
          Object.defineProperty(_doc, name, {
            value,
            writable: true,
            enumerable: true,
            configurable: true
          });
        } else {
          _doc[name] = value;
        }
      } finally {
        options.seenObjects.pop();
      }
    }
    return _doc;
  } else if (doc != null && typeof doc === "object" && typeof doc._bsontype === "string" && doc[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
    throw new BSONVersionError();
  } else if (isBSONType(doc)) {
    let outDoc = doc;
    if (typeof outDoc.toExtendedJSON !== "function") {
      const mapper = BSON_TYPE_MAPPINGS[doc._bsontype];
      if (!mapper) {
        throw new BSONError("Unrecognized or invalid _bsontype: " + doc._bsontype);
      }
      outDoc = mapper(outDoc);
    }
    if (bsontype === "Code" && outDoc.scope) {
      outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options));
    } else if (bsontype === "DBRef" && outDoc.oid) {
      outDoc = new DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options));
    }
    return outDoc.toExtendedJSON(options);
  } else {
    throw new BSONError("_bsontype must be a string, but was: " + typeof bsontype);
  }
}
function parse2(text, options) {
  const ejsonOptions = {
    useBigInt64: (options == null ? void 0 : options.useBigInt64) ?? false,
    relaxed: (options == null ? void 0 : options.relaxed) ?? true,
    legacy: (options == null ? void 0 : options.legacy) ?? false
  };
  return JSON.parse(text, (key, value) => {
    if (key.indexOf("\0") !== -1) {
      throw new BSONError(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(key)}`);
    }
    return deserializeValue(value, ejsonOptions);
  });
}
function stringify(value, replacer, space, options) {
  if (space != null && typeof space === "object") {
    options = space;
    space = 0;
  }
  if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
    options = replacer;
    replacer = void 0;
    space = 0;
  }
  const serializeOptions = Object.assign({ relaxed: true, legacy: false }, options, {
    seenObjects: [{ propertyName: "(root)", obj: null }]
  });
  const doc = serializeValue(value, serializeOptions);
  return JSON.stringify(doc, replacer, space);
}
function EJSONserialize(value, options) {
  options = options || {};
  return JSON.parse(stringify(value, options));
}
function EJSONdeserialize(ejson, options) {
  options = options || {};
  return parse2(JSON.stringify(ejson), options);
}
var EJSON = /* @__PURE__ */ Object.create(null);
EJSON.parse = parse2;
EJSON.stringify = stringify;
EJSON.serialize = EJSONserialize;
EJSON.deserialize = EJSONdeserialize;
Object.freeze(EJSON);
var BSONElementType = {
  double: 1,
  string: 2,
  object: 3,
  array: 4,
  binData: 5,
  undefined: 6,
  objectId: 7,
  bool: 8,
  date: 9,
  null: 10,
  regex: 11,
  dbPointer: 12,
  javascript: 13,
  symbol: 14,
  javascriptWithScope: 15,
  int: 16,
  timestamp: 17,
  long: 18,
  decimal: 19,
  minKey: 255,
  maxKey: 127
};
function getSize(source, offset) {
  try {
    return NumberUtils.getNonnegativeInt32LE(source, offset);
  } catch (cause) {
    throw new BSONOffsetError("BSON size cannot be negative", offset, { cause });
  }
}
function findNull(bytes, offset) {
  let nullTerminatorOffset = offset;
  for (; bytes[nullTerminatorOffset] !== 0; nullTerminatorOffset++)
    ;
  if (nullTerminatorOffset === bytes.length - 1) {
    throw new BSONOffsetError("Null terminator not found", offset);
  }
  return nullTerminatorOffset;
}
function parseToElements(bytes, startOffset = 0) {
  startOffset ?? (startOffset = 0);
  if (bytes.length < 5) {
    throw new BSONOffsetError(`Input must be at least 5 bytes, got ${bytes.length} bytes`, startOffset);
  }
  const documentSize = getSize(bytes, startOffset);
  if (documentSize > bytes.length - startOffset) {
    throw new BSONOffsetError(`Parsed documentSize (${documentSize} bytes) does not match input length (${bytes.length} bytes)`, startOffset);
  }
  if (bytes[startOffset + documentSize - 1] !== 0) {
    throw new BSONOffsetError("BSON documents must end in 0x00", startOffset + documentSize);
  }
  const elements = [];
  let offset = startOffset + 4;
  while (offset <= documentSize + startOffset) {
    const type = bytes[offset];
    offset += 1;
    if (type === 0) {
      if (offset - startOffset !== documentSize) {
        throw new BSONOffsetError(`Invalid 0x00 type byte`, offset);
      }
      break;
    }
    const nameOffset = offset;
    const nameLength = findNull(bytes, offset) - nameOffset;
    offset += nameLength + 1;
    let length;
    if (type === BSONElementType.double || type === BSONElementType.long || type === BSONElementType.date || type === BSONElementType.timestamp) {
      length = 8;
    } else if (type === BSONElementType.int) {
      length = 4;
    } else if (type === BSONElementType.objectId) {
      length = 12;
    } else if (type === BSONElementType.decimal) {
      length = 16;
    } else if (type === BSONElementType.bool) {
      length = 1;
    } else if (type === BSONElementType.null || type === BSONElementType.undefined || type === BSONElementType.maxKey || type === BSONElementType.minKey) {
      length = 0;
    } else if (type === BSONElementType.regex) {
      length = findNull(bytes, findNull(bytes, offset) + 1) + 1 - offset;
    } else if (type === BSONElementType.object || type === BSONElementType.array || type === BSONElementType.javascriptWithScope) {
      length = getSize(bytes, offset);
    } else if (type === BSONElementType.string || type === BSONElementType.binData || type === BSONElementType.dbPointer || type === BSONElementType.javascript || type === BSONElementType.symbol) {
      length = getSize(bytes, offset) + 4;
      if (type === BSONElementType.binData) {
        length += 1;
      }
      if (type === BSONElementType.dbPointer) {
        length += 12;
      }
    } else {
      throw new BSONOffsetError(`Invalid 0x${type.toString(16).padStart(2, "0")} type byte`, offset);
    }
    if (length > documentSize) {
      throw new BSONOffsetError("value reports length larger than document", offset);
    }
    elements.push([type, nameOffset, nameLength, offset, length]);
    offset += length;
  }
  return elements;
}
var onDemand = /* @__PURE__ */ Object.create(null);
onDemand.parseToElements = parseToElements;
onDemand.ByteUtils = ByteUtils;
onDemand.NumberUtils = NumberUtils;
Object.freeze(onDemand);
var MAXSIZE = 1024 * 1024 * 17;
var buffer = ByteUtils.allocate(MAXSIZE);
function setInternalBufferSize(size) {
  if (buffer.length < size) {
    buffer = ByteUtils.allocate(size);
  }
}
function serialize(object, options = {}) {
  const checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
  const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
  const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
  const minInternalBufferSize = typeof options.minInternalBufferSize === "number" ? options.minInternalBufferSize : MAXSIZE;
  if (buffer.length < minInternalBufferSize) {
    buffer = ByteUtils.allocate(minInternalBufferSize);
  }
  const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
  const finishedBuffer = ByteUtils.allocateUnsafe(serializationIndex);
  finishedBuffer.set(buffer.subarray(0, serializationIndex), 0);
  return finishedBuffer;
}
function serializeWithBufferAndIndex(object, finalBuffer, options = {}) {
  const checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
  const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
  const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
  const startIndex = typeof options.index === "number" ? options.index : 0;
  const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
  finalBuffer.set(buffer.subarray(0, serializationIndex), startIndex);
  return startIndex + serializationIndex - 1;
}
function deserialize(buffer2, options = {}) {
  return internalDeserialize(ByteUtils.toLocalBufferType(buffer2), options);
}
function calculateObjectSize(object, options = {}) {
  options = options || {};
  const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
  const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
  return internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined);
}
function deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
  const internalOptions = Object.assign({ allowObjectSmallerThanBufferSize: true, index: 0 }, options);
  const bufferData = ByteUtils.toLocalBufferType(data);
  let index = startIndex;
  for (let i3 = 0; i3 < numberOfDocuments; i3++) {
    const size = NumberUtils.getInt32LE(bufferData, index);
    internalOptions.index = index;
    documents[docStartIndex + i3] = internalDeserialize(bufferData, internalOptions);
    index = index + size;
  }
  return index;
}
var bson = Object.freeze({
  __proto__: null,
  BSONError,
  BSONOffsetError,
  BSONRegExp,
  BSONRuntimeError,
  BSONSymbol,
  BSONType,
  BSONValue,
  BSONVersionError,
  Binary,
  Code,
  DBRef,
  Decimal128,
  Double,
  EJSON,
  Int32,
  Long,
  MaxKey,
  MinKey,
  ObjectId,
  Timestamp,
  UUID,
  bsonType,
  calculateObjectSize,
  deserialize,
  deserializeStream,
  onDemand,
  serialize,
  serializeWithBufferAndIndex,
  setInternalBufferSize
});

// node_modules/cbor2/lib/constants.js
var f2 = { POS_INT: 0, NEG_INT: 1, BYTE_STRING: 2, UTF8_STRING: 3, ARRAY: 4, MAP: 5, TAG: 6, SIMPLE_FLOAT: 7 };
var I = { DATE_STRING: 0, DATE_EPOCH: 1, POS_BIGINT: 2, NEG_BIGINT: 3, DECIMAL_FRAC: 4, BIGFLOAT: 5, BASE64URL_EXPECTED: 21, BASE64_EXPECTED: 22, BASE16_EXPECTED: 23, CBOR: 24, URI: 32, BASE64URL: 33, BASE64: 34, MIME: 36, SET: 258, JSON: 262, WTF8: 273, REGEXP: 21066, SELF_DESCRIBED: 55799, INVALID_16: 65535, INVALID_32: 4294967295, INVALID_64: 0xffffffffffffffffn };
var o = { ZERO: 0, ONE: 24, TWO: 25, FOUR: 26, EIGHT: 27, INDEFINITE: 31 };
var T = { FALSE: 20, TRUE: 21, NULL: 22, UNDEFINED: 23 };
var N = class {
};
__publicField(N, "BREAK", Symbol.for("github.com/hildjj/cbor2/break"));
__publicField(N, "ENCODED", Symbol.for("github.com/hildjj/cbor2/cbor-encoded"));
__publicField(N, "LENGTH", Symbol.for("github.com/hildjj/cbor2/length"));
var S = { MIN: -(2n ** 63n), MAX: 2n ** 64n - 1n };

// node_modules/cbor2/lib/tag.js
var _e;
var _i = class _i {
  constructor(e2, t3 = void 0) {
    __publicField(this, "tag");
    __publicField(this, "contents");
    this.tag = e2, this.contents = t3;
  }
  get noChildren() {
    var _a4;
    return !!((_a4 = __privateGet(_i, _e).get(this.tag)) == null ? void 0 : _a4.noChildren);
  }
  static registerDecoder(e2, t3, n2) {
    const o5 = __privateGet(this, _e).get(e2);
    return __privateGet(this, _e).set(e2, t3), o5 && ("comment" in t3 || (t3.comment = o5.comment), "noChildren" in t3 || (t3.noChildren = o5.noChildren)), n2 && !t3.comment && (t3.comment = () => `(${n2})`), o5;
  }
  static clearDecoder(e2) {
    const t3 = __privateGet(this, _e).get(e2);
    return __privateGet(this, _e).delete(e2), t3;
  }
  static getDecoder(e2) {
    return __privateGet(this, _e).get(e2);
  }
  static getAllDecoders() {
    return new Map(__privateGet(this, _e));
  }
  *[Symbol.iterator]() {
    yield this.contents;
  }
  push(e2) {
    return this.contents = e2, 1;
  }
  decode(e2) {
    var _a4;
    const t3 = ((_a4 = e2 == null ? void 0 : e2.tags) == null ? void 0 : _a4.get(this.tag)) ?? __privateGet(_i, _e).get(this.tag);
    return t3 ? t3(this, e2) : this;
  }
  comment(e2, t3) {
    var _a4;
    const n2 = ((_a4 = e2 == null ? void 0 : e2.tags) == null ? void 0 : _a4.get(this.tag)) ?? __privateGet(_i, _e).get(this.tag);
    if (n2 == null ? void 0 : n2.comment) return n2.comment(this, e2, t3);
  }
  toCBOR() {
    return [this.tag, this.contents];
  }
  [Symbol.for("nodejs.util.inspect.custom")](e2, t3, n2) {
    return `${this.tag}(${n2(this.contents, t3)})`;
  }
};
_e = new WeakMap();
__privateAdd(_i, _e, /* @__PURE__ */ new Map());
var i = _i;

// node_modules/cbor2/lib/box.js
function f3(n2) {
  if (n2 != null && typeof n2 == "object") return n2[N.ENCODED];
}
function s(n2) {
  if (n2 != null && typeof n2 == "object") return n2[N.LENGTH];
}
function u(n2, e2) {
  Object.defineProperty(n2, N.ENCODED, { configurable: true, enumerable: false, value: e2 });
}
function d(n2, e2) {
  const r2 = Object(n2);
  return u(r2, e2), r2;
}

// node_modules/cbor2/lib/utils.js
var g = Symbol("CBOR_RANGES");
function c(r2, n2) {
  Object.defineProperty(r2, g, { configurable: false, enumerable: false, writable: false, value: n2 });
}
function f4(r2) {
  return r2[g];
}
function l(r2) {
  return f4(r2) !== void 0;
}
function R(r2, n2 = 0, t3 = r2.length - 1) {
  const o5 = r2.subarray(n2, t3), a3 = f4(r2);
  if (a3) {
    const s4 = [];
    for (const e2 of a3) if (e2[0] >= n2 && e2[0] + e2[1] <= t3) {
      const i3 = [...e2];
      i3[0] -= n2, s4.push(i3);
    }
    s4.length && c(o5, s4);
  }
  return o5;
}
function b(r2) {
  let n2 = Math.ceil(r2.length / 2);
  const t3 = new Uint8Array(n2);
  n2--;
  for (let o5 = r2.length, a3 = o5 - 2; o5 >= 0; o5 = a3, a3 -= 2, n2--) t3[n2] = parseInt(r2.substring(a3, o5), 16);
  return t3;
}
function A(r2) {
  return r2.reduce((n2, t3) => n2 + t3.toString(16).padStart(2, "0"), "");
}
function d2(r2) {
  const n2 = r2.reduce((e2, i3) => e2 + i3.length, 0), t3 = r2.some((e2) => l(e2)), o5 = [], a3 = new Uint8Array(n2);
  let s4 = 0;
  for (const e2 of r2) {
    if (!(e2 instanceof Uint8Array)) throw new TypeError(`Invalid array: ${e2}`);
    if (a3.set(e2, s4), t3) {
      const i3 = e2[g] ?? [[0, e2.length]];
      for (const u2 of i3) u2[0] += s4;
      o5.push(...i3);
    }
    s4 += e2.length;
  }
  return t3 && c(a3, o5), a3;
}
function y(r2) {
  const n2 = atob(r2);
  return Uint8Array.from(n2, (t3) => t3.codePointAt(0));
}
var p = { "-": "+", _: "/" };
function x(r2) {
  const n2 = r2.replace(/[_-]/g, (t3) => p[t3]);
  return y(n2.padEnd(Math.ceil(n2.length / 4) * 4, "="));
}
function h() {
  const r2 = new Uint8Array(4), n2 = new Uint32Array(r2.buffer);
  return !((n2[0] = 1) & r2[0]);
}
function U(r2) {
  var _a4;
  let n2 = "";
  for (const t3 of r2) {
    const o5 = (_a4 = t3.codePointAt(0)) == null ? void 0 : _a4.toString(16).padStart(4, "0");
    n2 && (n2 += ", "), n2 += `U+${o5}`;
  }
  return n2;
}

// node_modules/cbor2/lib/typeEncoderMap.js
var _e2;
var s2 = class {
  constructor() {
    __privateAdd(this, _e2, /* @__PURE__ */ new Map());
  }
  registerEncoder(e2, t3) {
    const n2 = __privateGet(this, _e2).get(e2);
    return __privateGet(this, _e2).set(e2, t3), n2;
  }
  get(e2) {
    return __privateGet(this, _e2).get(e2);
  }
  delete(e2) {
    return __privateGet(this, _e2).delete(e2);
  }
  clear() {
    __privateGet(this, _e2).clear();
  }
};
_e2 = new WeakMap();

// node_modules/cbor2/lib/sorts.js
function f5(c4, d5) {
  const [u2, a3, n2] = c4, [l6, s4, t3] = d5, r2 = Math.min(n2.length, t3.length);
  for (let o5 = 0; o5 < r2; o5++) {
    const e2 = n2[o5] - t3[o5];
    if (e2 !== 0) return e2;
  }
  return 0;
}

// node_modules/cbor2/lib/writer.js
var _r, _i2, _s, _t, _a2, _e_instances, n_fn, o_fn, l_fn, e_fn, h_fn;
var _e3 = class _e3 {
  constructor(t3 = {}) {
    __privateAdd(this, _e_instances);
    __privateAdd(this, _r);
    __privateAdd(this, _i2, []);
    __privateAdd(this, _s, null);
    __privateAdd(this, _t, 0);
    __privateAdd(this, _a2, 0);
    if (__privateSet(this, _r, { ..._e3.defaultOptions, ...t3 }), __privateGet(this, _r).chunkSize < 8) throw new RangeError(`Expected size >= 8, got ${__privateGet(this, _r).chunkSize}`);
    __privateMethod(this, _e_instances, n_fn).call(this);
  }
  get length() {
    return __privateGet(this, _a2);
  }
  read() {
    __privateMethod(this, _e_instances, o_fn).call(this);
    const t3 = new Uint8Array(__privateGet(this, _a2));
    let i3 = 0;
    for (const s4 of __privateGet(this, _i2)) t3.set(s4, i3), i3 += s4.length;
    return __privateMethod(this, _e_instances, n_fn).call(this), t3;
  }
  write(t3) {
    const i3 = t3.length;
    i3 > __privateMethod(this, _e_instances, l_fn).call(this) ? (__privateMethod(this, _e_instances, o_fn).call(this), i3 > __privateGet(this, _r).chunkSize ? (__privateGet(this, _i2).push(t3), __privateMethod(this, _e_instances, n_fn).call(this)) : (__privateMethod(this, _e_instances, n_fn).call(this), __privateGet(this, _i2)[__privateGet(this, _i2).length - 1].set(t3), __privateSet(this, _t, i3))) : (__privateGet(this, _i2)[__privateGet(this, _i2).length - 1].set(t3, __privateGet(this, _t)), __privateSet(this, _t, __privateGet(this, _t) + i3)), __privateSet(this, _a2, __privateGet(this, _a2) + i3);
  }
  writeUint8(t3) {
    __privateMethod(this, _e_instances, e_fn).call(this, 1), __privateGet(this, _s).setUint8(__privateGet(this, _t), t3), __privateMethod(this, _e_instances, h_fn).call(this, 1);
  }
  writeUint16(t3, i3 = false) {
    __privateMethod(this, _e_instances, e_fn).call(this, 2), __privateGet(this, _s).setUint16(__privateGet(this, _t), t3, i3), __privateMethod(this, _e_instances, h_fn).call(this, 2);
  }
  writeUint32(t3, i3 = false) {
    __privateMethod(this, _e_instances, e_fn).call(this, 4), __privateGet(this, _s).setUint32(__privateGet(this, _t), t3, i3), __privateMethod(this, _e_instances, h_fn).call(this, 4);
  }
  writeBigUint64(t3, i3 = false) {
    __privateMethod(this, _e_instances, e_fn).call(this, 8), __privateGet(this, _s).setBigUint64(__privateGet(this, _t), t3, i3), __privateMethod(this, _e_instances, h_fn).call(this, 8);
  }
  writeInt16(t3, i3 = false) {
    __privateMethod(this, _e_instances, e_fn).call(this, 2), __privateGet(this, _s).setInt16(__privateGet(this, _t), t3, i3), __privateMethod(this, _e_instances, h_fn).call(this, 2);
  }
  writeInt32(t3, i3 = false) {
    __privateMethod(this, _e_instances, e_fn).call(this, 4), __privateGet(this, _s).setInt32(__privateGet(this, _t), t3, i3), __privateMethod(this, _e_instances, h_fn).call(this, 4);
  }
  writeBigInt64(t3, i3 = false) {
    __privateMethod(this, _e_instances, e_fn).call(this, 8), __privateGet(this, _s).setBigInt64(__privateGet(this, _t), t3, i3), __privateMethod(this, _e_instances, h_fn).call(this, 8);
  }
  writeFloat32(t3, i3 = false) {
    __privateMethod(this, _e_instances, e_fn).call(this, 4), __privateGet(this, _s).setFloat32(__privateGet(this, _t), t3, i3), __privateMethod(this, _e_instances, h_fn).call(this, 4);
  }
  writeFloat64(t3, i3 = false) {
    __privateMethod(this, _e_instances, e_fn).call(this, 8), __privateGet(this, _s).setFloat64(__privateGet(this, _t), t3, i3), __privateMethod(this, _e_instances, h_fn).call(this, 8);
  }
  clear() {
    __privateSet(this, _a2, 0), __privateSet(this, _i2, []), __privateMethod(this, _e_instances, n_fn).call(this);
  }
};
_r = new WeakMap();
_i2 = new WeakMap();
_s = new WeakMap();
_t = new WeakMap();
_a2 = new WeakMap();
_e_instances = new WeakSet();
n_fn = function() {
  const t3 = new Uint8Array(__privateGet(this, _r).chunkSize);
  __privateGet(this, _i2).push(t3), __privateSet(this, _t, 0), __privateSet(this, _s, new DataView(t3.buffer, t3.byteOffset, t3.byteLength));
};
o_fn = function() {
  if (__privateGet(this, _t) === 0) {
    __privateGet(this, _i2).pop();
    return;
  }
  const t3 = __privateGet(this, _i2).length - 1;
  __privateGet(this, _i2)[t3] = __privateGet(this, _i2)[t3].subarray(0, __privateGet(this, _t)), __privateSet(this, _t, 0), __privateSet(this, _s, null);
};
l_fn = function() {
  const t3 = __privateGet(this, _i2).length - 1;
  return __privateGet(this, _i2)[t3].length - __privateGet(this, _t);
};
e_fn = function(t3) {
  __privateMethod(this, _e_instances, l_fn).call(this) < t3 && (__privateMethod(this, _e_instances, o_fn).call(this), __privateMethod(this, _e_instances, n_fn).call(this));
};
h_fn = function(t3) {
  __privateSet(this, _t, __privateGet(this, _t) + t3), __privateSet(this, _a2, __privateGet(this, _a2) + t3);
};
__publicField(_e3, "defaultOptions", { chunkSize: 4096 });
var e = _e3;

// node_modules/cbor2/lib/float.js
function o2(e2, n2 = 0, t3 = false) {
  const r2 = e2[n2] & 128 ? -1 : 1, f7 = (e2[n2] & 124) >> 2, a3 = (e2[n2] & 3) << 8 | e2[n2 + 1];
  if (f7 === 0) {
    if (t3 && a3 !== 0) throw new Error(`Unwanted subnormal: ${r2 * 5960464477539063e-23 * a3}`);
    return r2 * 5960464477539063e-23 * a3;
  } else if (f7 === 31) return a3 ? NaN : r2 * (1 / 0);
  return r2 * 2 ** (f7 - 25) * (1024 + a3);
}
function s3(e2) {
  const n2 = new DataView(new ArrayBuffer(4));
  n2.setFloat32(0, e2, false);
  const t3 = n2.getUint32(0, false);
  if ((t3 & 8191) !== 0) return null;
  let r2 = t3 >> 16 & 32768;
  const f7 = t3 >> 23 & 255, a3 = t3 & 8388607;
  if (!(f7 === 0 && a3 === 0)) if (f7 >= 113 && f7 <= 142) r2 += (f7 - 112 << 10) + (a3 >> 13);
  else if (f7 >= 103 && f7 < 113) {
    if (a3 & (1 << 126 - f7) - 1) return null;
    r2 += a3 + 8388608 >> 126 - f7;
  } else if (f7 === 255) r2 |= 31744, r2 |= a3 >> 13;
  else return null;
  return r2;
}
function i2(e2) {
  if (e2 !== 0) {
    const n2 = new ArrayBuffer(8), t3 = new DataView(n2);
    t3.setFloat64(0, e2, false);
    const r2 = t3.getBigUint64(0, false);
    if ((r2 & 0x7ff0000000000000n) === 0n) return r2 & 0x8000000000000000n ? -0 : 0;
  }
  return e2;
}
function l2(e2) {
  switch (e2.length) {
    case 2:
      o2(e2, 0, true);
      break;
    case 4: {
      const n2 = new DataView(e2.buffer, e2.byteOffset, e2.byteLength), t3 = n2.getUint32(0, false);
      if ((t3 & 2139095040) === 0 && t3 & 8388607) throw new Error(`Unwanted subnormal: ${n2.getFloat32(0, false)}`);
      break;
    }
    case 8: {
      const n2 = new DataView(e2.buffer, e2.byteOffset, e2.byteLength), t3 = n2.getBigUint64(0, false);
      if ((t3 & 0x7ff0000000000000n) === 0n && t3 & 0x000fffffffffffn) throw new Error(`Unwanted subnormal: ${n2.getFloat64(0, false)}`);
      break;
    }
    default:
      throw new TypeError(`Bad input to isSubnormal: ${e2}`);
  }
}

// node_modules/@cto.af/wtf8/lib/errors.js
var DecodeError = class extends TypeError {
  constructor() {
    super("The encoded data was not valid for encoding wtf-8");
    __publicField(this, "code", "ERR_ENCODING_INVALID_ENCODED_DATA");
  }
};
var InvalidEncodingError = class extends RangeError {
  constructor(label) {
    super(`Invalid encoding: "${label}"`);
    __publicField(this, "code", "ERR_ENCODING_NOT_SUPPORTED");
  }
};

// node_modules/@cto.af/wtf8/lib/const.js
var BOM = 65279;
var EMPTY = new Uint8Array(0);
var MIN_HIGH_SURROGATE = 55296;
var MIN_LOW_SURROGATE = 56320;
var REPLACEMENT = 65533;
var WTF8 = "wtf-8";

// node_modules/@cto.af/wtf8/lib/decode.js
function isArrayBufferView(input) {
  return input && !(input instanceof ArrayBuffer) && input.buffer instanceof ArrayBuffer;
}
function getUint8(input) {
  if (!input) {
    return EMPTY;
  }
  if (input instanceof Uint8Array) {
    return input;
  }
  if (isArrayBufferView(input)) {
    return new Uint8Array(input.buffer, input.byteOffset, input.byteLength);
  }
  return new Uint8Array(input);
}
var REMAINDER = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  -1,
  -1,
  -1,
  -1,
  1,
  1,
  2,
  3
];
var _left, _cur, _pending, _first, _buf;
var _Wtf8Decoder = class _Wtf8Decoder {
  constructor(label = "wtf8", options = void 0) {
    __publicField(this, "encoding", WTF8);
    __publicField(this, "fatal");
    __publicField(this, "ignoreBOM");
    __publicField(this, "bufferSize");
    __privateAdd(this, _left, 0);
    __privateAdd(this, _cur, 0);
    __privateAdd(this, _pending, 0);
    __privateAdd(this, _first, true);
    __privateAdd(this, _buf);
    if (label.toLowerCase().replace("-", "") !== "wtf8") {
      throw new InvalidEncodingError(label);
    }
    this.fatal = Boolean(options == null ? void 0 : options.fatal);
    this.ignoreBOM = Boolean(options == null ? void 0 : options.ignoreBOM);
    this.bufferSize = Math.floor((options == null ? void 0 : options.bufferSize) ?? _Wtf8Decoder.DEFAULT_BUFFERSIZE);
    if (isNaN(this.bufferSize) || this.bufferSize < 1) {
      throw new RangeError(`Invalid buffer size: ${options == null ? void 0 : options.bufferSize}`);
    }
    __privateSet(this, _buf, new Uint16Array(this.bufferSize));
  }
  decode(input, options) {
    const streaming = Boolean(options == null ? void 0 : options.stream);
    const bytes = getUint8(input);
    const res = [];
    const out = __privateGet(this, _buf);
    const maxSize = this.bufferSize - 3;
    let pos = 0;
    const fatal = () => {
      __privateSet(this, _cur, 0);
      __privateSet(this, _left, 0);
      __privateSet(this, _pending, 0);
      if (this.fatal) {
        throw new DecodeError();
      }
      out[pos++] = REPLACEMENT;
    };
    const fatals = () => {
      const p4 = __privateGet(this, _pending);
      for (let i3 = 0; i3 < p4; i3++) {
        fatal();
      }
    };
    const oneByte = (b4) => {
      if (__privateGet(this, _left) === 0) {
        const n2 = REMAINDER[b4 >> 4];
        switch (n2) {
          case -1:
            fatal();
            break;
          case 0:
            out[pos++] = b4;
            break;
          case 1:
            __privateSet(this, _cur, b4 & 31);
            if ((__privateGet(this, _cur) & 30) === 0) {
              fatal();
            } else {
              __privateSet(this, _left, 1);
              __privateSet(this, _pending, 1);
            }
            break;
          case 2:
            __privateSet(this, _cur, b4 & 15);
            __privateSet(this, _left, 2);
            __privateSet(this, _pending, 1);
            break;
          case 3:
            if (b4 & 8) {
              fatal();
            } else {
              __privateSet(this, _cur, b4 & 7);
              __privateSet(this, _left, 3);
              __privateSet(this, _pending, 1);
            }
            break;
        }
      } else {
        if ((b4 & 192) !== 128) {
          fatals();
          return oneByte(b4);
        }
        if (__privateGet(this, _pending) === 1 && __privateGet(this, _left) === 2 && __privateGet(this, _cur) === 0 && (b4 & 32) === 0) {
          fatals();
          return oneByte(b4);
        }
        if (__privateGet(this, _left) === 3 && __privateGet(this, _cur) === 0 && (b4 & 48) === 0) {
          fatals();
          return oneByte(b4);
        }
        __privateSet(this, _cur, __privateGet(this, _cur) << 6 | b4 & 63);
        __privateWrapper(this, _pending)._++;
        if (--__privateWrapper(this, _left)._ === 0) {
          if (this.ignoreBOM || !__privateGet(this, _first) || __privateGet(this, _cur) !== BOM) {
            if (__privateGet(this, _cur) < 65536) {
              out[pos++] = __privateGet(this, _cur);
            } else {
              const cp = __privateGet(this, _cur) - 65536;
              out[pos++] = cp >>> 10 & 1023 | MIN_HIGH_SURROGATE;
              out[pos++] = cp & 1023 | MIN_LOW_SURROGATE;
            }
          }
          __privateSet(this, _cur, 0);
          __privateSet(this, _pending, 0);
          __privateSet(this, _first, false);
        }
      }
    };
    for (const b4 of bytes) {
      if (pos >= maxSize) {
        res.push(String.fromCharCode.apply(null, out.subarray(0, pos)));
        pos = 0;
      }
      oneByte(b4);
    }
    if (!streaming) {
      __privateSet(this, _first, true);
      if (__privateGet(this, _cur) || __privateGet(this, _left)) {
        fatals();
      }
    }
    if (pos > 0) {
      res.push(String.fromCharCode.apply(null, out.subarray(0, pos)));
    }
    return res.join("");
  }
};
_left = new WeakMap();
_cur = new WeakMap();
_pending = new WeakMap();
_first = new WeakMap();
_buf = new WeakMap();
__publicField(_Wtf8Decoder, "DEFAULT_BUFFERSIZE", 4096);
var Wtf8Decoder = _Wtf8Decoder;

// node_modules/@cto.af/wtf8/lib/encode.js
function utf8length(str) {
  let len = 0;
  for (const s4 of str) {
    const cp = s4.codePointAt(0);
    if (cp < 128) {
      len++;
    } else if (cp < 2048) {
      len += 2;
    } else if (cp < 65536) {
      len += 3;
    } else {
      len += 4;
    }
  }
  return len;
}
var Wtf8Encoder = class {
  constructor() {
    __publicField(this, "encoding", WTF8);
  }
  encode(input) {
    if (!input) {
      return EMPTY;
    }
    const buf = new Uint8Array(utf8length(String(input)));
    this.encodeInto(input, buf);
    return buf;
  }
  encodeInto(source, destination) {
    const str = String(source);
    const len = str.length;
    const outLen = destination.length;
    let written = 0;
    let read = 0;
    for (read = 0; read < len; read++) {
      const c4 = str.codePointAt(read);
      if (c4 < 128) {
        if (written >= outLen) {
          break;
        }
        destination[written++] = c4;
      } else if (c4 < 2048) {
        if (written >= outLen - 1) {
          break;
        }
        destination[written++] = 192 | c4 >> 6;
        destination[written++] = 128 | c4 & 63;
      } else if (c4 < 65536) {
        if (written >= outLen - 2) {
          break;
        }
        destination[written++] = 224 | c4 >> 12;
        destination[written++] = 128 | c4 >> 6 & 63;
        destination[written++] = 128 | c4 & 63;
      } else {
        if (written >= outLen - 3) {
          break;
        }
        destination[written++] = 240 | c4 >> 18;
        destination[written++] = 128 | c4 >> 12 & 63;
        destination[written++] = 128 | c4 >> 6 & 63;
        destination[written++] = 128 | c4 & 63;
        read++;
      }
    }
    return {
      read,
      written
    };
  }
};

// node_modules/cbor2/lib/encoder.js
var { ENCODED: se } = N;
var U2 = f2.SIMPLE_FLOAT << 5 | o.TWO;
var h2 = f2.SIMPLE_FLOAT << 5 | o.FOUR;
var B = f2.SIMPLE_FLOAT << 5 | o.EIGHT;
var j = f2.SIMPLE_FLOAT << 5 | T.TRUE;
var P = f2.SIMPLE_FLOAT << 5 | T.FALSE;
var $ = f2.SIMPLE_FLOAT << 5 | T.UNDEFINED;
var q = f2.SIMPLE_FLOAT << 5 | T.NULL;
var z = new TextEncoder();
var K = new Wtf8Encoder();
var k = { ...e.defaultOptions, avoidInts: false, cde: false, collapseBigInts: true, dcbor: false, float64: false, flushToZero: false, forceEndian: null, ignoreOriginalEncoding: false, largeNegativeAsBigInt: false, reduceUnsafeNumbers: false, rejectBigInts: false, rejectCustomSimples: false, rejectDuplicateKeys: false, rejectFloats: false, rejectUndefined: false, simplifyNegativeZero: false, sortKeys: null, stringNormalization: null, types: null, wtf8: false };
var F = { cde: true, ignoreOriginalEncoding: true, sortKeys: f5 };
var H = { ...F, dcbor: true, largeNegativeAsBigInt: true, reduceUnsafeNumbers: true, rejectCustomSimples: true, rejectDuplicateKeys: true, rejectUndefined: true, simplifyNegativeZero: true, stringNormalization: "NFC" };
function y2(e2) {
  const n2 = e2 < 0;
  return typeof e2 == "bigint" ? [n2 ? -e2 - 1n : e2, n2] : [n2 ? -e2 - 1 : e2, n2];
}
function T2(e2, n2, t3) {
  if (t3.rejectFloats) throw new Error(`Attempt to encode an unwanted floating point number: ${e2}`);
  if (isNaN(e2)) n2.writeUint8(U2), n2.writeUint16(32256);
  else if (!t3.float64 && Math.fround(e2) === e2) {
    const r2 = s3(e2);
    r2 === null ? (n2.writeUint8(h2), n2.writeFloat32(e2)) : (n2.writeUint8(U2), n2.writeUint16(r2));
  } else n2.writeUint8(B), n2.writeFloat64(e2);
}
function a(e2, n2, t3) {
  const [r2, i3] = y2(e2);
  if (i3 && t3) throw new TypeError(`Negative size: ${e2}`);
  t3 ?? (t3 = i3 ? f2.NEG_INT : f2.POS_INT), t3 <<= 5, r2 < 24 ? n2.writeUint8(t3 | r2) : r2 <= 255 ? (n2.writeUint8(t3 | o.ONE), n2.writeUint8(r2)) : r2 <= 65535 ? (n2.writeUint8(t3 | o.TWO), n2.writeUint16(r2)) : r2 <= 4294967295 ? (n2.writeUint8(t3 | o.FOUR), n2.writeUint32(r2)) : (n2.writeUint8(t3 | o.EIGHT), n2.writeBigUint64(BigInt(r2)));
}
function p2(e2, n2, t3) {
  typeof e2 == "number" ? a(e2, n2, f2.TAG) : typeof e2 == "object" && !t3.ignoreOriginalEncoding && N.ENCODED in e2 ? n2.write(e2[N.ENCODED]) : e2 <= Number.MAX_SAFE_INTEGER ? a(Number(e2), n2, f2.TAG) : (n2.writeUint8(f2.TAG << 5 | o.EIGHT), n2.writeBigUint64(BigInt(e2)));
}
function N2(e2, n2, t3) {
  const [r2, i3] = y2(e2);
  if (t3.collapseBigInts && (!t3.largeNegativeAsBigInt || e2 >= -0x8000000000000000n)) {
    if (r2 <= 0xffffffffn) {
      a(Number(e2), n2);
      return;
    }
    if (r2 <= 0xffffffffffffffffn) {
      const E2 = (i3 ? f2.NEG_INT : f2.POS_INT) << 5;
      n2.writeUint8(E2 | o.EIGHT), n2.writeBigUint64(r2);
      return;
    }
  }
  if (t3.rejectBigInts) throw new Error(`Attempt to encode unwanted bigint: ${e2}`);
  const o5 = i3 ? I.NEG_BIGINT : I.POS_BIGINT, c4 = r2.toString(16), s4 = c4.length % 2 ? "0" : "";
  p2(o5, n2, t3);
  const u2 = b(s4 + c4);
  a(u2.length, n2, f2.BYTE_STRING), n2.write(u2);
}
function Y(e2, n2, t3) {
  t3.flushToZero && (e2 = i2(e2)), Object.is(e2, -0) ? t3.simplifyNegativeZero ? t3.avoidInts ? T2(0, n2, t3) : a(0, n2) : T2(e2, n2, t3) : !t3.avoidInts && Number.isSafeInteger(e2) ? a(e2, n2) : t3.reduceUnsafeNumbers && Math.floor(e2) === e2 && e2 >= S.MIN && e2 <= S.MAX ? N2(BigInt(e2), n2, t3) : T2(e2, n2, t3);
}
function Z(e2, n2, t3) {
  const r2 = t3.stringNormalization ? e2.normalize(t3.stringNormalization) : e2;
  if (t3.wtf8 && !e2.isWellFormed()) {
    const i3 = K.encode(r2);
    p2(I.WTF8, n2, t3), a(i3.length, n2, f2.BYTE_STRING), n2.write(i3);
  } else {
    const i3 = z.encode(r2);
    a(i3.length, n2, f2.UTF8_STRING), n2.write(i3);
  }
}
function J(e2, n2, t3) {
  const r2 = e2;
  R2(r2, r2.length, f2.ARRAY, n2, t3);
  for (const i3 of r2) g2(i3, n2, t3);
}
function V(e2, n2) {
  a(e2.length, n2, f2.BYTE_STRING), n2.write(e2);
}
var b2 = new s2();
b2.registerEncoder(Array, J), b2.registerEncoder(Uint8Array, V);
function ce(e2, n2) {
  return b2.registerEncoder(e2, n2);
}
function R2(e2, n2, t3, r2, i3) {
  const o5 = s(e2);
  o5 && !i3.ignoreOriginalEncoding ? r2.write(o5) : a(n2, r2, t3);
}
function X(e2, n2, t3) {
  var _a4;
  if (e2 === null) {
    n2.writeUint8(q);
    return;
  }
  if (!t3.ignoreOriginalEncoding && N.ENCODED in e2) {
    n2.write(e2[N.ENCODED]);
    return;
  }
  const r2 = e2.constructor;
  if (r2) {
    const o5 = ((_a4 = t3.types) == null ? void 0 : _a4.get(r2)) ?? b2.get(r2);
    if (o5) {
      const c4 = o5(e2, n2, t3);
      if (c4 !== void 0) {
        if (!Array.isArray(c4) || c4.length !== 2) throw new Error("Invalid encoder return value");
        (typeof c4[0] == "bigint" || isFinite(Number(c4[0]))) && p2(c4[0], n2, t3), g2(c4[1], n2, t3);
      }
      return;
    }
  }
  if (typeof e2.toCBOR == "function") {
    const o5 = e2.toCBOR(n2, t3);
    o5 && ((typeof o5[0] == "bigint" || isFinite(Number(o5[0]))) && p2(o5[0], n2, t3), g2(o5[1], n2, t3));
    return;
  }
  if (typeof e2.toJSON == "function") {
    g2(e2.toJSON(), n2, t3);
    return;
  }
  const i3 = Object.entries(e2).map((o5) => [o5[0], o5[1], Q(o5[0], t3)]);
  t3.sortKeys && i3.sort(t3.sortKeys), R2(e2, i3.length, f2.MAP, n2, t3);
  for (const [o5, c4, s4] of i3) n2.write(s4), g2(c4, n2, t3);
}
function g2(e2, n2, t3) {
  switch (typeof e2) {
    case "number":
      Y(e2, n2, t3);
      break;
    case "bigint":
      N2(e2, n2, t3);
      break;
    case "string":
      Z(e2, n2, t3);
      break;
    case "boolean":
      n2.writeUint8(e2 ? j : P);
      break;
    case "undefined":
      if (t3.rejectUndefined) throw new Error("Attempt to encode unwanted undefined.");
      n2.writeUint8($);
      break;
    case "object":
      X(e2, n2, t3);
      break;
    case "symbol":
      throw new TypeError(`Unknown symbol: ${e2.toString()}`);
    default:
      throw new TypeError(`Unknown type: ${typeof e2}, ${String(e2)}`);
  }
}
function Q(e2, n2 = {}) {
  const t3 = { ...k };
  n2.dcbor ? Object.assign(t3, H) : n2.cde && Object.assign(t3, F), Object.assign(t3, n2);
  const r2 = new e(t3);
  return g2(e2, r2, t3), r2.read();
}

// node_modules/cbor2/lib/options.js
var o3 = ((e2) => (e2[e2.NEVER = -1] = "NEVER", e2[e2.PREFERRED = 0] = "PREFERRED", e2[e2.ALWAYS = 1] = "ALWAYS", e2))(o3 || {});

// node_modules/cbor2/lib/simple.js
var _t2 = class _t2 {
  constructor(e2) {
    __publicField(this, "value");
    this.value = e2;
  }
  static create(e2) {
    return _t2.KnownSimple.has(e2) ? _t2.KnownSimple.get(e2) : new _t2(e2);
  }
  toCBOR(e2, i3) {
    if (i3.rejectCustomSimples) throw new Error(`Cannot encode non-standard Simple value: ${this.value}`);
    a(this.value, e2, f2.SIMPLE_FLOAT);
  }
  toString() {
    return `simple(${this.value})`;
  }
  decode() {
    return _t2.KnownSimple.has(this.value) ? _t2.KnownSimple.get(this.value) : this;
  }
  [Symbol.for("nodejs.util.inspect.custom")](e2, i3, r2) {
    return `simple(${r2(this.value, i3)})`;
  }
};
__publicField(_t2, "KnownSimple", /* @__PURE__ */ new Map([[T.FALSE, false], [T.TRUE, true], [T.NULL, null], [T.UNDEFINED, void 0]]));
var t = _t2;

// node_modules/cbor2/lib/decodeStream.js
var p3 = new TextDecoder("utf8", { fatal: true, ignoreBOM: true });
var _t3, _r2, _e4, _i3, _y_instances, n_fn2, a_fn, s_fn;
var _y = class _y {
  constructor(t3, r2) {
    __privateAdd(this, _y_instances);
    __privateAdd(this, _t3);
    __privateAdd(this, _r2);
    __privateAdd(this, _e4, 0);
    __privateAdd(this, _i3);
    if (__privateSet(this, _i3, { ..._y.defaultOptions, ...r2 }), typeof t3 == "string") switch (__privateGet(this, _i3).encoding) {
      case "hex":
        __privateSet(this, _t3, b(t3));
        break;
      case "base64":
        __privateSet(this, _t3, y(t3));
        break;
      default:
        throw new TypeError(`Encoding not implemented: "${__privateGet(this, _i3).encoding}"`);
    }
    else __privateSet(this, _t3, t3);
    __privateSet(this, _r2, new DataView(__privateGet(this, _t3).buffer, __privateGet(this, _t3).byteOffset, __privateGet(this, _t3).byteLength));
  }
  toHere(t3) {
    return R(__privateGet(this, _t3), t3, __privateGet(this, _e4));
  }
  *[Symbol.iterator]() {
    if (yield* __privateMethod(this, _y_instances, n_fn2).call(this, 0), __privateGet(this, _e4) !== __privateGet(this, _t3).length) throw new Error("Extra data in input");
  }
  *seq() {
    for (; __privateGet(this, _e4) < __privateGet(this, _t3).length; ) yield* __privateMethod(this, _y_instances, n_fn2).call(this, 0);
  }
};
_t3 = new WeakMap();
_r2 = new WeakMap();
_e4 = new WeakMap();
_i3 = new WeakMap();
_y_instances = new WeakSet();
n_fn2 = function* (t3) {
  if (t3++ > __privateGet(this, _i3).maxDepth) throw new Error(`Maximum depth ${__privateGet(this, _i3).maxDepth} exceeded`);
  const r2 = __privateGet(this, _e4), c4 = __privateGet(this, _r2).getUint8(__privateWrapper(this, _e4)._++), i3 = c4 >> 5, n2 = c4 & 31;
  let e2 = n2, f7 = false, a3 = 0;
  switch (n2) {
    case o.ONE:
      if (a3 = 1, e2 = __privateGet(this, _r2).getUint8(__privateGet(this, _e4)), i3 === f2.SIMPLE_FLOAT) {
        if (e2 < 32) throw new Error(`Invalid simple encoding in extra byte: ${e2}`);
        f7 = true;
      } else if (__privateGet(this, _i3).requirePreferred && e2 < 24) throw new Error(`Unexpectedly long integer encoding (1) for ${e2}`);
      break;
    case o.TWO:
      if (a3 = 2, i3 === f2.SIMPLE_FLOAT) e2 = o2(__privateGet(this, _t3), __privateGet(this, _e4));
      else if (e2 = __privateGet(this, _r2).getUint16(__privateGet(this, _e4), false), __privateGet(this, _i3).requirePreferred && e2 <= 255) throw new Error(`Unexpectedly long integer encoding (2) for ${e2}`);
      break;
    case o.FOUR:
      if (a3 = 4, i3 === f2.SIMPLE_FLOAT) e2 = __privateGet(this, _r2).getFloat32(__privateGet(this, _e4), false);
      else if (e2 = __privateGet(this, _r2).getUint32(__privateGet(this, _e4), false), __privateGet(this, _i3).requirePreferred && e2 <= 65535) throw new Error(`Unexpectedly long integer encoding (4) for ${e2}`);
      break;
    case o.EIGHT: {
      if (a3 = 8, i3 === f2.SIMPLE_FLOAT) e2 = __privateGet(this, _r2).getFloat64(__privateGet(this, _e4), false);
      else if (e2 = __privateGet(this, _r2).getBigUint64(__privateGet(this, _e4), false), e2 <= Number.MAX_SAFE_INTEGER && (e2 = Number(e2)), __privateGet(this, _i3).requirePreferred && e2 <= 4294967295) throw new Error(`Unexpectedly long integer encoding (8) for ${e2}`);
      break;
    }
    case 28:
    case 29:
    case 30:
      throw new Error(`Additional info not implemented: ${n2}`);
    case o.INDEFINITE:
      switch (i3) {
        case f2.POS_INT:
        case f2.NEG_INT:
        case f2.TAG:
          throw new Error(`Invalid indefinite encoding for MT ${i3}`);
        case f2.SIMPLE_FLOAT:
          yield [i3, n2, N.BREAK, r2, 0];
          return;
      }
      e2 = 1 / 0;
      break;
    default:
      f7 = true;
  }
  switch (__privateSet(this, _e4, __privateGet(this, _e4) + a3), i3) {
    case f2.POS_INT:
      yield [i3, n2, e2, r2, a3];
      break;
    case f2.NEG_INT:
      yield [i3, n2, typeof e2 == "bigint" ? -1n - e2 : -1 - Number(e2), r2, a3];
      break;
    case f2.BYTE_STRING:
      e2 === 1 / 0 ? yield* __privateMethod(this, _y_instances, s_fn).call(this, i3, t3, r2) : yield [i3, n2, __privateMethod(this, _y_instances, a_fn).call(this, e2), r2, e2];
      break;
    case f2.UTF8_STRING:
      e2 === 1 / 0 ? yield* __privateMethod(this, _y_instances, s_fn).call(this, i3, t3, r2) : yield [i3, n2, p3.decode(__privateMethod(this, _y_instances, a_fn).call(this, e2)), r2, e2];
      break;
    case f2.ARRAY:
      if (e2 === 1 / 0) yield* __privateMethod(this, _y_instances, s_fn).call(this, i3, t3, r2, false);
      else {
        const o5 = Number(e2);
        yield [i3, n2, o5, r2, a3];
        for (let h4 = 0; h4 < o5; h4++) yield* __privateMethod(this, _y_instances, n_fn2).call(this, t3 + 1);
      }
      break;
    case f2.MAP:
      if (e2 === 1 / 0) yield* __privateMethod(this, _y_instances, s_fn).call(this, i3, t3, r2, false);
      else {
        const o5 = Number(e2);
        yield [i3, n2, o5, r2, a3];
        for (let h4 = 0; h4 < o5; h4++) yield* __privateMethod(this, _y_instances, n_fn2).call(this, t3), yield* __privateMethod(this, _y_instances, n_fn2).call(this, t3);
      }
      break;
    case f2.TAG:
      yield [i3, n2, e2, r2, a3], yield* __privateMethod(this, _y_instances, n_fn2).call(this, t3);
      break;
    case f2.SIMPLE_FLOAT: {
      const o5 = e2;
      f7 && (e2 = t.create(Number(e2))), yield [i3, n2, e2, r2, o5];
      break;
    }
  }
};
a_fn = function(t3) {
  const r2 = R(__privateGet(this, _t3), __privateGet(this, _e4), __privateSet(this, _e4, __privateGet(this, _e4) + t3));
  if (r2.length !== t3) throw new Error(`Unexpected end of stream reading ${t3} bytes, got ${r2.length}`);
  return r2;
};
s_fn = function* (t3, r2, c4, i3 = true) {
  for (yield [t3, o.INDEFINITE, 1 / 0, c4, 1 / 0]; ; ) {
    const n2 = __privateMethod(this, _y_instances, n_fn2).call(this, r2), e2 = n2.next(), [f7, a3, o5] = e2.value;
    if (o5 === N.BREAK) {
      yield e2.value, n2.next();
      return;
    }
    if (i3) {
      if (f7 !== t3) throw new Error(`Unmatched major type.  Expected ${t3}, got ${f7}.`);
      if (a3 === o.INDEFINITE) throw new Error("New stream started in typed stream");
    }
    yield e2.value, yield* n2;
  }
};
__publicField(_y, "defaultOptions", { maxDepth: 1024, encoding: "hex", requirePreferred: false });
var y3 = _y;

// node_modules/cbor2/lib/container.js
var v = /* @__PURE__ */ new Map([[o.ZERO, 1], [o.ONE, 2], [o.TWO, 3], [o.FOUR, 5], [o.EIGHT, 9]]);
var A2 = new Uint8Array(0);
function k2(d5, r2) {
  return !r2.boxed && !r2.preferMap && d5.every(([i3]) => typeof i3 == "string") ? Object.fromEntries(d5) : new Map(d5);
}
var _e5, _t4, _w_instances, r_fn;
var _w = class _w {
  constructor(r2, i3, e2, t3) {
    __privateAdd(this, _w_instances);
    __publicField(this, "parent");
    __publicField(this, "mt");
    __publicField(this, "ai");
    __publicField(this, "left");
    __publicField(this, "offset");
    __publicField(this, "count", 0);
    __publicField(this, "children", []);
    __publicField(this, "depth", 0);
    __privateAdd(this, _e5);
    __privateAdd(this, _t4, null);
    if ([this.mt, this.ai, , this.offset] = r2, this.left = i3, this.parent = e2, __privateSet(this, _e5, t3), e2 && (this.depth = e2.depth + 1), this.mt === f2.MAP && (__privateGet(this, _e5).sortKeys || __privateGet(this, _e5).rejectDuplicateKeys) && __privateSet(this, _t4, []), __privateGet(this, _e5).rejectStreaming && this.ai === o.INDEFINITE) throw new Error("Streaming not supported");
  }
  get isStreaming() {
    return this.left === 1 / 0;
  }
  get done() {
    return this.left === 0;
  }
  static create(r2, i3, e2, t3) {
    const [s4, l6, n2, c4] = r2;
    switch (s4) {
      case f2.POS_INT:
      case f2.NEG_INT: {
        if (e2.rejectInts) throw new Error(`Unexpected integer: ${n2}`);
        if (e2.rejectLargeNegatives && n2 < -0x8000000000000000n) throw new Error(`Invalid 65bit negative number: ${n2}`);
        let o5 = n2;
        return e2.convertUnsafeIntsToFloat && o5 >= S.MIN && o5 <= S.MAX && (o5 = Number(n2)), e2.boxed ? d(o5, t3.toHere(c4)) : o5;
      }
      case f2.SIMPLE_FLOAT:
        if (l6 > o.ONE) {
          if (e2.rejectFloats) throw new Error(`Decoding unwanted floating point number: ${n2}`);
          if (e2.rejectNegativeZero && Object.is(n2, -0)) throw new Error("Decoding negative zero");
          if (e2.rejectLongLoundNaN && isNaN(n2)) {
            const o5 = t3.toHere(c4);
            if (o5.length !== 3 || o5[1] !== 126 || o5[2] !== 0) throw new Error(`Invalid NaN encoding: "${A(o5)}"`);
          }
          if (e2.rejectSubnormals && l2(t3.toHere(c4 + 1)), e2.rejectLongFloats) {
            const o5 = Q(n2, { chunkSize: 9, reduceUnsafeNumbers: e2.rejectUnsafeFloatInts });
            if (o5[0] >> 5 !== s4) throw new Error(`Should have been encoded as int, not float: ${n2}`);
            if (o5.length < v.get(l6)) throw new Error(`Number should have been encoded shorter: ${n2}`);
          }
          if (typeof n2 == "number" && e2.boxed) return d(n2, t3.toHere(c4));
        } else {
          if (e2.rejectSimple && n2 instanceof t) throw new Error(`Invalid simple value: ${n2}`);
          if (e2.rejectUndefined && n2 === void 0) throw new Error("Unexpected undefined");
        }
        return n2;
      case f2.BYTE_STRING:
      case f2.UTF8_STRING:
        if (n2 === 1 / 0) return new e2.ParentType(r2, 1 / 0, i3, e2);
        if (e2.rejectStringsNotNormalizedAs && typeof n2 == "string") {
          const o5 = n2.normalize(e2.rejectStringsNotNormalizedAs);
          if (n2 !== o5) throw new Error(`String not normalized as "${e2.rejectStringsNotNormalizedAs}", got [${U(n2)}] instead of [${U(o5)}]`);
        }
        return e2.boxed ? d(n2, t3.toHere(c4)) : n2;
      case f2.ARRAY:
        return new e2.ParentType(r2, n2, i3, e2);
      case f2.MAP:
        return new e2.ParentType(r2, n2 * 2, i3, e2);
      case f2.TAG: {
        const o5 = new e2.ParentType(r2, 1, i3, e2);
        return o5.children = new i(n2), o5;
      }
    }
    throw new TypeError(`Invalid major type: ${s4}`);
  }
  static decodeToEncodeOpts(r2) {
    return { ...k, avoidInts: r2.rejectInts, float64: !r2.rejectLongFloats, flushToZero: r2.rejectSubnormals, largeNegativeAsBigInt: r2.rejectLargeNegatives, sortKeys: r2.sortKeys };
  }
  push(r2, i3, e2) {
    if (this.children.push(r2), __privateGet(this, _t4)) {
      const t3 = f3(r2) || i3.toHere(e2);
      __privateGet(this, _t4).push(t3);
    }
    return --this.left;
  }
  replaceLast(r2, i3, e2) {
    let t3, s4 = -1 / 0;
    if (this.children instanceof i ? (s4 = 0, t3 = this.children.contents, this.children.contents = r2) : (s4 = this.children.length - 1, t3 = this.children[s4], this.children[s4] = r2), __privateGet(this, _t4)) {
      const l6 = f3(r2) || e2.toHere(i3.offset);
      __privateGet(this, _t4)[s4] = l6;
    }
    return t3;
  }
  convert(r2) {
    let i3;
    switch (this.mt) {
      case f2.ARRAY:
        i3 = this.children;
        break;
      case f2.MAP: {
        const e2 = __privateMethod(this, _w_instances, r_fn).call(this);
        if (__privateGet(this, _e5).sortKeys) {
          let t3;
          for (const s4 of e2) {
            if (t3 && __privateGet(this, _e5).sortKeys(t3, s4) >= 0) throw new Error(`Duplicate or out of order key: "0x${s4[2]}"`);
            t3 = s4;
          }
        } else if (__privateGet(this, _e5).rejectDuplicateKeys) {
          const t3 = /* @__PURE__ */ new Set();
          for (const [s4, l6, n2] of e2) {
            const c4 = A(n2);
            if (t3.has(c4)) throw new Error(`Duplicate key: "0x${c4}"`);
            t3.add(c4);
          }
        }
        i3 = __privateGet(this, _e5).createObject(e2, __privateGet(this, _e5));
        break;
      }
      case f2.BYTE_STRING:
        return d2(this.children);
      case f2.UTF8_STRING: {
        const e2 = this.children.join("");
        i3 = __privateGet(this, _e5).boxed ? d(e2, r2.toHere(this.offset)) : e2;
        break;
      }
      case f2.TAG:
        i3 = this.children.decode(__privateGet(this, _e5));
        break;
      default:
        throw new TypeError(`Invalid mt on convert: ${this.mt}`);
    }
    return __privateGet(this, _e5).saveOriginal && i3 && typeof i3 == "object" && u(i3, r2.toHere(this.offset)), i3;
  }
};
_e5 = new WeakMap();
_t4 = new WeakMap();
_w_instances = new WeakSet();
r_fn = function() {
  const r2 = this.children, i3 = r2.length;
  if (i3 % 2) throw new Error("Missing map value");
  const e2 = new Array(i3 / 2);
  if (__privateGet(this, _t4)) for (let t3 = 0; t3 < i3; t3 += 2) e2[t3 >> 1] = [r2[t3], r2[t3 + 1], __privateGet(this, _t4)[t3]];
  else for (let t3 = 0; t3 < i3; t3 += 2) e2[t3 >> 1] = [r2[t3], r2[t3 + 1], A2];
  return e2;
};
__publicField(_w, "defaultDecodeOptions", { ...y3.defaultOptions, ParentType: _w, boxed: false, cde: false, dcbor: false, diagnosticSizes: o3.PREFERRED, convertUnsafeIntsToFloat: false, createObject: k2, pretty: false, preferMap: false, rejectLargeNegatives: false, rejectBigInts: false, rejectDuplicateKeys: false, rejectFloats: false, rejectInts: false, rejectLongLoundNaN: false, rejectLongFloats: false, rejectNegativeZero: false, rejectSimple: false, rejectStreaming: false, rejectStringsNotNormalizedAs: null, rejectSubnormals: false, rejectUndefined: false, rejectUnsafeFloatInts: false, saveOriginal: false, sortKeys: null, tags: null });
__publicField(_w, "cdeDecodeOptions", { cde: true, rejectStreaming: true, requirePreferred: true, sortKeys: f5 });
__publicField(_w, "dcborDecodeOptions", { ..._w.cdeDecodeOptions, dcbor: true, convertUnsafeIntsToFloat: true, rejectDuplicateKeys: true, rejectLargeNegatives: true, rejectLongLoundNaN: true, rejectLongFloats: true, rejectNegativeZero: true, rejectSimple: true, rejectUndefined: true, rejectUnsafeFloatInts: true, rejectStringsNotNormalizedAs: "NFC" });
var w = _w;

// node_modules/cbor2/lib/diagnostic.js
var O = "  ";
var y4 = new TextEncoder();
var g3 = class extends w {
  constructor() {
    super(...arguments);
    __publicField(this, "close", "");
    __publicField(this, "quote", '"');
  }
  get isEmptyStream() {
    return (this.mt === f2.UTF8_STRING || this.mt === f2.BYTE_STRING) && this.count === 0;
  }
};
function a2(m2, l6, n2, p4) {
  let t3 = "";
  if (l6 === o.INDEFINITE) t3 += "_";
  else {
    if (p4.diagnosticSizes === o3.NEVER) return "";
    {
      let r2 = p4.diagnosticSizes === o3.ALWAYS;
      if (!r2) {
        let e2 = o.ZERO;
        if (Object.is(n2, -0)) e2 = o.TWO;
        else if (m2 === f2.POS_INT || m2 === f2.NEG_INT) {
          const T4 = n2 < 0, u2 = typeof n2 == "bigint" ? 1n : 1, o5 = T4 ? -n2 - u2 : n2;
          o5 <= 23 ? e2 = Number(o5) : o5 <= 255 ? e2 = o.ONE : o5 <= 65535 ? e2 = o.TWO : o5 <= 4294967295 ? e2 = o.FOUR : e2 = o.EIGHT;
        } else isFinite(n2) ? Math.fround(n2) === n2 ? s3(n2) == null ? e2 = o.FOUR : e2 = o.TWO : e2 = o.EIGHT : e2 = o.TWO;
        r2 = e2 !== l6;
      }
      r2 && (t3 += "_", l6 < o.ONE ? t3 += "i" : t3 += String(l6 - 24));
    }
  }
  return t3;
}
function M(m2, l6) {
  const n2 = { ...w.defaultDecodeOptions, ...l6, ParentType: g3 }, p4 = new y3(m2, n2);
  let t3, r2, e2 = "";
  for (const T4 of p4) {
    const [u2, o5, i3] = T4;
    switch (t3 && (t3.count > 0 && i3 !== N.BREAK && (t3.mt === f2.MAP && t3.count % 2 ? e2 += ": " : (e2 += ",", n2.pretty || (e2 += " "))), n2.pretty && (t3.mt !== f2.MAP || t3.count % 2 === 0) && (e2 += `
${O.repeat(t3.depth + 1)}`)), r2 = w.create(T4, t3, n2, p4), u2) {
      case f2.POS_INT:
      case f2.NEG_INT:
        e2 += String(i3), e2 += a2(u2, o5, i3, n2);
        break;
      case f2.SIMPLE_FLOAT:
        if (i3 !== N.BREAK) if (typeof i3 == "number") {
          const c4 = Object.is(i3, -0) ? "-0.0" : String(i3);
          e2 += c4, isFinite(i3) && !/[.e]/.test(c4) && (e2 += ".0"), e2 += a2(u2, o5, i3, n2);
        } else i3 instanceof t ? (e2 += "simple(", e2 += String(i3.value), e2 += a2(f2.POS_INT, o5, i3.value, n2), e2 += ")") : e2 += String(i3);
        break;
      case f2.BYTE_STRING:
        i3 === 1 / 0 ? (e2 += "(_ ", r2.close = ")", r2.quote = "'") : (e2 += "h'", e2 += A(i3), e2 += "'", e2 += a2(f2.POS_INT, o5, i3.length, n2));
        break;
      case f2.UTF8_STRING:
        i3 === 1 / 0 ? (e2 += "(_ ", r2.close = ")") : (e2 += JSON.stringify(i3), e2 += a2(f2.POS_INT, o5, y4.encode(i3).length, n2));
        break;
      case f2.ARRAY: {
        e2 += "[";
        const c4 = a2(f2.POS_INT, o5, i3, n2);
        e2 += c4, c4 && (e2 += " "), n2.pretty && i3 ? r2.close = `
${O.repeat(r2.depth)}]` : r2.close = "]";
        break;
      }
      case f2.MAP: {
        e2 += "{";
        const c4 = a2(f2.POS_INT, o5, i3, n2);
        e2 += c4, c4 && (e2 += " "), n2.pretty && i3 ? r2.close = `
${O.repeat(r2.depth)}}` : r2.close = "}";
        break;
      }
      case f2.TAG:
        e2 += String(i3), e2 += a2(f2.POS_INT, o5, i3, n2), e2 += "(", r2.close = ")";
        break;
    }
    if (r2 === N.BREAK) if (t3 == null ? void 0 : t3.isStreaming) t3.left = 0;
    else throw new Error("Unexpected BREAK");
    else t3 && (t3.count++, t3.left--);
    for (r2 instanceof g3 && (t3 = r2); t3 == null ? void 0 : t3.done; ) {
      if (t3.isEmptyStream) e2 = e2.slice(0, -3), e2 += `${t3.quote}${t3.quote}_`;
      else {
        if (t3.mt === f2.MAP && t3.count % 2 !== 0) throw new Error(`Odd streaming map size: ${t3.count}`);
        e2 += t3.close;
      }
      t3 = t3.parent;
    }
  }
  return e2;
}

// node_modules/cbor2/lib/comment.js
var H2 = new TextDecoder();
var _a3, _b;
var A3 = class extends (_b = w, _a3 = N.ENCODED, _b) {
  constructor(a3, f7, e2, n2) {
    super(a3, f7, e2, n2);
    __publicField(this, "depth", 0);
    __publicField(this, "leaf", false);
    __publicField(this, "value");
    __publicField(this, "length");
    __publicField(this, _a3);
    this.parent ? this.depth = this.parent.depth + 1 : this.depth = n2.initialDepth, [, , this.value, , this.length] = a3;
  }
  numBytes() {
    switch (this.ai) {
      case o.ONE:
        return 1;
      case o.TWO:
        return 2;
      case o.FOUR:
        return 4;
      case o.EIGHT:
        return 8;
    }
    return 0;
  }
};
function k3(t3) {
  return t3 instanceof A3;
}
function O2(t3, a3) {
  return t3 === 1 / 0 ? "Indefinite" : a3 ? `${t3} ${a3}${t3 !== 1 && t3 !== 1n ? "s" : ""}` : String(t3);
}
function y5(t3) {
  return "".padStart(t3, " ");
}
function x2(t3, a3, f7) {
  let e2 = "";
  e2 += y5(t3.depth * 2);
  const n2 = f3(t3);
  e2 += A(n2.subarray(0, 1));
  const r2 = t3.numBytes();
  r2 && (e2 += " ", e2 += A(n2.subarray(1, r2 + 1))), e2 = e2.padEnd(a3.minCol + 1, " "), e2 += "-- ", f7 !== void 0 && (e2 += y5(t3.depth * 2), f7 !== "" && (e2 += `[${f7}] `));
  let p4 = false;
  const [s4] = t3.children;
  switch (t3.mt) {
    case f2.POS_INT:
      e2 += `Unsigned: ${s4}`, typeof s4 == "bigint" && (e2 += "n");
      break;
    case f2.NEG_INT:
      e2 += `Negative: ${s4}`, typeof s4 == "bigint" && (e2 += "n");
      break;
    case f2.BYTE_STRING:
      e2 += `Bytes (Length: ${O2(t3.length)})`;
      break;
    case f2.UTF8_STRING:
      e2 += `UTF8 (Length: ${O2(t3.length)})`, t3.length !== 1 / 0 && (e2 += `: ${JSON.stringify(s4)}`);
      break;
    case f2.ARRAY:
      e2 += `Array (Length: ${O2(t3.value, "item")})`;
      break;
    case f2.MAP:
      e2 += `Map (Length: ${O2(t3.value, "pair")})`;
      break;
    case f2.TAG: {
      e2 += `Tag #${t3.value}`;
      const o5 = t3.children, [m2] = o5.contents.children, i3 = new i(o5.tag, m2);
      u(i3, n2);
      const l6 = i3.comment(a3, t3.depth);
      l6 && (e2 += ": ", e2 += l6), p4 || (p4 = i3.noChildren);
      break;
    }
    case f2.SIMPLE_FLOAT:
      s4 === N.BREAK ? e2 += "BREAK" : t3.ai > o.ONE ? Object.is(s4, -0) ? e2 += "Float: -0" : e2 += `Float: ${s4}` : (e2 += "Simple: ", s4 instanceof t ? e2 += s4.value : e2 += s4);
      break;
  }
  if (!p4) if (t3.leaf) {
    if (e2 += `
`, n2.length > r2 + 1) {
      const o5 = y5((t3.depth + 1) * 2), m2 = f4(n2);
      if (m2 == null ? void 0 : m2.length) {
        m2.sort((l6, c4) => {
          const g4 = l6[0] - c4[0];
          return g4 || c4[1] - l6[1];
        });
        let i3 = 0;
        for (const [l6, c4, g4] of m2) if (!(l6 < i3)) {
          if (i3 = l6 + c4, g4 === "<<") {
            e2 += y5(a3.minCol + 1), e2 += "--", e2 += o5, e2 += "<< ";
            const d5 = R(n2, l6, l6 + c4), h4 = f4(d5);
            if (h4) {
              const $3 = h4.findIndex(([w3, D2, v2]) => w3 === 0 && D2 === c4 && v2 === "<<");
              $3 >= 0 && h4.splice($3, 1);
            }
            e2 += M(d5), e2 += ` >>
`, e2 += L(d5, { initialDepth: t3.depth + 1, minCol: a3.minCol, noPrefixHex: true });
            continue;
          } else g4 === "'" && (e2 += y5(a3.minCol + 1), e2 += "--", e2 += o5, e2 += "'", e2 += H2.decode(n2.subarray(l6, l6 + c4)), e2 += `'
`);
          if (l6 > r2) for (let d5 = l6; d5 < l6 + c4; d5 += 8) {
            const h4 = Math.min(d5 + 8, l6 + c4);
            e2 += o5, e2 += A(n2.subarray(d5, h4)), e2 += `
`;
          }
        }
      } else for (let i3 = r2 + 1; i3 < n2.length; i3 += 8) e2 += o5, e2 += A(n2.subarray(i3, i3 + 8)), e2 += `
`;
    }
  } else {
    e2 += `
`;
    let o5 = 0;
    for (const m2 of t3.children) {
      if (k3(m2)) {
        let i3 = String(o5);
        t3.mt === f2.MAP ? i3 = o5 % 2 ? `val ${(o5 - 1) / 2}` : `key ${o5 / 2}` : t3.mt === f2.TAG && (i3 = ""), e2 += x2(m2, a3, i3);
      }
      o5++;
    }
  }
  return e2;
}
var q2 = { ...w.defaultDecodeOptions, initialDepth: 0, noPrefixHex: false, minCol: 0 };
function L(t3, a3) {
  const f7 = { ...q2, ...a3, ParentType: A3, saveOriginal: true }, e2 = new y3(t3, f7);
  let n2, r2;
  for (const s4 of e2) {
    if (r2 = w.create(s4, n2, f7, e2), s4[2] === N.BREAK) if (n2 == null ? void 0 : n2.isStreaming) n2.left = 1;
    else throw new Error("Unexpected BREAK");
    if (!k3(r2)) {
      const i3 = new A3(s4, 0, n2, f7);
      i3.leaf = true, i3.children.push(r2), u(i3, e2.toHere(s4[3])), r2 = i3;
    }
    let o5 = (r2.depth + 1) * 2;
    const m2 = r2.numBytes();
    for (m2 && (o5 += 1, o5 += m2 * 2), f7.minCol = Math.max(f7.minCol, o5), n2 && n2.push(r2, e2, s4[3]), n2 = r2; n2 == null ? void 0 : n2.done; ) r2 = n2, r2.leaf || u(r2, e2.toHere(r2.offset)), { parent: n2 } = n2;
  }
  a3 && (a3.minCol = f7.minCol);
  let p4 = f7.noPrefixHex ? "" : `0x${A(e2.toHere(0))}
`;
  return p4 += x2(r2, f7), p4;
}

// node_modules/cbor2/lib/types.js
var S2 = !h();
function O3(e2) {
  if (typeof e2 == "object" && e2) {
    if (e2.constructor !== Number) throw new Error(`Expected number: ${e2}`);
  } else if (typeof e2 != "number") throw new Error(`Expected number: ${e2}`);
}
function E(e2) {
  if (typeof e2 == "object" && e2) {
    if (e2.constructor !== String) throw new Error(`Expected string: ${e2}`);
  } else if (typeof e2 != "string") throw new Error(`Expected string: ${e2}`);
}
function f6(e2) {
  if (!(e2 instanceof Uint8Array)) throw new Error(`Expected Uint8Array: ${e2}`);
}
function U3(e2) {
  if (!Array.isArray(e2)) throw new Error(`Expected Array: ${e2}`);
}
ce(Map, (e2, r2, n2) => {
  const t3 = [...e2.entries()].map((o5) => [o5[0], o5[1], Q(o5[0], n2)]);
  if (n2.rejectDuplicateKeys) {
    const o5 = /* @__PURE__ */ new Set();
    for (const [d5, u2, y6] of t3) {
      const g4 = A(y6);
      if (o5.has(g4)) throw new Error(`Duplicate map key: 0x${g4}`);
      o5.add(g4);
    }
  }
  n2.sortKeys && t3.sort(n2.sortKeys), R2(e2, e2.size, f2.MAP, r2, n2);
  for (const [o5, d5, u2] of t3) r2.write(u2), g2(d5, r2, n2);
});
function h3(e2) {
  return E(e2.contents), new Date(e2.contents);
}
h3.comment = (e2) => (E(e2.contents), `(String Date) ${new Date(e2.contents).toISOString()}`), i.registerDecoder(I.DATE_STRING, h3);
function N3(e2) {
  return O3(e2.contents), new Date(e2.contents * 1e3);
}
N3.comment = (e2) => (O3(e2.contents), `(Epoch Date) ${new Date(e2.contents * 1e3).toISOString()}`), i.registerDecoder(I.DATE_EPOCH, N3), ce(Date, (e2) => [I.DATE_EPOCH, e2.valueOf() / 1e3]);
function T3(e2, r2, n2) {
  if (f6(r2.contents), n2.rejectBigInts) throw new Error(`Decoding unwanted big integer: ${r2}(h'${A(r2.contents)}')`);
  if (n2.requirePreferred && r2.contents[0] === 0) throw new Error(`Decoding overly-large bigint: ${r2.tag}(h'${A(r2.contents)})`);
  let t3 = r2.contents.reduce((o5, d5) => o5 << 8n | BigInt(d5), 0n);
  if (e2 && (t3 = -1n - t3), n2.requirePreferred && t3 >= Number.MIN_SAFE_INTEGER && t3 <= Number.MAX_SAFE_INTEGER) throw new Error(`Decoding bigint that could have been int: ${t3}n`);
  return n2.boxed ? d(t3, r2.contents) : t3;
}
var _ = T3.bind(null, false);
var $2 = T3.bind(null, true);
_.comment = (e2, r2) => `(Positive BigInt) ${T3(false, e2, r2)}n`, $2.comment = (e2, r2) => `(Negative BigInt) ${T3(true, e2, r2)}n`, i.registerDecoder(I.POS_BIGINT, _), i.registerDecoder(I.NEG_BIGINT, $2);
function D(e2, r2) {
  return f6(e2.contents), e2;
}
D.comment = (e2, r2, n2) => {
  f6(e2.contents);
  const t3 = { ...r2, initialDepth: n2 + 2, noPrefixHex: true }, o5 = f3(e2);
  let u2 = 2 ** ((o5[0] & 31) - 24) + 1;
  const y6 = o5[u2] & 31;
  let g4 = A(o5.subarray(u2, ++u2));
  y6 >= 24 && (g4 += " ", g4 += A(o5.subarray(u2, u2 + 2 ** (y6 - 24)))), t3.minCol = Math.max(t3.minCol, (n2 + 1) * 2 + g4.length);
  const p4 = L(e2.contents, t3);
  let I2 = `Embedded CBOR
`;
  return I2 += `${"".padStart((n2 + 1) * 2, " ")}${g4}`.padEnd(t3.minCol + 1, " "), I2 += `-- Bytes (Length: ${e2.contents.length})
`, I2 += p4, I2;
}, D.noChildren = true, i.registerDecoder(I.CBOR, D), i.registerDecoder(I.URI, (e2) => (E(e2.contents), new URL(e2.contents)), "URI"), ce(URL, (e2) => [I.URI, e2.toString()]), i.registerDecoder(I.BASE64URL, (e2) => (E(e2.contents), x(e2.contents)), "Base64url-encoded"), i.registerDecoder(I.BASE64, (e2) => (E(e2.contents), y(e2.contents)), "Base64-encoded"), i.registerDecoder(35, (e2) => (E(e2.contents), new RegExp(e2.contents)), "RegExp"), i.registerDecoder(21065, (e2) => {
  E(e2.contents);
  const r2 = `^(?:${e2.contents})$`;
  return new RegExp(r2, "u");
}, "I-RegExp"), i.registerDecoder(I.REGEXP, (e2) => {
  if (U3(e2.contents), e2.contents.length < 1 || e2.contents.length > 2) throw new Error(`Invalid RegExp Array: ${e2.contents}`);
  return new RegExp(e2.contents[0], e2.contents[1]);
}, "RegExp"), ce(RegExp, (e2) => [I.REGEXP, [e2.source, e2.flags]]), i.registerDecoder(64, (e2) => (f6(e2.contents), e2.contents), "uint8 Typed Array");
function c2(e2, r2, n2) {
  f6(e2.contents);
  let t3 = e2.contents.length;
  if (t3 % r2.BYTES_PER_ELEMENT !== 0) throw new Error(`Number of bytes must be divisible by ${r2.BYTES_PER_ELEMENT}, got: ${t3}`);
  t3 /= r2.BYTES_PER_ELEMENT;
  const o5 = new r2(t3), d5 = new DataView(e2.contents.buffer, e2.contents.byteOffset, e2.contents.byteLength), u2 = d5[`get${r2.name.replace(/Array/, "")}`].bind(d5);
  for (let y6 = 0; y6 < t3; y6++) o5[y6] = u2(y6 * r2.BYTES_PER_ELEMENT, n2);
  return o5;
}
function l3(e2, r2, n2, t3, o5) {
  const d5 = o5.forceEndian ?? S2;
  if (p2(d5 ? r2 : n2, e2, o5), a(t3.byteLength, e2, f2.BYTE_STRING), S2 === d5) e2.write(new Uint8Array(t3.buffer, t3.byteOffset, t3.byteLength));
  else {
    const y6 = `write${t3.constructor.name.replace(/Array/, "")}`, g4 = e2[y6].bind(e2);
    for (const p4 of t3) g4(p4, d5);
  }
}
i.registerDecoder(65, (e2) => c2(e2, Uint16Array, false), "uint16, big endian, Typed Array"), i.registerDecoder(66, (e2) => c2(e2, Uint32Array, false), "uint32, big endian, Typed Array"), i.registerDecoder(67, (e2) => c2(e2, BigUint64Array, false), "uint64, big endian, Typed Array"), i.registerDecoder(68, (e2) => (f6(e2.contents), new Uint8ClampedArray(e2.contents)), "uint8 Typed Array, clamped arithmetic"), ce(Uint8ClampedArray, (e2) => [68, new Uint8Array(e2.buffer, e2.byteOffset, e2.byteLength)]), i.registerDecoder(69, (e2) => c2(e2, Uint16Array, true), "uint16, little endian, Typed Array"), ce(Uint16Array, (e2, r2, n2) => l3(r2, 69, 65, e2, n2)), i.registerDecoder(70, (e2) => c2(e2, Uint32Array, true), "uint32, little endian, Typed Array"), ce(Uint32Array, (e2, r2, n2) => l3(r2, 70, 66, e2, n2)), i.registerDecoder(71, (e2) => c2(e2, BigUint64Array, true), "uint64, little endian, Typed Array"), ce(BigUint64Array, (e2, r2, n2) => l3(r2, 71, 67, e2, n2)), i.registerDecoder(72, (e2) => (f6(e2.contents), new Int8Array(e2.contents)), "sint8 Typed Array"), ce(Int8Array, (e2) => [72, new Uint8Array(e2.buffer, e2.byteOffset, e2.byteLength)]), i.registerDecoder(73, (e2) => c2(e2, Int16Array, false), "sint16, big endian, Typed Array"), i.registerDecoder(74, (e2) => c2(e2, Int32Array, false), "sint32, big endian, Typed Array"), i.registerDecoder(75, (e2) => c2(e2, BigInt64Array, false), "sint64, big endian, Typed Array"), i.registerDecoder(77, (e2) => c2(e2, Int16Array, true), "sint16, little endian, Typed Array"), ce(Int16Array, (e2, r2, n2) => l3(r2, 77, 73, e2, n2)), i.registerDecoder(78, (e2) => c2(e2, Int32Array, true), "sint32, little endian, Typed Array"), ce(Int32Array, (e2, r2, n2) => l3(r2, 78, 74, e2, n2)), i.registerDecoder(79, (e2) => c2(e2, BigInt64Array, true), "sint64, little endian, Typed Array"), ce(BigInt64Array, (e2, r2, n2) => l3(r2, 79, 75, e2, n2)), i.registerDecoder(81, (e2) => c2(e2, Float32Array, false), "IEEE 754 binary32, big endian, Typed Array"), i.registerDecoder(82, (e2) => c2(e2, Float64Array, false), "IEEE 754 binary64, big endian, Typed Array"), i.registerDecoder(85, (e2) => c2(e2, Float32Array, true), "IEEE 754 binary32, little endian, Typed Array"), ce(Float32Array, (e2, r2, n2) => l3(r2, 85, 81, e2, n2)), i.registerDecoder(86, (e2) => c2(e2, Float64Array, true), "IEEE 754 binary64, big endian, Typed Array"), ce(Float64Array, (e2, r2, n2) => l3(r2, 86, 82, e2, n2)), i.registerDecoder(I.SET, (e2, r2) => {
  if (U3(e2.contents), r2.sortKeys) {
    const n2 = w.decodeToEncodeOpts(r2);
    let t3 = null;
    for (const o5 of e2.contents) {
      const d5 = [o5, void 0, Q(o5, n2)];
      if (t3 && r2.sortKeys(t3, d5) >= 0) throw new Error(`Set items out of order in tag #${I.SET}`);
      t3 = d5;
    }
  }
  return new Set(e2.contents);
}, "Set"), ce(Set, (e2, r2, n2) => {
  let t3 = [...e2];
  if (n2.sortKeys) {
    const o5 = t3.map((d5) => [d5, void 0, Q(d5, n2)]);
    o5.sort(n2.sortKeys), t3 = o5.map(([d5]) => d5);
  }
  return [I.SET, t3];
}), i.registerDecoder(I.JSON, (e2) => (E(e2.contents), JSON.parse(e2.contents)), "JSON-encoded");
function x3(e2) {
  return f6(e2.contents), new Wtf8Decoder().decode(e2.contents);
}
x3.comment = (e2) => {
  f6(e2.contents);
  const r2 = new Wtf8Decoder();
  return `(WTF8 string): ${JSON.stringify(r2.decode(e2.contents))}`;
}, i.registerDecoder(I.WTF8, x3), i.registerDecoder(I.SELF_DESCRIBED, (e2) => e2.contents, "Self-Described"), i.registerDecoder(I.INVALID_16, () => {
  throw new Error(`Tag always invalid: ${I.INVALID_16}`);
}, "Invalid"), i.registerDecoder(I.INVALID_32, () => {
  throw new Error(`Tag always invalid: ${I.INVALID_32}`);
}, "Invalid"), i.registerDecoder(I.INVALID_64, () => {
  throw new Error(`Tag always invalid: ${I.INVALID_64}`);
}, "Invalid");
function w2(e2) {
  throw new Error(`Encoding ${e2.constructor.name} intentionally unimplmented.  It is not concrete enough to interoperate.  Convert to Uint8Array first.`);
}
ce(ArrayBuffer, w2), ce(DataView, w2), typeof SharedArrayBuffer < "u" && ce(SharedArrayBuffer, w2);
function m(e2) {
  return [NaN, e2.valueOf()];
}
ce(Boolean, m), ce(Number, m), ce(String, m), ce(BigInt, m);

// node_modules/cbor2/lib/decoder.js
function c3(i3) {
  const e2 = { ...w.defaultDecodeOptions };
  if (i3.dcbor ? Object.assign(e2, w.dcborDecodeOptions) : i3.cde && Object.assign(e2, w.cdeDecodeOptions), Object.assign(e2, i3), Object.hasOwn(e2, "rejectLongNumbers")) throw new TypeError("rejectLongNumbers has changed to requirePreferred");
  return e2.boxed && (e2.saveOriginal = true), e2;
}
var d3 = class {
  constructor() {
    __publicField(this, "parent");
    __publicField(this, "ret");
  }
  step(e2, n2, t3) {
    var _a4, _b2;
    if (this.ret = w.create(e2, this.parent, n2, t3), e2[2] === N.BREAK) if ((_a4 = this.parent) == null ? void 0 : _a4.isStreaming) this.parent.left = 0;
    else throw new Error("Unexpected BREAK");
    else this.parent && this.parent.push(this.ret, t3, e2[3]);
    for (this.ret instanceof w && (this.parent = this.ret); (_b2 = this.parent) == null ? void 0 : _b2.done; ) {
      this.ret = this.parent.convert(t3);
      const r2 = this.parent.parent;
      r2 == null ? void 0 : r2.replaceLast(this.ret, this.parent, t3), this.parent = r2;
    }
  }
};
function l4(i3, e2 = {}) {
  const n2 = c3(e2), t3 = new y3(i3, n2), r2 = new d3();
  for (const o5 of t3) r2.step(o5, n2, t3);
  return r2.ret;
}

// node_modules/cbor2/lib/index.js
var { cdeDecodeOptions: r, dcborDecodeOptions: n, defaultDecodeOptions: d4 } = w;

// node_modules/iobuffer/lib/text.js
function decode(bytes, encoding = "utf8") {
  const decoder = new TextDecoder(encoding);
  return decoder.decode(bytes);
}
var encoder = new TextEncoder();
function encode(str) {
  return encoder.encode(str);
}

// node_modules/iobuffer/lib/iobuffer.js
var defaultByteLength = 1024 * 8;
var hostBigEndian = (() => {
  const array = new Uint8Array(4);
  const view = new Uint32Array(array.buffer);
  return !((view[0] = 1) & array[0]);
})();
var typedArrays = {
  int8: globalThis.Int8Array,
  uint8: globalThis.Uint8Array,
  int16: globalThis.Int16Array,
  uint16: globalThis.Uint16Array,
  int32: globalThis.Int32Array,
  uint32: globalThis.Uint32Array,
  uint64: globalThis.BigUint64Array,
  int64: globalThis.BigInt64Array,
  float32: globalThis.Float32Array,
  float64: globalThis.Float64Array
};
var IOBuffer = class _IOBuffer {
  /**
   * Create a new IOBuffer.
   * @param data - The data to construct the IOBuffer with.
   * If data is a number, it will be the new buffer's length<br>
   * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>
   * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,
   * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.
   * @param options - An object for the options.
   * @returns A new IOBuffer instance.
   */
  constructor(data = defaultByteLength, options = {}) {
    /**
     * Reference to the internal ArrayBuffer object.
     */
    __publicField(this, "buffer");
    /**
     * Byte length of the internal ArrayBuffer.
     */
    __publicField(this, "byteLength");
    /**
     * Byte offset of the internal ArrayBuffer.
     */
    __publicField(this, "byteOffset");
    /**
     * Byte length of the internal ArrayBuffer.
     */
    __publicField(this, "length");
    /**
     * The current offset of the buffer's pointer.
     */
    __publicField(this, "offset");
    __publicField(this, "lastWrittenByte");
    __publicField(this, "littleEndian");
    __publicField(this, "_data");
    __publicField(this, "_mark");
    __publicField(this, "_marks");
    let dataIsGiven = false;
    if (typeof data === "number") {
      data = new ArrayBuffer(data);
    } else {
      dataIsGiven = true;
      this.lastWrittenByte = data.byteLength;
    }
    const offset = options.offset ? options.offset >>> 0 : 0;
    const byteLength = data.byteLength - offset;
    let dvOffset = offset;
    if (ArrayBuffer.isView(data) || data instanceof _IOBuffer) {
      if (data.byteLength !== data.buffer.byteLength) {
        dvOffset = data.byteOffset + offset;
      }
      data = data.buffer;
    }
    if (dataIsGiven) {
      this.lastWrittenByte = byteLength;
    } else {
      this.lastWrittenByte = 0;
    }
    this.buffer = data;
    this.length = byteLength;
    this.byteLength = byteLength;
    this.byteOffset = dvOffset;
    this.offset = 0;
    this.littleEndian = true;
    this._data = new DataView(this.buffer, dvOffset, byteLength);
    this._mark = 0;
    this._marks = [];
  }
  /**
   * Checks if the memory allocated to the buffer is sufficient to store more
   * bytes after the offset.
   * @param byteLength - The needed memory in bytes.
   * @returns `true` if there is sufficient space and `false` otherwise.
   */
  available(byteLength = 1) {
    return this.offset + byteLength <= this.length;
  }
  /**
   * Check if little-endian mode is used for reading and writing multi-byte
   * values.
   * @returns `true` if little-endian mode is used, `false` otherwise.
   */
  isLittleEndian() {
    return this.littleEndian;
  }
  /**
   * Set little-endian mode for reading and writing multi-byte values.
   * @returns This.
   */
  setLittleEndian() {
    this.littleEndian = true;
    return this;
  }
  /**
   * Check if big-endian mode is used for reading and writing multi-byte values.
   * @returns `true` if big-endian mode is used, `false` otherwise.
   */
  isBigEndian() {
    return !this.littleEndian;
  }
  /**
   * Switches to big-endian mode for reading and writing multi-byte values.
   * @returns This.
   */
  setBigEndian() {
    this.littleEndian = false;
    return this;
  }
  /**
   * Move the pointer n bytes forward.
   * @param n - Number of bytes to skip.
   * @returns This.
   */
  skip(n2 = 1) {
    this.offset += n2;
    return this;
  }
  /**
   * Move the pointer n bytes backward.
   * @param n - Number of bytes to move back.
   * @returns This.
   */
  back(n2 = 1) {
    this.offset -= n2;
    return this;
  }
  /**
   * Move the pointer to the given offset.
   * @param offset - The offset to move to.
   * @returns This.
   */
  seek(offset) {
    this.offset = offset;
    return this;
  }
  /**
   * Store the current pointer offset.
   * @see {@link IOBuffer#reset}
   * @returns This.
   */
  mark() {
    this._mark = this.offset;
    return this;
  }
  /**
   * Move the pointer back to the last pointer offset set by mark.
   * @see {@link IOBuffer#mark}
   * @returns This.
   */
  reset() {
    this.offset = this._mark;
    return this;
  }
  /**
   * Push the current pointer offset to the mark stack.
   * @see {@link IOBuffer#popMark}
   * @returns This.
   */
  pushMark() {
    this._marks.push(this.offset);
    return this;
  }
  /**
   * Pop the last pointer offset from the mark stack, and set the current
   * pointer offset to the popped value.
   * @see {@link IOBuffer#pushMark}
   * @returns This.
   */
  popMark() {
    const offset = this._marks.pop();
    if (offset === void 0) {
      throw new Error("Mark stack empty");
    }
    this.seek(offset);
    return this;
  }
  /**
   * Move the pointer offset back to 0.
   * @returns This.
   */
  rewind() {
    this.offset = 0;
    return this;
  }
  /**
   * Make sure the buffer has sufficient memory to write a given byteLength at
   * the current pointer offset.
   * If the buffer's memory is insufficient, this method will create a new
   * buffer (a copy) with a length that is twice (byteLength + current offset).
   * @param byteLength - The needed memory in bytes.
   * @returns This.
   */
  ensureAvailable(byteLength = 1) {
    if (!this.available(byteLength)) {
      const lengthNeeded = this.offset + byteLength;
      const newLength = lengthNeeded * 2;
      const newArray = new Uint8Array(newLength);
      newArray.set(new Uint8Array(this.buffer));
      this.buffer = newArray.buffer;
      this.length = newLength;
      this.byteLength = newLength;
      this._data = new DataView(this.buffer);
    }
    return this;
  }
  /**
   * Read a byte and return false if the byte's value is 0, or true otherwise.
   * Moves pointer forward by one byte.
   * @returns The read boolean.
   */
  readBoolean() {
    return this.readUint8() !== 0;
  }
  /**
   * Read a signed 8-bit integer and move pointer forward by 1 byte.
   * @returns The read byte.
   */
  readInt8() {
    return this._data.getInt8(this.offset++);
  }
  /**
   * Read an unsigned 8-bit integer and move pointer forward by 1 byte.
   * @returns The read byte.
   */
  readUint8() {
    return this._data.getUint8(this.offset++);
  }
  /**
   * Alias for {@link IOBuffer#readUint8}.
   * @returns The read byte.
   */
  readByte() {
    return this.readUint8();
  }
  /**
   * Read `n` bytes and move pointer forward by `n` bytes.
   * @param n - Number of bytes to read.
   * @returns The read bytes.
   */
  readBytes(n2 = 1) {
    return this.readArray(n2, "uint8");
  }
  /**
   * Creates an array of corresponding to the type `type` and size `size`.
   * For example, type `uint8` will create a `Uint8Array`.
   * @param size - size of the resulting array
   * @param type - number type of elements to read
   * @returns The read array.
   */
  readArray(size, type) {
    const bytes = typedArrays[type].BYTES_PER_ELEMENT * size;
    const offset = this.byteOffset + this.offset;
    const slice = this.buffer.slice(offset, offset + bytes);
    if (this.littleEndian === hostBigEndian && type !== "uint8" && type !== "int8") {
      const slice2 = new Uint8Array(this.buffer.slice(offset, offset + bytes));
      slice2.reverse();
      const returnArray2 = new typedArrays[type](slice2.buffer);
      this.offset += bytes;
      returnArray2.reverse();
      return returnArray2;
    }
    const returnArray = new typedArrays[type](slice);
    this.offset += bytes;
    return returnArray;
  }
  /**
   * Read a 16-bit signed integer and move pointer forward by 2 bytes.
   * @returns The read value.
   */
  readInt16() {
    const value = this._data.getInt16(this.offset, this.littleEndian);
    this.offset += 2;
    return value;
  }
  /**
   * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.
   * @returns The read value.
   */
  readUint16() {
    const value = this._data.getUint16(this.offset, this.littleEndian);
    this.offset += 2;
    return value;
  }
  /**
   * Read a 32-bit signed integer and move pointer forward by 4 bytes.
   * @returns The read value.
   */
  readInt32() {
    const value = this._data.getInt32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  /**
   * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.
   * @returns The read value.
   */
  readUint32() {
    const value = this._data.getUint32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  /**
   * Read a 32-bit floating number and move pointer forward by 4 bytes.
   * @returns The read value.
   */
  readFloat32() {
    const value = this._data.getFloat32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  /**
   * Read a 64-bit floating number and move pointer forward by 8 bytes.
   * @returns The read value.
   */
  readFloat64() {
    const value = this._data.getFloat64(this.offset, this.littleEndian);
    this.offset += 8;
    return value;
  }
  /**
   * Read a 64-bit signed integer number and move pointer forward by 8 bytes.
   * @returns The read value.
   */
  readBigInt64() {
    const value = this._data.getBigInt64(this.offset, this.littleEndian);
    this.offset += 8;
    return value;
  }
  /**
   * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.
   * @returns The read value.
   */
  readBigUint64() {
    const value = this._data.getBigUint64(this.offset, this.littleEndian);
    this.offset += 8;
    return value;
  }
  /**
   * Read a 1-byte ASCII character and move pointer forward by 1 byte.
   * @returns The read character.
   */
  readChar() {
    return String.fromCharCode(this.readInt8());
  }
  /**
   * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.
   * @param n - Number of characters to read.
   * @returns The read characters.
   */
  readChars(n2 = 1) {
    let result = "";
    for (let i3 = 0; i3 < n2; i3++) {
      result += this.readChar();
    }
    return result;
  }
  /**
   * Read the next `n` bytes, return a UTF-8 decoded string and move pointer
   * forward by `n` bytes.
   * @param n - Number of bytes to read.
   * @returns The decoded string.
   */
  readUtf8(n2 = 1) {
    return decode(this.readBytes(n2));
  }
  /**
   * Read the next `n` bytes, return a string decoded with `encoding` and move pointer
   * forward by `n` bytes.
   * If no encoding is passed, the function is equivalent to @see {@link IOBuffer#readUtf8}
   * @param n - Number of bytes to read.
   * @param encoding - The encoding to use. Default is 'utf8'.
   * @returns The decoded string.
   */
  decodeText(n2 = 1, encoding = "utf8") {
    return decode(this.readBytes(n2), encoding);
  }
  /**
   * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer
   * forward by 1 byte.
   * @param value - The value to write.
   * @returns This.
   */
  writeBoolean(value) {
    this.writeUint8(value ? 255 : 0);
    return this;
  }
  /**
   * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.
   * @param value - The value to write.
   * @returns This.
   */
  writeInt8(value) {
    this.ensureAvailable(1);
    this._data.setInt8(this.offset++, value);
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write `value` as an 8-bit unsigned integer and move pointer forward by 1
   * byte.
   * @param value - The value to write.
   * @returns This.
   */
  writeUint8(value) {
    this.ensureAvailable(1);
    this._data.setUint8(this.offset++, value);
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * An alias for {@link IOBuffer#writeUint8}.
   * @param value - The value to write.
   * @returns This.
   */
  writeByte(value) {
    return this.writeUint8(value);
  }
  /**
   * Write all elements of `bytes` as uint8 values and move pointer forward by
   * `bytes.length` bytes.
   * @param bytes - The array of bytes to write.
   * @returns This.
   */
  writeBytes(bytes) {
    this.ensureAvailable(bytes.length);
    for (let i3 = 0; i3 < bytes.length; i3++) {
      this._data.setUint8(this.offset++, bytes[i3]);
    }
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write `value` as a 16-bit signed integer and move pointer forward by 2
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeInt16(value) {
    this.ensureAvailable(2);
    this._data.setInt16(this.offset, value, this.littleEndian);
    this.offset += 2;
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write `value` as a 16-bit unsigned integer and move pointer forward by 2
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeUint16(value) {
    this.ensureAvailable(2);
    this._data.setUint16(this.offset, value, this.littleEndian);
    this.offset += 2;
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write `value` as a 32-bit signed integer and move pointer forward by 4
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeInt32(value) {
    this.ensureAvailable(4);
    this._data.setInt32(this.offset, value, this.littleEndian);
    this.offset += 4;
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write `value` as a 32-bit unsigned integer and move pointer forward by 4
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeUint32(value) {
    this.ensureAvailable(4);
    this._data.setUint32(this.offset, value, this.littleEndian);
    this.offset += 4;
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write `value` as a 32-bit floating number and move pointer forward by 4
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeFloat32(value) {
    this.ensureAvailable(4);
    this._data.setFloat32(this.offset, value, this.littleEndian);
    this.offset += 4;
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write `value` as a 64-bit floating number and move pointer forward by 8
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeFloat64(value) {
    this.ensureAvailable(8);
    this._data.setFloat64(this.offset, value, this.littleEndian);
    this.offset += 8;
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write `value` as a 64-bit signed bigint and move pointer forward by 8
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeBigInt64(value) {
    this.ensureAvailable(8);
    this._data.setBigInt64(this.offset, value, this.littleEndian);
    this.offset += 8;
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeBigUint64(value) {
    this.ensureAvailable(8);
    this._data.setBigUint64(this.offset, value, this.littleEndian);
    this.offset += 8;
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write the charCode of `str`'s first character as an 8-bit unsigned integer
   * and move pointer forward by 1 byte.
   * @param str - The character to write.
   * @returns This.
   */
  writeChar(str) {
    return this.writeUint8(str.charCodeAt(0));
  }
  /**
   * Write the charCodes of all `str`'s characters as 8-bit unsigned integers
   * and move pointer forward by `str.length` bytes.
   * @param str - The characters to write.
   * @returns This.
   */
  writeChars(str) {
    for (let i3 = 0; i3 < str.length; i3++) {
      this.writeUint8(str.charCodeAt(i3));
    }
    return this;
  }
  /**
   * UTF-8 encode and write `str` to the current pointer offset and move pointer
   * forward according to the encoded length.
   * @param str - The string to write.
   * @returns This.
   */
  writeUtf8(str) {
    return this.writeBytes(encode(str));
  }
  /**
   * Export a Uint8Array view of the internal buffer.
   * The view starts at the byte offset and its length
   * is calculated to stop at the last written byte or the original length.
   * @returns A new Uint8Array view.
   */
  toArray() {
    return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);
  }
  /**
   *  Get the total number of bytes written so far, regardless of the current offset.
   * @returns - Total number of bytes.
   */
  getWrittenByteLength() {
    return this.lastWrittenByte - this.byteOffset;
  }
  /**
   * Update the last written byte offset
   * @private
   */
  _updateLastWrittenByte() {
    if (this.offset > this.lastWrittenByte) {
      this.lastWrittenByte = this.offset;
    }
  }
};

// node_modules/pako/dist/pako.esm.mjs
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
var extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
var extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
var d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
var put_short = (s4, w3) => {
  s4.pending_buf[s4.pending++] = w3 & 255;
  s4.pending_buf[s4.pending++] = w3 >>> 8 & 255;
};
var send_bits = (s4, value, length) => {
  if (s4.bi_valid > Buf_size - length) {
    s4.bi_buf |= value << s4.bi_valid & 65535;
    put_short(s4, s4.bi_buf);
    s4.bi_buf = value >> Buf_size - s4.bi_valid;
    s4.bi_valid += length - Buf_size;
  } else {
    s4.bi_buf |= value << s4.bi_valid & 65535;
    s4.bi_valid += length;
  }
};
var send_code = (s4, c4, tree) => {
  send_bits(
    s4,
    tree[c4 * 2],
    tree[c4 * 2 + 1]
    /*.Len*/
  );
};
var bi_reverse = (code, len) => {
  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
var bi_flush = (s4) => {
  if (s4.bi_valid === 16) {
    put_short(s4, s4.bi_buf);
    s4.bi_buf = 0;
    s4.bi_valid = 0;
  } else if (s4.bi_valid >= 8) {
    s4.pending_buf[s4.pending++] = s4.bi_buf & 255;
    s4.bi_buf >>= 8;
    s4.bi_valid -= 8;
  }
};
var gen_bitlen = (s4, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h4;
  let n2, m2;
  let bits;
  let xbits;
  let f7;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s4.bl_count[bits] = 0;
  }
  tree[s4.heap[s4.heap_max] * 2 + 1] = 0;
  for (h4 = s4.heap_max + 1; h4 < HEAP_SIZE$1; h4++) {
    n2 = s4.heap[h4];
    bits = tree[tree[n2 * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n2 * 2 + 1] = bits;
    if (n2 > max_code) {
      continue;
    }
    s4.bl_count[bits]++;
    xbits = 0;
    if (n2 >= base) {
      xbits = extra[n2 - base];
    }
    f7 = tree[n2 * 2];
    s4.opt_len += f7 * (bits + xbits);
    if (has_stree) {
      s4.static_len += f7 * (stree[n2 * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s4.bl_count[bits] === 0) {
      bits--;
    }
    s4.bl_count[bits]--;
    s4.bl_count[bits + 1] += 2;
    s4.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n2 = s4.bl_count[bits];
    while (n2 !== 0) {
      m2 = s4.heap[--h4];
      if (m2 > max_code) {
        continue;
      }
      if (tree[m2 * 2 + 1] !== bits) {
        s4.opt_len += (bits - tree[m2 * 2 + 1]) * tree[m2 * 2];
        tree[m2 * 2 + 1] = bits;
      }
      n2--;
    }
  }
};
var gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code = 0;
  let bits;
  let n2;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code = code + bl_count[bits - 1] << 1;
    next_code[bits] = code;
  }
  for (n2 = 0; n2 <= max_code; n2++) {
    let len = tree[n2 * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n2 * 2] = bi_reverse(next_code[len]++, len);
  }
};
var tr_static_init = () => {
  let n2;
  let bits;
  let length;
  let code;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n2 = 0; n2 < 1 << extra_lbits[code]; n2++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n2 = 0; n2 < 1 << extra_dbits[code]; n2++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n2 = 0; n2 < 1 << extra_dbits[code] - 7; n2++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n2 = 0;
  while (n2 <= 143) {
    static_ltree[n2 * 2 + 1] = 8;
    n2++;
    bl_count[8]++;
  }
  while (n2 <= 255) {
    static_ltree[n2 * 2 + 1] = 9;
    n2++;
    bl_count[9]++;
  }
  while (n2 <= 279) {
    static_ltree[n2 * 2 + 1] = 7;
    n2++;
    bl_count[7]++;
  }
  while (n2 <= 287) {
    static_ltree[n2 * 2 + 1] = 8;
    n2++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n2 = 0; n2 < D_CODES$1; n2++) {
    static_dtree[n2 * 2 + 1] = 5;
    static_dtree[n2 * 2] = bi_reverse(n2, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
var init_block = (s4) => {
  let n2;
  for (n2 = 0; n2 < L_CODES$1; n2++) {
    s4.dyn_ltree[n2 * 2] = 0;
  }
  for (n2 = 0; n2 < D_CODES$1; n2++) {
    s4.dyn_dtree[n2 * 2] = 0;
  }
  for (n2 = 0; n2 < BL_CODES$1; n2++) {
    s4.bl_tree[n2 * 2] = 0;
  }
  s4.dyn_ltree[END_BLOCK * 2] = 1;
  s4.opt_len = s4.static_len = 0;
  s4.sym_next = s4.matches = 0;
};
var bi_windup = (s4) => {
  if (s4.bi_valid > 8) {
    put_short(s4, s4.bi_buf);
  } else if (s4.bi_valid > 0) {
    s4.pending_buf[s4.pending++] = s4.bi_buf;
  }
  s4.bi_buf = 0;
  s4.bi_valid = 0;
};
var smaller = (tree, n2, m2, depth) => {
  const _n2 = n2 * 2;
  const _m2 = m2 * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n2] <= depth[m2];
};
var pqdownheap = (s4, tree, k4) => {
  const v2 = s4.heap[k4];
  let j2 = k4 << 1;
  while (j2 <= s4.heap_len) {
    if (j2 < s4.heap_len && smaller(tree, s4.heap[j2 + 1], s4.heap[j2], s4.depth)) {
      j2++;
    }
    if (smaller(tree, v2, s4.heap[j2], s4.depth)) {
      break;
    }
    s4.heap[k4] = s4.heap[j2];
    k4 = j2;
    j2 <<= 1;
  }
  s4.heap[k4] = v2;
};
var compress_block = (s4, ltree, dtree) => {
  let dist;
  let lc;
  let sx = 0;
  let code;
  let extra;
  if (s4.sym_next !== 0) {
    do {
      dist = s4.pending_buf[s4.sym_buf + sx++] & 255;
      dist += (s4.pending_buf[s4.sym_buf + sx++] & 255) << 8;
      lc = s4.pending_buf[s4.sym_buf + sx++];
      if (dist === 0) {
        send_code(s4, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s4, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s4, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s4, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s4, dist, extra);
        }
      }
    } while (sx < s4.sym_next);
  }
  send_code(s4, END_BLOCK, ltree);
};
var build_tree = (s4, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n2, m2;
  let max_code = -1;
  let node;
  s4.heap_len = 0;
  s4.heap_max = HEAP_SIZE$1;
  for (n2 = 0; n2 < elems; n2++) {
    if (tree[n2 * 2] !== 0) {
      s4.heap[++s4.heap_len] = max_code = n2;
      s4.depth[n2] = 0;
    } else {
      tree[n2 * 2 + 1] = 0;
    }
  }
  while (s4.heap_len < 2) {
    node = s4.heap[++s4.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s4.depth[node] = 0;
    s4.opt_len--;
    if (has_stree) {
      s4.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n2 = s4.heap_len >> 1; n2 >= 1; n2--) {
    pqdownheap(s4, tree, n2);
  }
  node = elems;
  do {
    n2 = s4.heap[
      1
      /*SMALLEST*/
    ];
    s4.heap[
      1
      /*SMALLEST*/
    ] = s4.heap[s4.heap_len--];
    pqdownheap(
      s4,
      tree,
      1
      /*SMALLEST*/
    );
    m2 = s4.heap[
      1
      /*SMALLEST*/
    ];
    s4.heap[--s4.heap_max] = n2;
    s4.heap[--s4.heap_max] = m2;
    tree[node * 2] = tree[n2 * 2] + tree[m2 * 2];
    s4.depth[node] = (s4.depth[n2] >= s4.depth[m2] ? s4.depth[n2] : s4.depth[m2]) + 1;
    tree[n2 * 2 + 1] = tree[m2 * 2 + 1] = node;
    s4.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s4,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s4.heap_len >= 2);
  s4.heap[--s4.heap_max] = s4.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s4, desc);
  gen_codes(tree, max_code, s4.bl_count);
};
var scan_tree = (s4, tree, max_code) => {
  let n2;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n2 = 0; n2 <= max_code; n2++) {
    curlen = nextlen;
    nextlen = tree[(n2 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s4.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s4.bl_tree[curlen * 2]++;
      }
      s4.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s4.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s4.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var send_tree = (s4, tree, max_code) => {
  let n2;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n2 = 0; n2 <= max_code; n2++) {
    curlen = nextlen;
    nextlen = tree[(n2 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s4, curlen, s4.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s4, curlen, s4.bl_tree);
        count--;
      }
      send_code(s4, REP_3_6, s4.bl_tree);
      send_bits(s4, count - 3, 2);
    } else if (count <= 10) {
      send_code(s4, REPZ_3_10, s4.bl_tree);
      send_bits(s4, count - 3, 3);
    } else {
      send_code(s4, REPZ_11_138, s4.bl_tree);
      send_bits(s4, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var build_bl_tree = (s4) => {
  let max_blindex;
  scan_tree(s4, s4.dyn_ltree, s4.l_desc.max_code);
  scan_tree(s4, s4.dyn_dtree, s4.d_desc.max_code);
  build_tree(s4, s4.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s4.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s4.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
var send_all_trees = (s4, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s4, lcodes - 257, 5);
  send_bits(s4, dcodes - 1, 5);
  send_bits(s4, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s4, s4.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s4, s4.dyn_ltree, lcodes - 1);
  send_tree(s4, s4.dyn_dtree, dcodes - 1);
};
var detect_data_type = (s4) => {
  let block_mask = 4093624447;
  let n2;
  for (n2 = 0; n2 <= 31; n2++, block_mask >>>= 1) {
    if (block_mask & 1 && s4.dyn_ltree[n2 * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s4.dyn_ltree[9 * 2] !== 0 || s4.dyn_ltree[10 * 2] !== 0 || s4.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n2 = 32; n2 < LITERALS$1; n2++) {
    if (s4.dyn_ltree[n2 * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
var static_init_done = false;
var _tr_init$1 = (s4) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s4.l_desc = new TreeDesc(s4.dyn_ltree, static_l_desc);
  s4.d_desc = new TreeDesc(s4.dyn_dtree, static_d_desc);
  s4.bl_desc = new TreeDesc(s4.bl_tree, static_bl_desc);
  s4.bi_buf = 0;
  s4.bi_valid = 0;
  init_block(s4);
};
var _tr_stored_block$1 = (s4, buf, stored_len, last) => {
  send_bits(s4, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  bi_windup(s4);
  put_short(s4, stored_len);
  put_short(s4, ~stored_len);
  if (stored_len) {
    s4.pending_buf.set(s4.window.subarray(buf, buf + stored_len), s4.pending);
  }
  s4.pending += stored_len;
};
var _tr_align$1 = (s4) => {
  send_bits(s4, STATIC_TREES << 1, 3);
  send_code(s4, END_BLOCK, static_ltree);
  bi_flush(s4);
};
var _tr_flush_block$1 = (s4, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s4.level > 0) {
    if (s4.strm.data_type === Z_UNKNOWN$1) {
      s4.strm.data_type = detect_data_type(s4);
    }
    build_tree(s4, s4.l_desc);
    build_tree(s4, s4.d_desc);
    max_blindex = build_bl_tree(s4);
    opt_lenb = s4.opt_len + 3 + 7 >>> 3;
    static_lenb = s4.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s4, buf, stored_len, last);
  } else if (s4.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s4, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s4, static_ltree, static_dtree);
  } else {
    send_bits(s4, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s4, s4.l_desc.max_code + 1, s4.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s4, s4.dyn_ltree, s4.dyn_dtree);
  }
  init_block(s4);
  if (last) {
    bi_windup(s4);
  }
};
var _tr_tally$1 = (s4, dist, lc) => {
  s4.pending_buf[s4.sym_buf + s4.sym_next++] = dist;
  s4.pending_buf[s4.sym_buf + s4.sym_next++] = dist >> 8;
  s4.pending_buf[s4.sym_buf + s4.sym_next++] = lc;
  if (dist === 0) {
    s4.dyn_ltree[lc * 2]++;
  } else {
    s4.matches++;
    dist--;
    s4.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s4.dyn_dtree[d_code(dist) * 2]++;
  }
  return s4.sym_next === s4.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
var adler32 = (adler, buf, len, pos) => {
  let s1 = adler & 65535 | 0, s22 = adler >>> 16 & 65535 | 0, n2 = 0;
  while (len !== 0) {
    n2 = len > 2e3 ? 2e3 : len;
    len -= n2;
    do {
      s1 = s1 + buf[pos++] | 0;
      s22 = s22 + s1 | 0;
    } while (--n2);
    s1 %= 65521;
    s22 %= 65521;
  }
  return s1 | s22 << 16 | 0;
};
var adler32_1 = adler32;
var makeTable = () => {
  let c4, table = [];
  for (var n2 = 0; n2 < 256; n2++) {
    c4 = n2;
    for (var k4 = 0; k4 < 8; k4++) {
      c4 = c4 & 1 ? 3988292384 ^ c4 >>> 1 : c4 >>> 1;
    }
    table[n2] = c4;
  }
  return table;
};
var crcTable = new Uint32Array(makeTable());
var crc32 = (crc2, buf, len, pos) => {
  const t3 = crcTable;
  const end = pos + len;
  crc2 ^= -1;
  for (let i3 = pos; i3 < end; i3++) {
    crc2 = crc2 >>> 8 ^ t3[(crc2 ^ buf[i3]) & 255];
  }
  return crc2 ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var GZIP_STATE = 57;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
var err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
var rank = (f7) => {
  return f7 * 2 - (f7 > 4 ? 9 : 0);
};
var zero = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
var slide_hash = (s4) => {
  let n2, m2;
  let p4;
  let wsize = s4.w_size;
  n2 = s4.hash_size;
  p4 = n2;
  do {
    m2 = s4.head[--p4];
    s4.head[p4] = m2 >= wsize ? m2 - wsize : 0;
  } while (--n2);
  n2 = wsize;
  p4 = n2;
  do {
    m2 = s4.prev[--p4];
    s4.prev[p4] = m2 >= wsize ? m2 - wsize : 0;
  } while (--n2);
};
var HASH_ZLIB = (s4, prev, data) => (prev << s4.hash_shift ^ data) & s4.hash_mask;
var HASH = HASH_ZLIB;
var flush_pending = (strm) => {
  const s4 = strm.state;
  let len = s4.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s4.pending_buf.subarray(s4.pending_out, s4.pending_out + len), strm.next_out);
  strm.next_out += len;
  s4.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s4.pending -= len;
  if (s4.pending === 0) {
    s4.pending_out = 0;
  }
};
var flush_block_only = (s4, last) => {
  _tr_flush_block(s4, s4.block_start >= 0 ? s4.block_start : -1, s4.strstart - s4.block_start, last);
  s4.block_start = s4.strstart;
  flush_pending(s4.strm);
};
var put_byte = (s4, b4) => {
  s4.pending_buf[s4.pending++] = b4;
};
var putShortMSB = (s4, b4) => {
  s4.pending_buf[s4.pending++] = b4 >>> 8 & 255;
  s4.pending_buf[s4.pending++] = b4 & 255;
};
var read_buf = (strm, buf, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
var longest_match = (s4, cur_match) => {
  let chain_length = s4.max_chain_length;
  let scan = s4.strstart;
  let match;
  let len;
  let best_len = s4.prev_length;
  let nice_match = s4.nice_match;
  const limit = s4.strstart > s4.w_size - MIN_LOOKAHEAD ? s4.strstart - (s4.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s4.window;
  const wmask = s4.w_mask;
  const prev = s4.prev;
  const strend = s4.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s4.prev_length >= s4.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s4.lookahead) {
    nice_match = s4.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s4.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s4.lookahead) {
    return best_len;
  }
  return s4.lookahead;
};
var fill_window = (s4) => {
  const _w_size = s4.w_size;
  let n2, more, str;
  do {
    more = s4.window_size - s4.lookahead - s4.strstart;
    if (s4.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s4.window.set(s4.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s4.match_start -= _w_size;
      s4.strstart -= _w_size;
      s4.block_start -= _w_size;
      if (s4.insert > s4.strstart) {
        s4.insert = s4.strstart;
      }
      slide_hash(s4);
      more += _w_size;
    }
    if (s4.strm.avail_in === 0) {
      break;
    }
    n2 = read_buf(s4.strm, s4.window, s4.strstart + s4.lookahead, more);
    s4.lookahead += n2;
    if (s4.lookahead + s4.insert >= MIN_MATCH) {
      str = s4.strstart - s4.insert;
      s4.ins_h = s4.window[str];
      s4.ins_h = HASH(s4, s4.ins_h, s4.window[str + 1]);
      while (s4.insert) {
        s4.ins_h = HASH(s4, s4.ins_h, s4.window[str + MIN_MATCH - 1]);
        s4.prev[str & s4.w_mask] = s4.head[s4.ins_h];
        s4.head[s4.ins_h] = str;
        str++;
        s4.insert--;
        if (s4.lookahead + s4.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s4.lookahead < MIN_LOOKAHEAD && s4.strm.avail_in !== 0);
};
var deflate_stored = (s4, flush) => {
  let min_block = s4.pending_buf_size - 5 > s4.w_size ? s4.w_size : s4.pending_buf_size - 5;
  let len, left, have, last = 0;
  let used = s4.strm.avail_in;
  do {
    len = 65535;
    have = s4.bi_valid + 42 >> 3;
    if (s4.strm.avail_out < have) {
      break;
    }
    have = s4.strm.avail_out - have;
    left = s4.strstart - s4.block_start;
    if (len > left + s4.strm.avail_in) {
      len = left + s4.strm.avail_in;
    }
    if (len > have) {
      len = have;
    }
    if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s4.strm.avail_in)) {
      break;
    }
    last = flush === Z_FINISH$3 && len === left + s4.strm.avail_in ? 1 : 0;
    _tr_stored_block(s4, 0, 0, last);
    s4.pending_buf[s4.pending - 4] = len;
    s4.pending_buf[s4.pending - 3] = len >> 8;
    s4.pending_buf[s4.pending - 2] = ~len;
    s4.pending_buf[s4.pending - 1] = ~len >> 8;
    flush_pending(s4.strm);
    if (left) {
      if (left > len) {
        left = len;
      }
      s4.strm.output.set(s4.window.subarray(s4.block_start, s4.block_start + left), s4.strm.next_out);
      s4.strm.next_out += left;
      s4.strm.avail_out -= left;
      s4.strm.total_out += left;
      s4.block_start += left;
      len -= left;
    }
    if (len) {
      read_buf(s4.strm, s4.strm.output, s4.strm.next_out, len);
      s4.strm.next_out += len;
      s4.strm.avail_out -= len;
      s4.strm.total_out += len;
    }
  } while (last === 0);
  used -= s4.strm.avail_in;
  if (used) {
    if (used >= s4.w_size) {
      s4.matches = 2;
      s4.window.set(s4.strm.input.subarray(s4.strm.next_in - s4.w_size, s4.strm.next_in), 0);
      s4.strstart = s4.w_size;
      s4.insert = s4.strstart;
    } else {
      if (s4.window_size - s4.strstart <= used) {
        s4.strstart -= s4.w_size;
        s4.window.set(s4.window.subarray(s4.w_size, s4.w_size + s4.strstart), 0);
        if (s4.matches < 2) {
          s4.matches++;
        }
        if (s4.insert > s4.strstart) {
          s4.insert = s4.strstart;
        }
      }
      s4.window.set(s4.strm.input.subarray(s4.strm.next_in - used, s4.strm.next_in), s4.strstart);
      s4.strstart += used;
      s4.insert += used > s4.w_size - s4.insert ? s4.w_size - s4.insert : used;
    }
    s4.block_start = s4.strstart;
  }
  if (s4.high_water < s4.strstart) {
    s4.high_water = s4.strstart;
  }
  if (last) {
    return BS_FINISH_DONE;
  }
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s4.strm.avail_in === 0 && s4.strstart === s4.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s4.window_size - s4.strstart;
  if (s4.strm.avail_in > have && s4.block_start >= s4.w_size) {
    s4.block_start -= s4.w_size;
    s4.strstart -= s4.w_size;
    s4.window.set(s4.window.subarray(s4.w_size, s4.w_size + s4.strstart), 0);
    if (s4.matches < 2) {
      s4.matches++;
    }
    have += s4.w_size;
    if (s4.insert > s4.strstart) {
      s4.insert = s4.strstart;
    }
  }
  if (have > s4.strm.avail_in) {
    have = s4.strm.avail_in;
  }
  if (have) {
    read_buf(s4.strm, s4.window, s4.strstart, have);
    s4.strstart += have;
    s4.insert += have > s4.w_size - s4.insert ? s4.w_size - s4.insert : have;
  }
  if (s4.high_water < s4.strstart) {
    s4.high_water = s4.strstart;
  }
  have = s4.bi_valid + 42 >> 3;
  have = s4.pending_buf_size - have > 65535 ? 65535 : s4.pending_buf_size - have;
  min_block = have > s4.w_size ? s4.w_size : have;
  left = s4.strstart - s4.block_start;
  if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s4.strm.avail_in === 0 && left <= have) {
    len = left > have ? have : left;
    last = flush === Z_FINISH$3 && s4.strm.avail_in === 0 && len === left ? 1 : 0;
    _tr_stored_block(s4, s4.block_start, len, last);
    s4.block_start += len;
    flush_pending(s4.strm);
  }
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};
var deflate_fast = (s4, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s4.lookahead < MIN_LOOKAHEAD) {
      fill_window(s4);
      if (s4.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s4.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s4.lookahead >= MIN_MATCH) {
      s4.ins_h = HASH(s4, s4.ins_h, s4.window[s4.strstart + MIN_MATCH - 1]);
      hash_head = s4.prev[s4.strstart & s4.w_mask] = s4.head[s4.ins_h];
      s4.head[s4.ins_h] = s4.strstart;
    }
    if (hash_head !== 0 && s4.strstart - hash_head <= s4.w_size - MIN_LOOKAHEAD) {
      s4.match_length = longest_match(s4, hash_head);
    }
    if (s4.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s4, s4.strstart - s4.match_start, s4.match_length - MIN_MATCH);
      s4.lookahead -= s4.match_length;
      if (s4.match_length <= s4.max_lazy_match && s4.lookahead >= MIN_MATCH) {
        s4.match_length--;
        do {
          s4.strstart++;
          s4.ins_h = HASH(s4, s4.ins_h, s4.window[s4.strstart + MIN_MATCH - 1]);
          hash_head = s4.prev[s4.strstart & s4.w_mask] = s4.head[s4.ins_h];
          s4.head[s4.ins_h] = s4.strstart;
        } while (--s4.match_length !== 0);
        s4.strstart++;
      } else {
        s4.strstart += s4.match_length;
        s4.match_length = 0;
        s4.ins_h = s4.window[s4.strstart];
        s4.ins_h = HASH(s4, s4.ins_h, s4.window[s4.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s4, 0, s4.window[s4.strstart]);
      s4.lookahead--;
      s4.strstart++;
    }
    if (bflush) {
      flush_block_only(s4, false);
      if (s4.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s4.insert = s4.strstart < MIN_MATCH - 1 ? s4.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s4, true);
    if (s4.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s4.sym_next) {
    flush_block_only(s4, false);
    if (s4.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_slow = (s4, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s4.lookahead < MIN_LOOKAHEAD) {
      fill_window(s4);
      if (s4.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s4.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s4.lookahead >= MIN_MATCH) {
      s4.ins_h = HASH(s4, s4.ins_h, s4.window[s4.strstart + MIN_MATCH - 1]);
      hash_head = s4.prev[s4.strstart & s4.w_mask] = s4.head[s4.ins_h];
      s4.head[s4.ins_h] = s4.strstart;
    }
    s4.prev_length = s4.match_length;
    s4.prev_match = s4.match_start;
    s4.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s4.prev_length < s4.max_lazy_match && s4.strstart - hash_head <= s4.w_size - MIN_LOOKAHEAD) {
      s4.match_length = longest_match(s4, hash_head);
      if (s4.match_length <= 5 && (s4.strategy === Z_FILTERED || s4.match_length === MIN_MATCH && s4.strstart - s4.match_start > 4096)) {
        s4.match_length = MIN_MATCH - 1;
      }
    }
    if (s4.prev_length >= MIN_MATCH && s4.match_length <= s4.prev_length) {
      max_insert = s4.strstart + s4.lookahead - MIN_MATCH;
      bflush = _tr_tally(s4, s4.strstart - 1 - s4.prev_match, s4.prev_length - MIN_MATCH);
      s4.lookahead -= s4.prev_length - 1;
      s4.prev_length -= 2;
      do {
        if (++s4.strstart <= max_insert) {
          s4.ins_h = HASH(s4, s4.ins_h, s4.window[s4.strstart + MIN_MATCH - 1]);
          hash_head = s4.prev[s4.strstart & s4.w_mask] = s4.head[s4.ins_h];
          s4.head[s4.ins_h] = s4.strstart;
        }
      } while (--s4.prev_length !== 0);
      s4.match_available = 0;
      s4.match_length = MIN_MATCH - 1;
      s4.strstart++;
      if (bflush) {
        flush_block_only(s4, false);
        if (s4.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s4.match_available) {
      bflush = _tr_tally(s4, 0, s4.window[s4.strstart - 1]);
      if (bflush) {
        flush_block_only(s4, false);
      }
      s4.strstart++;
      s4.lookahead--;
      if (s4.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s4.match_available = 1;
      s4.strstart++;
      s4.lookahead--;
    }
  }
  if (s4.match_available) {
    bflush = _tr_tally(s4, 0, s4.window[s4.strstart - 1]);
    s4.match_available = 0;
  }
  s4.insert = s4.strstart < MIN_MATCH - 1 ? s4.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s4, true);
    if (s4.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s4.sym_next) {
    flush_block_only(s4, false);
    if (s4.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_rle = (s4, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s4.window;
  for (; ; ) {
    if (s4.lookahead <= MAX_MATCH) {
      fill_window(s4);
      if (s4.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s4.lookahead === 0) {
        break;
      }
    }
    s4.match_length = 0;
    if (s4.lookahead >= MIN_MATCH && s4.strstart > 0) {
      scan = s4.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s4.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s4.match_length = MAX_MATCH - (strend - scan);
        if (s4.match_length > s4.lookahead) {
          s4.match_length = s4.lookahead;
        }
      }
    }
    if (s4.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s4, 1, s4.match_length - MIN_MATCH);
      s4.lookahead -= s4.match_length;
      s4.strstart += s4.match_length;
      s4.match_length = 0;
    } else {
      bflush = _tr_tally(s4, 0, s4.window[s4.strstart]);
      s4.lookahead--;
      s4.strstart++;
    }
    if (bflush) {
      flush_block_only(s4, false);
      if (s4.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s4.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s4, true);
    if (s4.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s4.sym_next) {
    flush_block_only(s4, false);
    if (s4.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_huff = (s4, flush) => {
  let bflush;
  for (; ; ) {
    if (s4.lookahead === 0) {
      fill_window(s4);
      if (s4.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s4.match_length = 0;
    bflush = _tr_tally(s4, 0, s4.window[s4.strstart]);
    s4.lookahead--;
    s4.strstart++;
    if (bflush) {
      flush_block_only(s4, false);
      if (s4.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s4.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s4, true);
    if (s4.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s4.sym_next) {
    flush_block_only(s4, false);
    if (s4.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
var lm_init = (s4) => {
  s4.window_size = 2 * s4.w_size;
  zero(s4.head);
  s4.max_lazy_match = configuration_table[s4.level].max_lazy;
  s4.good_match = configuration_table[s4.level].good_length;
  s4.nice_match = configuration_table[s4.level].nice_length;
  s4.max_chain_length = configuration_table[s4.level].max_chain;
  s4.strstart = 0;
  s4.block_start = 0;
  s4.lookahead = 0;
  s4.insert = 0;
  s4.match_length = s4.prev_length = MIN_MATCH - 1;
  s4.match_available = 0;
  s4.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
var deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s4 = strm.state;
  if (!s4 || s4.strm !== strm || s4.status !== INIT_STATE && //#ifdef GZIP
  s4.status !== GZIP_STATE && //#endif
  s4.status !== EXTRA_STATE && s4.status !== NAME_STATE && s4.status !== COMMENT_STATE && s4.status !== HCRC_STATE && s4.status !== BUSY_STATE && s4.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
var deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s4 = strm.state;
  s4.pending = 0;
  s4.pending_out = 0;
  if (s4.wrap < 0) {
    s4.wrap = -s4.wrap;
  }
  s4.status = //#ifdef GZIP
  s4.wrap === 2 ? GZIP_STATE : (
    //#endif
    s4.wrap ? INIT_STATE : BUSY_STATE
  );
  strm.adler = s4.wrap === 2 ? 0 : 1;
  s4.last_flush = -2;
  _tr_init(s4);
  return Z_OK$3;
};
var deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
var deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s4 = new DeflateState();
  strm.state = s4;
  s4.strm = strm;
  s4.status = INIT_STATE;
  s4.wrap = wrap;
  s4.gzhead = null;
  s4.w_bits = windowBits;
  s4.w_size = 1 << s4.w_bits;
  s4.w_mask = s4.w_size - 1;
  s4.hash_bits = memLevel + 7;
  s4.hash_size = 1 << s4.hash_bits;
  s4.hash_mask = s4.hash_size - 1;
  s4.hash_shift = ~~((s4.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s4.window = new Uint8Array(s4.w_size * 2);
  s4.head = new Uint16Array(s4.hash_size);
  s4.prev = new Uint16Array(s4.w_size);
  s4.lit_bufsize = 1 << memLevel + 6;
  s4.pending_buf_size = s4.lit_bufsize * 4;
  s4.pending_buf = new Uint8Array(s4.pending_buf_size);
  s4.sym_buf = s4.lit_bufsize;
  s4.sym_end = (s4.lit_bufsize - 1) * 3;
  s4.level = level;
  s4.strategy = strategy;
  s4.method = method;
  return deflateReset(strm);
};
var deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
var deflate$2 = (strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s4 = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s4.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s4.last_flush;
  s4.last_flush = flush;
  if (s4.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s4.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s4.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s4.status === INIT_STATE && s4.wrap === 0) {
    s4.status = BUSY_STATE;
  }
  if (s4.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s4.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s4.strategy >= Z_HUFFMAN_ONLY || s4.level < 2) {
      level_flags = 0;
    } else if (s4.level < 6) {
      level_flags = 1;
    } else if (s4.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s4.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s4, header);
    if (s4.strstart !== 0) {
      putShortMSB(s4, strm.adler >>> 16);
      putShortMSB(s4, strm.adler & 65535);
    }
    strm.adler = 1;
    s4.status = BUSY_STATE;
    flush_pending(strm);
    if (s4.pending !== 0) {
      s4.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s4.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s4, 31);
    put_byte(s4, 139);
    put_byte(s4, 8);
    if (!s4.gzhead) {
      put_byte(s4, 0);
      put_byte(s4, 0);
      put_byte(s4, 0);
      put_byte(s4, 0);
      put_byte(s4, 0);
      put_byte(s4, s4.level === 9 ? 2 : s4.strategy >= Z_HUFFMAN_ONLY || s4.level < 2 ? 4 : 0);
      put_byte(s4, OS_CODE);
      s4.status = BUSY_STATE;
      flush_pending(strm);
      if (s4.pending !== 0) {
        s4.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s4,
        (s4.gzhead.text ? 1 : 0) + (s4.gzhead.hcrc ? 2 : 0) + (!s4.gzhead.extra ? 0 : 4) + (!s4.gzhead.name ? 0 : 8) + (!s4.gzhead.comment ? 0 : 16)
      );
      put_byte(s4, s4.gzhead.time & 255);
      put_byte(s4, s4.gzhead.time >> 8 & 255);
      put_byte(s4, s4.gzhead.time >> 16 & 255);
      put_byte(s4, s4.gzhead.time >> 24 & 255);
      put_byte(s4, s4.level === 9 ? 2 : s4.strategy >= Z_HUFFMAN_ONLY || s4.level < 2 ? 4 : 0);
      put_byte(s4, s4.gzhead.os & 255);
      if (s4.gzhead.extra && s4.gzhead.extra.length) {
        put_byte(s4, s4.gzhead.extra.length & 255);
        put_byte(s4, s4.gzhead.extra.length >> 8 & 255);
      }
      if (s4.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s4.pending_buf, s4.pending, 0);
      }
      s4.gzindex = 0;
      s4.status = EXTRA_STATE;
    }
  }
  if (s4.status === EXTRA_STATE) {
    if (s4.gzhead.extra) {
      let beg = s4.pending;
      let left = (s4.gzhead.extra.length & 65535) - s4.gzindex;
      while (s4.pending + left > s4.pending_buf_size) {
        let copy = s4.pending_buf_size - s4.pending;
        s4.pending_buf.set(s4.gzhead.extra.subarray(s4.gzindex, s4.gzindex + copy), s4.pending);
        s4.pending = s4.pending_buf_size;
        if (s4.gzhead.hcrc && s4.pending > beg) {
          strm.adler = crc32_1(strm.adler, s4.pending_buf, s4.pending - beg, beg);
        }
        s4.gzindex += copy;
        flush_pending(strm);
        if (s4.pending !== 0) {
          s4.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      let gzhead_extra = new Uint8Array(s4.gzhead.extra);
      s4.pending_buf.set(gzhead_extra.subarray(s4.gzindex, s4.gzindex + left), s4.pending);
      s4.pending += left;
      if (s4.gzhead.hcrc && s4.pending > beg) {
        strm.adler = crc32_1(strm.adler, s4.pending_buf, s4.pending - beg, beg);
      }
      s4.gzindex = 0;
    }
    s4.status = NAME_STATE;
  }
  if (s4.status === NAME_STATE) {
    if (s4.gzhead.name) {
      let beg = s4.pending;
      let val;
      do {
        if (s4.pending === s4.pending_buf_size) {
          if (s4.gzhead.hcrc && s4.pending > beg) {
            strm.adler = crc32_1(strm.adler, s4.pending_buf, s4.pending - beg, beg);
          }
          flush_pending(strm);
          if (s4.pending !== 0) {
            s4.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s4.gzindex < s4.gzhead.name.length) {
          val = s4.gzhead.name.charCodeAt(s4.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s4, val);
      } while (val !== 0);
      if (s4.gzhead.hcrc && s4.pending > beg) {
        strm.adler = crc32_1(strm.adler, s4.pending_buf, s4.pending - beg, beg);
      }
      s4.gzindex = 0;
    }
    s4.status = COMMENT_STATE;
  }
  if (s4.status === COMMENT_STATE) {
    if (s4.gzhead.comment) {
      let beg = s4.pending;
      let val;
      do {
        if (s4.pending === s4.pending_buf_size) {
          if (s4.gzhead.hcrc && s4.pending > beg) {
            strm.adler = crc32_1(strm.adler, s4.pending_buf, s4.pending - beg, beg);
          }
          flush_pending(strm);
          if (s4.pending !== 0) {
            s4.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s4.gzindex < s4.gzhead.comment.length) {
          val = s4.gzhead.comment.charCodeAt(s4.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s4, val);
      } while (val !== 0);
      if (s4.gzhead.hcrc && s4.pending > beg) {
        strm.adler = crc32_1(strm.adler, s4.pending_buf, s4.pending - beg, beg);
      }
    }
    s4.status = HCRC_STATE;
  }
  if (s4.status === HCRC_STATE) {
    if (s4.gzhead.hcrc) {
      if (s4.pending + 2 > s4.pending_buf_size) {
        flush_pending(strm);
        if (s4.pending !== 0) {
          s4.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s4, strm.adler & 255);
      put_byte(s4, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s4.status = BUSY_STATE;
    flush_pending(strm);
    if (s4.pending !== 0) {
      s4.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s4.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s4.status !== FINISH_STATE) {
    let bstate = s4.level === 0 ? deflate_stored(s4, flush) : s4.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s4, flush) : s4.strategy === Z_RLE ? deflate_rle(s4, flush) : configuration_table[s4.level].func(s4, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s4.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s4.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s4);
      } else if (flush !== Z_BLOCK$1) {
        _tr_stored_block(s4, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero(s4.head);
          if (s4.lookahead === 0) {
            s4.strstart = 0;
            s4.block_start = 0;
            s4.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s4.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s4.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s4.wrap === 2) {
    put_byte(s4, strm.adler & 255);
    put_byte(s4, strm.adler >> 8 & 255);
    put_byte(s4, strm.adler >> 16 & 255);
    put_byte(s4, strm.adler >> 24 & 255);
    put_byte(s4, strm.total_in & 255);
    put_byte(s4, strm.total_in >> 8 & 255);
    put_byte(s4, strm.total_in >> 16 & 255);
    put_byte(s4, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s4, strm.adler >>> 16);
    putShortMSB(s4, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s4.wrap > 0) {
    s4.wrap = -s4.wrap;
  }
  return s4.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
var deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
var deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s4 = strm.state;
  const wrap = s4.wrap;
  if (wrap === 2 || wrap === 1 && s4.status !== INIT_STATE || s4.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s4.wrap = 0;
  if (dictLength >= s4.w_size) {
    if (wrap === 0) {
      zero(s4.head);
      s4.strstart = 0;
      s4.block_start = 0;
      s4.insert = 0;
    }
    let tmpDict = new Uint8Array(s4.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s4.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s4.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s4);
  while (s4.lookahead >= MIN_MATCH) {
    let str = s4.strstart;
    let n2 = s4.lookahead - (MIN_MATCH - 1);
    do {
      s4.ins_h = HASH(s4, s4.ins_h, s4.window[str + MIN_MATCH - 1]);
      s4.prev[str & s4.w_mask] = s4.head[s4.ins_h];
      s4.head[s4.ins_h] = str;
      str++;
    } while (--n2);
    s4.strstart = str;
    s4.lookahead = MIN_MATCH - 1;
    fill_window(s4);
  }
  s4.strstart += s4.lookahead;
  s4.block_start = s4.strstart;
  s4.insert = s4.lookahead;
  s4.lookahead = 0;
  s4.match_length = s4.prev_length = MIN_MATCH - 1;
  s4.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s4.wrap = wrap;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
var _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p4 in source) {
      if (_has(source, p4)) {
        obj[p4] = source[p4];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i3 = 0, l6 = chunks.length; i3 < l6; i3++) {
    len += chunks[i3].length;
  }
  const result = new Uint8Array(len);
  for (let i3 = 0, pos = 0, l6 = chunks.length; i3 < l6; i3++) {
    let chunk = chunks[i3];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new Uint8Array(256);
for (let q3 = 0; q3 < 256; q3++) {
  _utf8len[q3] = q3 >= 252 ? 6 : q3 >= 248 ? 5 : q3 >= 240 ? 4 : q3 >= 224 ? 3 : q3 >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c4, c22, m_pos, i3, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c4 = str.charCodeAt(m_pos);
    if ((c4 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c4 = 65536 + (c4 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    buf_len += c4 < 128 ? 1 : c4 < 2048 ? 2 : c4 < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i3 = 0, m_pos = 0; i3 < buf_len; m_pos++) {
    c4 = str.charCodeAt(m_pos);
    if ((c4 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c4 = 65536 + (c4 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    if (c4 < 128) {
      buf[i3++] = c4;
    } else if (c4 < 2048) {
      buf[i3++] = 192 | c4 >>> 6;
      buf[i3++] = 128 | c4 & 63;
    } else if (c4 < 65536) {
      buf[i3++] = 224 | c4 >>> 12;
      buf[i3++] = 128 | c4 >>> 6 & 63;
      buf[i3++] = 128 | c4 & 63;
    } else {
      buf[i3++] = 240 | c4 >>> 18;
      buf[i3++] = 128 | c4 >>> 12 & 63;
      buf[i3++] = 128 | c4 >>> 6 & 63;
      buf[i3++] = 128 | c4 & 63;
    }
  }
  return buf;
};
var buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i3 = 0; i3 < len; i3++) {
    result += String.fromCharCode(buf[i3]);
  }
  return result;
};
var buf2string = (buf, max) => {
  const len = max || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i3, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i3 = 0; i3 < len; ) {
    let c4 = buf[i3++];
    if (c4 < 128) {
      utf16buf[out++] = c4;
      continue;
    }
    let c_len = _utf8len[c4];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i3 += c_len - 1;
      continue;
    }
    c4 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i3 < len) {
      c4 = c4 << 6 | buf[i3++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c4 < 65536) {
      utf16buf[out++] = c4;
    } else {
      c4 -= 65536;
      utf16buf[out++] = 55296 | c4 >> 10 & 1023;
      utf16buf[out++] = 56320 | c4 & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var toString$1 = Object.prototype.toString;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data === "string") {
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1,
  constants: constants$1
};
var BAD$1 = 16209;
var TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
var lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
var dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
var dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
var inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base = extra = work;
    match = 20;
  } else if (type === LENS$1) {
    base = lbase;
    extra = lext;
    match = 257;
  } else {
    base = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
var HEAD = 16180;
var FLAGS = 16181;
var TIME = 16182;
var OS = 16183;
var EXLEN = 16184;
var EXTRA = 16185;
var NAME = 16186;
var COMMENT = 16187;
var HCRC = 16188;
var DICTID = 16189;
var DICT = 16190;
var TYPE = 16191;
var TYPEDO = 16192;
var STORED = 16193;
var COPY_ = 16194;
var COPY = 16195;
var TABLE = 16196;
var LENLENS = 16197;
var CODELENS = 16198;
var LEN_ = 16199;
var LEN = 16200;
var LENEXT = 16201;
var DIST = 16202;
var DISTEXT = 16203;
var MATCH = 16204;
var LIT = 16205;
var CHECK = 16206;
var LENGTH = 16207;
var DONE = 16208;
var BAD = 16209;
var MEM = 16210;
var SYNC = 16211;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
var zswap32 = (q3) => {
  return (q3 >>> 24 & 255) + (q3 >>> 8 & 65280) + ((q3 & 65280) << 8) + ((q3 & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
var inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
var inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
var inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
var inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
var inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
var inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
var virgin = true;
var lenfix;
var distfix;
var fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
var updatewindow = (strm, src, end, copy) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
var inflate$2 = (strm, flush) => {
  let state;
  let input, output;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n2;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        /* falls through */
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        /* falls through */
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        /* falls through */
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        /* falls through */
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        /* falls through */
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        /* falls through */
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        /* falls through */
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        /* falls through */
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        /* falls through */
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case COPY_:
          state.mode = COPY;
        /* falls through */
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy), put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        /* falls through */
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        /* falls through */
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n2 = here_bits + 2;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n2 = here_bits + 3;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n2 = here_bits + 7;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case LEN_:
          state.mode = LEN;
        /* falls through */
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        /* falls through */
        case LENEXT:
          if (state.extra) {
            n2 = state.extra;
            while (bits < n2) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        /* falls through */
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        /* falls through */
        case DISTEXT:
          if (state.extra) {
            n2 = state.extra;
            while (bits < n2) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        /* falls through */
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        /* falls through */
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        /* falls through */
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        /* falls through */
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
var inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
var inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
var inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
var toString = Object.prototype.toString;
var {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended) return false;
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0) continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err) throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants
};
var { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
var { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var Inflate_1 = Inflate;
var inflate_1 = inflate;

// node_modules/fast-png/lib/helpers/crc.js
var crcTable2 = [];
for (let n2 = 0; n2 < 256; n2++) {
  let c4 = n2;
  for (let k4 = 0; k4 < 8; k4++) {
    if (c4 & 1) {
      c4 = 3988292384 ^ c4 >>> 1;
    } else {
      c4 = c4 >>> 1;
    }
  }
  crcTable2[n2] = c4;
}
var initialCrc = 4294967295;
function updateCrc(currentCrc, data, length) {
  let c4 = currentCrc;
  for (let n2 = 0; n2 < length; n2++) {
    c4 = crcTable2[(c4 ^ data[n2]) & 255] ^ c4 >>> 8;
  }
  return c4;
}
function crc(data, length) {
  return (updateCrc(initialCrc, data, length) ^ initialCrc) >>> 0;
}
function checkCrc(buffer2, crcLength, chunkName) {
  const expectedCrc = buffer2.readUint32();
  const actualCrc = crc(new Uint8Array(buffer2.buffer, buffer2.byteOffset + buffer2.offset - crcLength - 4, crcLength), crcLength);
  if (actualCrc !== expectedCrc) {
    throw new Error(`CRC mismatch for chunk ${chunkName}. Expected ${expectedCrc}, found ${actualCrc}`);
  }
}

// node_modules/fast-png/lib/helpers/unfilter.js
function unfilterNone(currentLine, newLine, bytesPerLine) {
  for (let i3 = 0; i3 < bytesPerLine; i3++) {
    newLine[i3] = currentLine[i3];
  }
}
function unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel) {
  let i3 = 0;
  for (; i3 < bytesPerPixel; i3++) {
    newLine[i3] = currentLine[i3];
  }
  for (; i3 < bytesPerLine; i3++) {
    newLine[i3] = currentLine[i3] + newLine[i3 - bytesPerPixel] & 255;
  }
}
function unfilterUp(currentLine, newLine, prevLine, bytesPerLine) {
  let i3 = 0;
  if (prevLine.length === 0) {
    for (; i3 < bytesPerLine; i3++) {
      newLine[i3] = currentLine[i3];
    }
  } else {
    for (; i3 < bytesPerLine; i3++) {
      newLine[i3] = currentLine[i3] + prevLine[i3] & 255;
    }
  }
}
function unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {
  let i3 = 0;
  if (prevLine.length === 0) {
    for (; i3 < bytesPerPixel; i3++) {
      newLine[i3] = currentLine[i3];
    }
    for (; i3 < bytesPerLine; i3++) {
      newLine[i3] = currentLine[i3] + (newLine[i3 - bytesPerPixel] >> 1) & 255;
    }
  } else {
    for (; i3 < bytesPerPixel; i3++) {
      newLine[i3] = currentLine[i3] + (prevLine[i3] >> 1) & 255;
    }
    for (; i3 < bytesPerLine; i3++) {
      newLine[i3] = currentLine[i3] + (newLine[i3 - bytesPerPixel] + prevLine[i3] >> 1) & 255;
    }
  }
}
function unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {
  let i3 = 0;
  if (prevLine.length === 0) {
    for (; i3 < bytesPerPixel; i3++) {
      newLine[i3] = currentLine[i3];
    }
    for (; i3 < bytesPerLine; i3++) {
      newLine[i3] = currentLine[i3] + newLine[i3 - bytesPerPixel] & 255;
    }
  } else {
    for (; i3 < bytesPerPixel; i3++) {
      newLine[i3] = currentLine[i3] + prevLine[i3] & 255;
    }
    for (; i3 < bytesPerLine; i3++) {
      newLine[i3] = currentLine[i3] + paethPredictor(newLine[i3 - bytesPerPixel], prevLine[i3], prevLine[i3 - bytesPerPixel]) & 255;
    }
  }
}
function paethPredictor(a3, b4, c4) {
  const p4 = a3 + b4 - c4;
  const pa = Math.abs(p4 - a3);
  const pb = Math.abs(p4 - b4);
  const pc = Math.abs(p4 - c4);
  if (pa <= pb && pa <= pc)
    return a3;
  else if (pb <= pc)
    return b4;
  else
    return c4;
}

// node_modules/fast-png/lib/helpers/apply_unfilter.js
function applyUnfilter(filterType, currentLine, newLine, prevLine, passLineBytes, bytesPerPixel) {
  switch (filterType) {
    case 0:
      unfilterNone(currentLine, newLine, passLineBytes);
      break;
    case 1:
      unfilterSub(currentLine, newLine, passLineBytes, bytesPerPixel);
      break;
    case 2:
      unfilterUp(currentLine, newLine, prevLine, passLineBytes);
      break;
    case 3:
      unfilterAverage(currentLine, newLine, prevLine, passLineBytes, bytesPerPixel);
      break;
    case 4:
      unfilterPaeth(currentLine, newLine, prevLine, passLineBytes, bytesPerPixel);
      break;
    default:
      throw new Error(`Unsupported filter: ${filterType}`);
  }
}

// node_modules/fast-png/lib/helpers/decode_interlace_adam7.js
var uint16 = new Uint16Array([255]);
var uint8 = new Uint8Array(uint16.buffer);
var osIsLittleEndian = uint8[0] === 255;
function decodeInterlaceAdam7(params) {
  const { data, width, height, channels, depth } = params;
  const passes = [
    { x: 0, y: 0, xStep: 8, yStep: 8 },
    // Pass 1
    { x: 4, y: 0, xStep: 8, yStep: 8 },
    // Pass 2
    { x: 0, y: 4, xStep: 4, yStep: 8 },
    // Pass 3
    { x: 2, y: 0, xStep: 4, yStep: 4 },
    // Pass 4
    { x: 0, y: 2, xStep: 2, yStep: 4 },
    // Pass 5
    { x: 1, y: 0, xStep: 2, yStep: 2 },
    // Pass 6
    { x: 0, y: 1, xStep: 1, yStep: 2 }
    // Pass 7
  ];
  const bytesPerPixel = Math.ceil(depth / 8) * channels;
  const resultData = new Uint8Array(height * width * bytesPerPixel);
  let offset = 0;
  for (let passIndex = 0; passIndex < 7; passIndex++) {
    const pass = passes[passIndex];
    const passWidth = Math.ceil((width - pass.x) / pass.xStep);
    const passHeight = Math.ceil((height - pass.y) / pass.yStep);
    if (passWidth <= 0 || passHeight <= 0)
      continue;
    const passLineBytes = passWidth * bytesPerPixel;
    const prevLine = new Uint8Array(passLineBytes);
    for (let y6 = 0; y6 < passHeight; y6++) {
      const filterType = data[offset++];
      const currentLine = data.subarray(offset, offset + passLineBytes);
      offset += passLineBytes;
      const newLine = new Uint8Array(passLineBytes);
      applyUnfilter(filterType, currentLine, newLine, prevLine, passLineBytes, bytesPerPixel);
      prevLine.set(newLine);
      for (let x4 = 0; x4 < passWidth; x4++) {
        const outputX = pass.x + x4 * pass.xStep;
        const outputY = pass.y + y6 * pass.yStep;
        if (outputX >= width || outputY >= height)
          continue;
        for (let i3 = 0; i3 < bytesPerPixel; i3++) {
          resultData[(outputY * width + outputX) * bytesPerPixel + i3] = newLine[x4 * bytesPerPixel + i3];
        }
      }
    }
  }
  if (depth === 16) {
    const uint16Data = new Uint16Array(resultData.buffer);
    if (osIsLittleEndian) {
      for (let k4 = 0; k4 < uint16Data.length; k4++) {
        uint16Data[k4] = swap16(uint16Data[k4]);
      }
    }
    return uint16Data;
  } else {
    return resultData;
  }
}
function swap16(val) {
  return (val & 255) << 8 | val >> 8 & 255;
}

// node_modules/fast-png/lib/helpers/decode_interlace_null.js
var uint162 = new Uint16Array([255]);
var uint82 = new Uint8Array(uint162.buffer);
var osIsLittleEndian2 = uint82[0] === 255;
var empty = new Uint8Array(0);
function decodeInterlaceNull(params) {
  const { data, width, height, channels, depth } = params;
  const bytesPerPixel = Math.ceil(depth / 8) * channels;
  const bytesPerLine = Math.ceil(depth / 8 * channels * width);
  const newData = new Uint8Array(height * bytesPerLine);
  let prevLine = empty;
  let offset = 0;
  let currentLine;
  let newLine;
  for (let i3 = 0; i3 < height; i3++) {
    currentLine = data.subarray(offset + 1, offset + 1 + bytesPerLine);
    newLine = newData.subarray(i3 * bytesPerLine, (i3 + 1) * bytesPerLine);
    switch (data[offset]) {
      case 0:
        unfilterNone(currentLine, newLine, bytesPerLine);
        break;
      case 1:
        unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel);
        break;
      case 2:
        unfilterUp(currentLine, newLine, prevLine, bytesPerLine);
        break;
      case 3:
        unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);
        break;
      case 4:
        unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);
        break;
      default:
        throw new Error(`Unsupported filter: ${data[offset]}`);
    }
    prevLine = newLine;
    offset += bytesPerLine + 1;
  }
  if (depth === 16) {
    const uint16Data = new Uint16Array(newData.buffer);
    if (osIsLittleEndian2) {
      for (let k4 = 0; k4 < uint16Data.length; k4++) {
        uint16Data[k4] = swap162(uint16Data[k4]);
      }
    }
    return uint16Data;
  } else {
    return newData;
  }
}
function swap162(val) {
  return (val & 255) << 8 | val >> 8 & 255;
}

// node_modules/fast-png/lib/helpers/signature.js
var pngSignature = Uint8Array.of(137, 80, 78, 71, 13, 10, 26, 10);
function checkSignature(buffer2) {
  if (!hasPngSignature(buffer2.readBytes(pngSignature.length))) {
    throw new Error("wrong PNG signature");
  }
}
function hasPngSignature(array) {
  if (array.length < pngSignature.length) {
    return false;
  }
  for (let i3 = 0; i3 < pngSignature.length; i3++) {
    if (array[i3] !== pngSignature[i3]) {
      return false;
    }
  }
  return true;
}

// node_modules/fast-png/lib/helpers/text.js
var textChunkName = "tEXt";
var NULL = 0;
var latin1Decoder = new TextDecoder("latin1");
function validateKeyword(keyword) {
  validateLatin1(keyword);
  if (keyword.length === 0 || keyword.length > 79) {
    throw new Error("keyword length must be between 1 and 79");
  }
}
var latin1Regex = /^[\u0000-\u00FF]*$/;
function validateLatin1(text) {
  if (!latin1Regex.test(text)) {
    throw new Error("invalid latin1 text");
  }
}
function decodetEXt(text, buffer2, length) {
  const keyword = readKeyword(buffer2);
  text[keyword] = readLatin1(buffer2, length - keyword.length - 1);
}
function readKeyword(buffer2) {
  buffer2.mark();
  while (buffer2.readByte() !== NULL) {
  }
  const end = buffer2.offset;
  buffer2.reset();
  const keyword = latin1Decoder.decode(buffer2.readBytes(end - buffer2.offset - 1));
  buffer2.skip(1);
  validateKeyword(keyword);
  return keyword;
}
function readLatin1(buffer2, length) {
  return latin1Decoder.decode(buffer2.readBytes(length));
}

// node_modules/fast-png/lib/internal_types.js
var ColorType = {
  UNKNOWN: -1,
  GREYSCALE: 0,
  TRUECOLOUR: 2,
  INDEXED_COLOUR: 3,
  GREYSCALE_ALPHA: 4,
  TRUECOLOUR_ALPHA: 6
};
var CompressionMethod = {
  UNKNOWN: -1,
  DEFLATE: 0
};
var FilterMethod = {
  UNKNOWN: -1,
  ADAPTIVE: 0
};
var InterlaceMethod = {
  UNKNOWN: -1,
  NO_INTERLACE: 0,
  ADAM7: 1
};
var DisposeOpType = {
  NONE: 0,
  BACKGROUND: 1,
  PREVIOUS: 2
};
var BlendOpType = {
  SOURCE: 0,
  OVER: 1
};

// node_modules/fast-png/lib/png_decoder.js
var PngDecoder = class extends IOBuffer {
  constructor(data, options = {}) {
    super(data);
    __publicField(this, "_checkCrc");
    __publicField(this, "_inflator");
    __publicField(this, "_png");
    __publicField(this, "_apng");
    __publicField(this, "_end");
    __publicField(this, "_hasPalette");
    __publicField(this, "_palette");
    __publicField(this, "_hasTransparency");
    __publicField(this, "_transparency");
    __publicField(this, "_compressionMethod");
    __publicField(this, "_filterMethod");
    __publicField(this, "_interlaceMethod");
    __publicField(this, "_colorType");
    __publicField(this, "_isAnimated");
    __publicField(this, "_numberOfFrames");
    __publicField(this, "_numberOfPlays");
    __publicField(this, "_frames");
    __publicField(this, "_writingDataChunks");
    const { checkCrc: checkCrc2 = false } = options;
    this._checkCrc = checkCrc2;
    this._inflator = new Inflate_1();
    this._png = {
      width: -1,
      height: -1,
      channels: -1,
      data: new Uint8Array(0),
      depth: 1,
      text: {}
    };
    this._apng = {
      width: -1,
      height: -1,
      channels: -1,
      depth: 1,
      numberOfFrames: 1,
      numberOfPlays: 0,
      text: {},
      frames: []
    };
    this._end = false;
    this._hasPalette = false;
    this._palette = [];
    this._hasTransparency = false;
    this._transparency = new Uint16Array(0);
    this._compressionMethod = CompressionMethod.UNKNOWN;
    this._filterMethod = FilterMethod.UNKNOWN;
    this._interlaceMethod = InterlaceMethod.UNKNOWN;
    this._colorType = ColorType.UNKNOWN;
    this._isAnimated = false;
    this._numberOfFrames = 1;
    this._numberOfPlays = 0;
    this._frames = [];
    this._writingDataChunks = false;
    this.setBigEndian();
  }
  decode() {
    checkSignature(this);
    while (!this._end) {
      const length = this.readUint32();
      const type = this.readChars(4);
      this.decodeChunk(length, type);
    }
    this.decodeImage();
    return this._png;
  }
  decodeApng() {
    checkSignature(this);
    while (!this._end) {
      const length = this.readUint32();
      const type = this.readChars(4);
      this.decodeApngChunk(length, type);
    }
    this.decodeApngImage();
    return this._apng;
  }
  // https://www.w3.org/TR/PNG/#5Chunk-layout
  decodeChunk(length, type) {
    const offset = this.offset;
    switch (type) {
      // 11.2 Critical chunks
      case "IHDR":
        this.decodeIHDR();
        break;
      case "PLTE":
        this.decodePLTE(length);
        break;
      case "IDAT":
        this.decodeIDAT(length);
        break;
      case "IEND":
        this._end = true;
        break;
      // 11.3 Ancillary chunks
      case "tRNS":
        this.decodetRNS(length);
        break;
      case "iCCP":
        this.decodeiCCP(length);
        break;
      case textChunkName:
        decodetEXt(this._png.text, this, length);
        break;
      case "pHYs":
        this.decodepHYs();
        break;
      default:
        this.skip(length);
        break;
    }
    if (this.offset - offset !== length) {
      throw new Error(`Length mismatch while decoding chunk ${type}`);
    }
    if (this._checkCrc) {
      checkCrc(this, length + 4, type);
    } else {
      this.skip(4);
    }
  }
  decodeApngChunk(length, type) {
    const offset = this.offset;
    if (type !== "fdAT" && type !== "IDAT" && this._writingDataChunks) {
      this.pushDataToFrame();
    }
    switch (type) {
      case "acTL":
        this.decodeACTL();
        break;
      case "fcTL":
        this.decodeFCTL();
        break;
      case "fdAT":
        this.decodeFDAT(length);
        break;
      default:
        this.decodeChunk(length, type);
        this.offset = offset + length;
        break;
    }
    if (this.offset - offset !== length) {
      throw new Error(`Length mismatch while decoding chunk ${type}`);
    }
    if (this._checkCrc) {
      checkCrc(this, length + 4, type);
    } else {
      this.skip(4);
    }
  }
  // https://www.w3.org/TR/PNG/#11IHDR
  decodeIHDR() {
    const image = this._png;
    image.width = this.readUint32();
    image.height = this.readUint32();
    image.depth = checkBitDepth(this.readUint8());
    const colorType = this.readUint8();
    this._colorType = colorType;
    let channels;
    switch (colorType) {
      case ColorType.GREYSCALE:
        channels = 1;
        break;
      case ColorType.TRUECOLOUR:
        channels = 3;
        break;
      case ColorType.INDEXED_COLOUR:
        channels = 1;
        break;
      case ColorType.GREYSCALE_ALPHA:
        channels = 2;
        break;
      case ColorType.TRUECOLOUR_ALPHA:
        channels = 4;
        break;
      // Kept for exhaustiveness.
      // eslint-disable-next-line unicorn/no-useless-switch-case
      case ColorType.UNKNOWN:
      default:
        throw new Error(`Unknown color type: ${colorType}`);
    }
    this._png.channels = channels;
    this._compressionMethod = this.readUint8();
    if (this._compressionMethod !== CompressionMethod.DEFLATE) {
      throw new Error(`Unsupported compression method: ${this._compressionMethod}`);
    }
    this._filterMethod = this.readUint8();
    this._interlaceMethod = this.readUint8();
  }
  decodeACTL() {
    this._numberOfFrames = this.readUint32();
    this._numberOfPlays = this.readUint32();
    this._isAnimated = true;
  }
  decodeFCTL() {
    const image = {
      sequenceNumber: this.readUint32(),
      width: this.readUint32(),
      height: this.readUint32(),
      xOffset: this.readUint32(),
      yOffset: this.readUint32(),
      delayNumber: this.readUint16(),
      delayDenominator: this.readUint16(),
      disposeOp: this.readUint8(),
      blendOp: this.readUint8(),
      data: new Uint8Array(0)
    };
    this._frames.push(image);
  }
  // https://www.w3.org/TR/PNG/#11PLTE
  decodePLTE(length) {
    if (length % 3 !== 0) {
      throw new RangeError(`PLTE field length must be a multiple of 3. Got ${length}`);
    }
    const l6 = length / 3;
    this._hasPalette = true;
    const palette = [];
    this._palette = palette;
    for (let i3 = 0; i3 < l6; i3++) {
      palette.push([this.readUint8(), this.readUint8(), this.readUint8()]);
    }
  }
  // https://www.w3.org/TR/PNG/#11IDAT
  decodeIDAT(length) {
    this._writingDataChunks = true;
    const dataLength = length;
    const dataOffset = this.offset + this.byteOffset;
    this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));
    if (this._inflator.err) {
      throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
    }
    this.skip(length);
  }
  decodeFDAT(length) {
    this._writingDataChunks = true;
    let dataLength = length;
    let dataOffset = this.offset + this.byteOffset;
    dataOffset += 4;
    dataLength -= 4;
    this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));
    if (this._inflator.err) {
      throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
    }
    this.skip(length);
  }
  // https://www.w3.org/TR/PNG/#11tRNS
  decodetRNS(length) {
    switch (this._colorType) {
      case ColorType.GREYSCALE:
      case ColorType.TRUECOLOUR: {
        if (length % 2 !== 0) {
          throw new RangeError(`tRNS chunk length must be a multiple of 2. Got ${length}`);
        }
        if (length / 2 > this._png.width * this._png.height) {
          throw new Error(`tRNS chunk contains more alpha values than there are pixels (${length / 2} vs ${this._png.width * this._png.height})`);
        }
        this._hasTransparency = true;
        this._transparency = new Uint16Array(length / 2);
        for (let i3 = 0; i3 < length / 2; i3++) {
          this._transparency[i3] = this.readUint16();
        }
        break;
      }
      case ColorType.INDEXED_COLOUR: {
        if (length > this._palette.length) {
          throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${length} vs ${this._palette.length})`);
        }
        let i3 = 0;
        for (; i3 < length; i3++) {
          const alpha = this.readByte();
          this._palette[i3].push(alpha);
        }
        for (; i3 < this._palette.length; i3++) {
          this._palette[i3].push(255);
        }
        break;
      }
      // Kept for exhaustiveness.
      /* eslint-disable unicorn/no-useless-switch-case */
      case ColorType.UNKNOWN:
      case ColorType.GREYSCALE_ALPHA:
      case ColorType.TRUECOLOUR_ALPHA:
      default: {
        throw new Error(`tRNS chunk is not supported for color type ${this._colorType}`);
      }
    }
  }
  // https://www.w3.org/TR/PNG/#11iCCP
  decodeiCCP(length) {
    const name = readKeyword(this);
    const compressionMethod = this.readUint8();
    if (compressionMethod !== CompressionMethod.DEFLATE) {
      throw new Error(`Unsupported iCCP compression method: ${compressionMethod}`);
    }
    const compressedProfile = this.readBytes(length - name.length - 2);
    this._png.iccEmbeddedProfile = {
      name,
      profile: inflate_1(compressedProfile)
    };
  }
  // https://www.w3.org/TR/PNG/#11pHYs
  decodepHYs() {
    const ppuX = this.readUint32();
    const ppuY = this.readUint32();
    const unitSpecifier = this.readByte();
    this._png.resolution = {
      x: ppuX,
      y: ppuY,
      unit: unitSpecifier
    };
  }
  decodeApngImage() {
    this._apng.width = this._png.width;
    this._apng.height = this._png.height;
    this._apng.channels = this._png.channels;
    this._apng.depth = this._png.depth;
    this._apng.numberOfFrames = this._numberOfFrames;
    this._apng.numberOfPlays = this._numberOfPlays;
    this._apng.text = this._png.text;
    this._apng.resolution = this._png.resolution;
    for (let i3 = 0; i3 < this._numberOfFrames; i3++) {
      const newFrame = {
        sequenceNumber: this._frames[i3].sequenceNumber,
        delayNumber: this._frames[i3].delayNumber,
        delayDenominator: this._frames[i3].delayDenominator,
        data: this._apng.depth === 8 ? new Uint8Array(this._apng.width * this._apng.height * this._apng.channels) : new Uint16Array(this._apng.width * this._apng.height * this._apng.channels)
      };
      const frame = this._frames.at(i3);
      if (frame) {
        frame.data = decodeInterlaceNull({
          data: frame.data,
          width: frame.width,
          height: frame.height,
          channels: this._apng.channels,
          depth: this._apng.depth
        });
        if (this._hasPalette) {
          this._apng.palette = this._palette;
        }
        if (this._hasTransparency) {
          this._apng.transparency = this._transparency;
        }
        if (i3 === 0 || frame.xOffset === 0 && frame.yOffset === 0 && frame.width === this._png.width && frame.height === this._png.height) {
          newFrame.data = frame.data;
        } else {
          const prevFrame = this._apng.frames.at(i3 - 1);
          this.disposeFrame(frame, prevFrame, newFrame);
          this.addFrameDataToCanvas(newFrame, frame);
        }
        this._apng.frames.push(newFrame);
      }
    }
    return this._apng;
  }
  disposeFrame(frame, prevFrame, imageFrame) {
    switch (frame.disposeOp) {
      case DisposeOpType.NONE:
        break;
      case DisposeOpType.BACKGROUND:
        for (let row = 0; row < this._png.height; row++) {
          for (let col = 0; col < this._png.width; col++) {
            const index = (row * frame.width + col) * this._png.channels;
            for (let channel = 0; channel < this._png.channels; channel++) {
              imageFrame.data[index + channel] = 0;
            }
          }
        }
        break;
      case DisposeOpType.PREVIOUS:
        imageFrame.data.set(prevFrame.data);
        break;
      default:
        throw new Error("Unknown disposeOp");
    }
  }
  addFrameDataToCanvas(imageFrame, frame) {
    const maxValue = 1 << this._png.depth;
    const calculatePixelIndices = (row, col) => {
      const index = ((row + frame.yOffset) * this._png.width + frame.xOffset + col) * this._png.channels;
      const frameIndex = (row * frame.width + col) * this._png.channels;
      return { index, frameIndex };
    };
    switch (frame.blendOp) {
      case BlendOpType.SOURCE:
        for (let row = 0; row < frame.height; row++) {
          for (let col = 0; col < frame.width; col++) {
            const { index, frameIndex } = calculatePixelIndices(row, col);
            for (let channel = 0; channel < this._png.channels; channel++) {
              imageFrame.data[index + channel] = frame.data[frameIndex + channel];
            }
          }
        }
        break;
      // https://www.w3.org/TR/png-3/#13Alpha-channel-processing
      case BlendOpType.OVER:
        for (let row = 0; row < frame.height; row++) {
          for (let col = 0; col < frame.width; col++) {
            const { index, frameIndex } = calculatePixelIndices(row, col);
            for (let channel = 0; channel < this._png.channels; channel++) {
              const sourceAlpha = frame.data[frameIndex + this._png.channels - 1] / maxValue;
              const foregroundValue = channel % (this._png.channels - 1) === 0 ? 1 : frame.data[frameIndex + channel];
              const value = Math.floor(sourceAlpha * foregroundValue + (1 - sourceAlpha) * imageFrame.data[index + channel]);
              imageFrame.data[index + channel] += value;
            }
          }
        }
        break;
      default:
        throw new Error("Unknown blendOp");
    }
  }
  decodeImage() {
    var _a4;
    if (this._inflator.err) {
      throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
    }
    const data = this._isAnimated ? ((_a4 = this._frames) == null ? void 0 : _a4.at(0)).data : this._inflator.result;
    if (this._filterMethod !== FilterMethod.ADAPTIVE) {
      throw new Error(`Filter method ${this._filterMethod} not supported`);
    }
    if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {
      this._png.data = decodeInterlaceNull({
        data,
        width: this._png.width,
        height: this._png.height,
        channels: this._png.channels,
        depth: this._png.depth
      });
    } else if (this._interlaceMethod === InterlaceMethod.ADAM7) {
      this._png.data = decodeInterlaceAdam7({
        data,
        width: this._png.width,
        height: this._png.height,
        channels: this._png.channels,
        depth: this._png.depth
      });
    } else {
      throw new Error(`Interlace method ${this._interlaceMethod} not supported`);
    }
    if (this._hasPalette) {
      this._png.palette = this._palette;
    }
    if (this._hasTransparency) {
      this._png.transparency = this._transparency;
    }
  }
  pushDataToFrame() {
    const result = this._inflator.result;
    const lastFrame = this._frames.at(-1);
    if (lastFrame) {
      lastFrame.data = result;
    } else {
      this._frames.push({
        sequenceNumber: 0,
        width: this._png.width,
        height: this._png.height,
        xOffset: 0,
        yOffset: 0,
        delayNumber: 0,
        delayDenominator: 0,
        disposeOp: DisposeOpType.NONE,
        blendOp: BlendOpType.SOURCE,
        data: result
      });
    }
    this._inflator = new Inflate_1();
    this._writingDataChunks = false;
  }
};
function checkBitDepth(value) {
  if (value !== 1 && value !== 2 && value !== 4 && value !== 8 && value !== 16) {
    throw new Error(`invalid bit depth: ${value}`);
  }
  return value;
}

// node_modules/fast-png/lib/index.js
function decodePng(data, options) {
  const decoder = new PngDecoder(data, options);
  return decoder.decode();
}

// node_modules/roslib/dist/RosLib.js
function ut(n2) {
  return n2 instanceof Object && "op" in n2 && typeof n2.op == "string";
}
function Qt(n2) {
  return n2.op === "status";
}
function _r3(n2) {
  return n2.op === "set_level";
}
function Jt(n2) {
  return n2.op === "fragment";
}
function Zt(n2) {
  return n2.op === "png";
}
function Sr(n2) {
  return n2.op === "advertise";
}
function Or(n2) {
  return n2.op === "unadvertise";
}
function Bt(n2) {
  return n2.op === "publish";
}
function Rr(n2) {
  return n2.op === "subscribe";
}
function Mr(n2) {
  return n2.op === "unsubscribe";
}
function xr(n2) {
  return n2.op === "advertise_service";
}
function Ir(n2) {
  return n2.op === "unadvertise_service";
}
function At(n2) {
  return n2.op === "call_service";
}
function Ft(n2) {
  return n2.op === "service_response";
}
function Br(n2) {
  return n2.op === "advertise_action";
}
function Fr(n2) {
  return n2.op === "unadvertise_action";
}
function Lt(n2) {
  return n2.op === "send_action_goal";
}
function Pt(n2) {
  return n2.op === "cancel_action_goal";
}
function kt(n2) {
  return n2.op === "action_feedback";
}
function Ut(n2) {
  return n2.op === "action_result";
}
var _e6, _t5, _r4, _re_instances, u_fn;
var re = class extends import_index.default {
  /**
   * @param options
   * @param options.ros - The ROSLIB.Ros connection handle.
   * @param options.name - The service name, like '/add_two_ints'.
   * @param options.serviceType - The service type, like 'rospy_tutorials/AddTwoInts'.
   */
  constructor({
    ros: t3,
    name: u2,
    serviceType: s4
  }) {
    super();
    __privateAdd(this, _re_instances);
    __privateAdd(this, _e6);
    __privateAdd(this, _t5);
    __privateAdd(this, _r4);
    __privateSet(this, _e6, null), this.isAdvertised = false, __privateSet(this, _t5, Promise.resolve()), __privateSet(this, _r4, false), this.ros = t3, this.name = u2, this.serviceType = s4;
  }
  /**
   * Call the service. Returns the service response in the
   * callback. Does nothing if this service is currently advertised.
   *
   * @param request - The service request to send.
   * @param [callback] - Function with the following params:
   * @param [failedCallback] - The callback function when the service call failed with params:
   * @param [timeout] - Optional timeout, in seconds, for the service call. A non-positive value means no timeout.
   *                             If not provided, the rosbridge server will use its default value.
   */
  callService(t3, u2, s4 = console.error, c4) {
    if (this.isAdvertised)
      return;
    const o5 = `call_service:${this.name}:${v4_default()}`;
    this.ros.once(o5, function(h4) {
      Ft(h4) && (h4.result ? u2 == null ? void 0 : u2(h4.values) : s4(h4.values ?? ""));
    }), this.ros.callOnConnection({
      op: "call_service",
      id: o5,
      service: this.name,
      args: t3,
      timeout: c4
    });
  }
  /**
   * Advertise the service. This turns the Service object from a client
   * into a server. The callback will be called with every request
   * that's made on this service.
   *
   * @param callback This works similarly to the callback for a C++ service in that you should take care not to overwrite the response object.
   *  Instead, only modify the values within.
   */
  async advertise(t3) {
    return __privateSet(this, _t5, __privateGet(this, _t5).then(() => {
      this.isAdvertised && __privateMethod(this, _re_instances, u_fn).call(this), __privateSet(this, _e6, (u2) => {
        if (!At(u2))
          throw new Error(
            `Invalid message received on service channel: ${JSON.stringify(u2)}`
          );
        const s4 = {};
        let c4;
        try {
          c4 = t3(u2.args, s4);
        } catch {
          c4 = false;
        }
        c4 ? this.ros.callOnConnection({
          op: "service_response",
          service: this.name,
          values: s4,
          result: c4,
          id: u2.id
        }) : this.ros.callOnConnection({
          op: "service_response",
          service: this.name,
          result: c4,
          id: u2.id
        });
      }), this.ros.on(this.name, __privateGet(this, _e6)), this.ros.callOnConnection({
        op: "advertise_service",
        type: this.serviceType,
        service: this.name
      }), this.isAdvertised = true;
    }).catch((u2) => {
      throw this.emit("error", u2), u2;
    })), __privateGet(this, _t5);
  }
  async unadvertise() {
    return __privateSet(this, _t5, __privateGet(this, _t5).then(() => {
      __privateMethod(this, _re_instances, u_fn).call(this);
    }).catch((t3) => {
      throw this.emit("error", t3), t3;
    })), __privateGet(this, _t5);
  }
  /**
   * An alternate form of Service advertisement that supports a modern Promise-based interface for use with async/await.
   * @param callback An asynchronous callback processing the request and returning a response.
   */
  async advertiseAsync(t3) {
    return __privateSet(this, _t5, __privateGet(this, _t5).then(() => {
      this.isAdvertised && __privateMethod(this, _re_instances, u_fn).call(this), __privateSet(this, _e6, (u2) => {
        if (!At(u2))
          throw new Error(
            `Invalid message received on service channel: ${JSON.stringify(u2)}`
          );
        (async () => {
          try {
            this.ros.callOnConnection({
              op: "service_response",
              service: this.name,
              result: true,
              values: await t3(u2.args),
              id: u2.id
            });
          } catch (s4) {
            this.ros.callOnConnection({
              op: "service_response",
              service: this.name,
              result: false,
              values: String(s4),
              id: u2.id
            });
          }
        })().catch(console.error);
      }), this.ros.on(this.name, __privateGet(this, _e6)), this.ros.callOnConnection({
        op: "advertise_service",
        type: this.serviceType,
        service: this.name
      }), this.isAdvertised = true;
    }).catch((u2) => {
      throw this.emit("error", u2), u2;
    })), __privateGet(this, _t5);
  }
};
_e6 = new WeakMap();
_t5 = new WeakMap();
_r4 = new WeakMap();
_re_instances = new WeakSet();
/**
 * Internal method to perform unadvertisement without queueing
 */
u_fn = function() {
  if (!(!this.isAdvertised || __privateGet(this, _r4))) {
    __privateSet(this, _r4, true);
    try {
      this.isAdvertised = false, __privateGet(this, _e6) && (this.ros.off(this.name, __privateGet(this, _e6)), __privateSet(this, _e6, null)), this.ros.callOnConnection({
        op: "unadvertise_service",
        service: this.name
      });
    } finally {
      __privateSet(this, _r4, false);
    }
  }
};
var _e7;
var fe = class extends import_index.default {
  /**
   * @param options
   * @param options.ros - The ROSLIB.Ros connection handle.
   * @param options.name - The topic name, like '/cmd_vel'.
   * @param options.messageType - The message type, like 'std_msgs/String'.
   * @param [options.compression=none] - The type of compression to use, like 'png', 'cbor', or 'cbor-raw'.
   * @param [options.throttle_rate=0] - The rate (in ms in between messages) at which to throttle the topics.
   * @param [options.queue_size=100] - The queue created at bridge side for re-publishing webtopics.
   * @param [options.latch=false] - Latch the topic when publishing.
   * @param [options.queue_length=0] - The queue length at bridge side used when subscribing.
   * @param [options.reconnect_on_close=true] - The flag to enable resubscription and readvertisement on close event.
   */
  constructor({
    ros: t3,
    name: u2,
    messageType: s4,
    compression: c4 = "none",
    throttle_rate: o5 = 0,
    latch: h4 = false,
    queue_size: v2 = 100,
    queue_length: f7 = 0,
    reconnect_on_close: g4 = true
  }) {
    super();
    __privateAdd(this, _e7);
    this.waitForReconnect = false, this.reconnectFunc = void 0, this.isAdvertised = false, this.subscribeId = null, __privateSet(this, _e7, (D2) => {
      if (Bt(D2))
        this.emit("message", D2.msg);
      else
        throw new Error(
          `Unexpected message on topic channel: ${JSON.stringify(D2)}`
        );
    }), this.ros = t3, this.name = u2, this.messageType = s4, this.compression = c4, this.throttle_rate = o5, this.latch = h4, this.queue_size = v2, this.queue_length = f7, this.reconnect_on_close = g4, this.compression && this.compression !== "png" && this.compression !== "cbor" && this.compression !== "cbor-raw" && this.compression !== "none" && (this.emit(
      "warning",
      `${this.compression} compression is not supported. No compression will be used.`
    ), this.compression = "none"), this.throttle_rate < 0 && (this.emit(
      "warning",
      `${this.throttle_rate.toString()} is not allowed. Set to 0`
    ), this.throttle_rate = 0), this.reconnect_on_close ? this.callForSubscribeAndAdvertise = (D2) => {
      this.ros.callOnConnection(D2), this.waitForReconnect = false, this.reconnectFunc = () => {
        this.waitForReconnect || (this.waitForReconnect = true, this.ros.callOnConnection(D2), this.ros.once("connection", () => {
          this.waitForReconnect = false;
        }));
      }, this.ros.on("close", this.reconnectFunc);
    } : this.callForSubscribeAndAdvertise = (D2) => {
      this.ros.callOnConnection(D2);
    };
  }
  /**
   * Every time a message is published for the given topic, the callback
   * will be called with the message object.
   *
   * @param callback - Function with the following params:
   */
  subscribe(t3) {
    this.on("message", t3), !this.subscribeId && (this.ros.on(this.name, __privateGet(this, _e7)), this.subscribeId = `subscribe:${this.name}:${v4_default()}`, this.callForSubscribeAndAdvertise({
      op: "subscribe",
      id: this.subscribeId,
      type: this.messageType,
      topic: this.name,
      compression: this.compression,
      throttle_rate: this.throttle_rate,
      queue_length: this.queue_length
    }));
  }
  /**
   * Unregister as a subscriber for the topic. Unsubscribing will stop
   * and remove all subscribe callbacks. To remove a callback, you must
   * explicitly pass the callback function in.
   *
   * @param [callback] - The callback to unregister, if
   *     provided and other listeners are registered the topic won't
   *     unsubscribe, just stop emitting to the passed listener.
   */
  unsubscribe(t3) {
    t3 && (this.off("message", t3), this.listeners("message").length) || this.subscribeId && (this.ros.off(this.name, __privateGet(this, _e7)), this.reconnect_on_close && this.ros.off("close", this.reconnectFunc), this.emit("unsubscribe"), this.ros.callOnConnection({
      op: "unsubscribe",
      id: this.subscribeId,
      topic: this.name
    }), this.subscribeId = null);
  }
  /**
   * Register as a publisher for the topic.
   */
  advertise() {
    this.isAdvertised || (this.advertiseId = `advertise:${this.name}:${v4_default()}`, this.callForSubscribeAndAdvertise({
      op: "advertise",
      id: this.advertiseId,
      type: this.messageType,
      topic: this.name,
      latch: this.latch,
      queue_size: this.queue_size
    }), this.isAdvertised = true, this.reconnect_on_close || this.ros.on("close", () => {
      this.isAdvertised = false;
    }));
  }
  /**
   * Unregister as a publisher for the topic.
   */
  unadvertise() {
    this.isAdvertised && (this.reconnect_on_close && this.ros.off("close", this.reconnectFunc), this.emit("unadvertise"), this.ros.callOnConnection({
      op: "unadvertise",
      id: this.advertiseId,
      topic: this.name
    }), this.isAdvertised = false);
  }
  /**
   * Publish the message.
   *
   * @param message - The message to publish.
   */
  publish(t3) {
    this.isAdvertised || this.advertise(), this.ros.callOnConnection({
      op: "publish",
      id: `publish:${this.name}:${v4_default()}`,
      topic: this.name,
      msg: t3
    });
  }
  /**
   * Retrieves list of publishers for this topic.
   *
   * @param callback - Function with the following params:
   *   * publishers - The list of publishers.
   * @param [failedCallback] - The callback function when the service call failed.
   */
  getPublishers(t3, u2 = console.error) {
    const s4 = new re({
      ros: this.ros,
      name: "/rosapi/publishers",
      serviceType: "rosapi/Publishers"
    }), c4 = {
      topic: this.name
    };
    s4.callService(
      c4,
      function(o5) {
        t3(o5.publishers);
      },
      function(o5) {
        u2(o5);
      }
    );
  }
};
_e7 = new WeakMap();
var Kt = class {
  /**
   * @param options
   * @param options.ros - The ROSLIB.Ros connection handle.
   * @param options.name - The param name, like max_vel_x.
   */
  constructor({ ros: t3, name: u2 }) {
    this.ros = t3, this.name = u2;
  }
  /**
   * Fetch the value of the param.
   *
   * @param callback - The callback function.
   * @param [failedCallback] - The callback function when the service call failed or the parameter retrieval was unsuccessful.
   */
  get(t3, u2 = console.error) {
    const s4 = new re({
      ros: this.ros,
      name: "rosapi/get_param",
      serviceType: "rosapi/GetParam"
    }), c4 = { name: this.name };
    s4.callService(
      c4,
      function(o5) {
        "successful" in o5 && !o5.successful ? u2(o5.reason) : t3(JSON.parse(o5.value));
      },
      u2
    );
  }
  /**
   * Set the value of the param in ROS.
   *
   * @param value - The value to set param to.
   * @param [callback] - The callback function.
   * @param [failedCallback] - The callback function when the service call failed or the parameter setting was unsuccessful.
   */
  set(t3, u2, s4 = console.error) {
    const c4 = new re({
      ros: this.ros,
      name: "rosapi/set_param",
      serviceType: "rosapi/SetParam"
    }), o5 = {
      name: this.name,
      value: JSON.stringify(t3)
    };
    c4.callService(
      o5,
      function(h4) {
        "successful" in h4 && !h4.successful ? s4(h4.reason) : u2 && u2(h4);
      },
      s4
    );
  }
  /**
   * Delete this parameter on the ROS server.
   *
   * @param callback - The callback function.
   * @param [failedCallback] - The callback function when the service call failed or the parameter deletion was unsuccessful.
   */
  delete(t3, u2 = console.error) {
    const s4 = new re({
      ros: this.ros,
      name: "rosapi/delete_param",
      serviceType: "rosapi/DeleteParam"
    }), c4 = {
      name: this.name
    };
    s4.callService(
      c4,
      function(o5) {
        "successful" in o5 && !o5.successful ? u2(o5.reason) : t3(o5);
      },
      u2
    );
  }
};
var qt = class extends import_index.default {
  /**
   * @param options
   * @param options.ros - The ROSLIB.Ros connection handle.
   * @param options.serverName - The action server name, like '/fibonacci'.
   * @param options.actionName - The action message name, like 'actionlib_tutorials/FibonacciAction'.
   * @param [options.timeout] - The timeout length when connecting to the action server.
   * @param [options.omitFeedback] - The flag to indicate whether to omit the feedback channel or not.
   * @param [options.omitStatus] - The flag to indicate whether to omit the status channel or not.
   * @param [options.omitResult] - The flag to indicate whether to omit the result channel or not.
   */
  constructor({
    ros: t3,
    serverName: u2,
    actionName: s4,
    timeout: c4,
    omitFeedback: o5,
    omitStatus: h4,
    omitResult: v2
  }) {
    super(), this.goals = {}, this.receivedStatus = false, this.ros = t3, this.serverName = u2, this.actionName = s4, this.timeout = c4, this.omitFeedback = o5, this.omitStatus = h4, this.omitResult = v2, this.feedbackListener = new fe({
      ros: this.ros,
      name: `${this.serverName}/feedback`,
      messageType: `${this.actionName}Feedback`
    }), this.statusListener = new fe({
      ros: this.ros,
      name: `${this.serverName}/status`,
      messageType: "actionlib_msgs/GoalStatusArray"
    }), this.resultListener = new fe({
      ros: this.ros,
      name: `${this.serverName}/result`,
      messageType: `${this.actionName}Result`
    }), this.goalTopic = new fe({
      ros: this.ros,
      name: `${this.serverName}/goal`,
      messageType: `${this.actionName}Goal`
    }), this.cancelTopic = new fe({
      ros: this.ros,
      name: `${this.serverName}/cancel`,
      messageType: "actionlib_msgs/GoalID"
    }), this.goalTopic.advertise(), this.cancelTopic.advertise(), this.omitStatus || this.statusListener.subscribe((f7) => {
      this.receivedStatus = true, f7.status_list.forEach((g4) => {
        const D2 = this.goals[g4.goal_id.id];
        D2 && D2.emit("status", g4);
      });
    }), this.omitFeedback || this.feedbackListener.subscribe((f7) => {
      const g4 = this.goals[f7.status.goal_id.id];
      g4 && (g4.emit("status", f7.status), g4.emit("feedback", f7.feedback));
    }), this.omitResult || this.resultListener.subscribe((f7) => {
      const g4 = this.goals[f7.status.goal_id.id];
      g4 && (g4.emit("status", f7.status), g4.emit("result", f7.result));
    }), this.timeout && setTimeout(() => {
      this.receivedStatus || this.emit("timeout");
    }, this.timeout);
  }
  /**
   * Cancel all goals associated with this ActionClient.
   */
  cancel() {
    const t3 = {};
    this.cancelTopic.publish(t3);
  }
  /**
   * Unsubscribe and unadvertise all topics associated with this ActionClient.
   */
  dispose() {
    this.goalTopic.unadvertise(), this.cancelTopic.unadvertise(), this.omitStatus || this.statusListener.unsubscribe(), this.omitFeedback || this.feedbackListener.unsubscribe(), this.omitResult || this.resultListener.unsubscribe();
  }
};
var er = class extends import_index.default {
  /**
   * @param options
   * @param options.actionClient - The ROSLIB.ActionClient to use with this goal.
   * @param options.goalMessage - The JSON object containing the goal for the action server.
   */
  constructor({
    actionClient: t3,
    goalMessage: u2
  }) {
    super(), this.isFinished = false, this.status = void 0, this.result = void 0, this.feedback = void 0, this.goalID = `goal_${v4_default()}`, this.actionClient = t3, this.goalMessage = {
      goal_id: {
        stamp: {
          secs: 0,
          nsecs: 0
        },
        id: this.goalID
      },
      goal: u2
    }, this.on("status", (s4) => {
      this.status = s4;
    }), this.on("result", (s4) => {
      this.isFinished = true, this.result = s4;
    }), this.on("feedback", (s4) => {
      this.feedback = s4;
    }), this.actionClient.goals[this.goalID] = this;
  }
  /**
   * Send the goal to the action server.
   *
   * @param [timeout] - A timeout length for the goal's result.
   */
  send(t3) {
    this.actionClient.goalTopic.publish(this.goalMessage), t3 && setTimeout(() => {
      this.isFinished || this.emit("timeout");
    }, t3);
  }
  /**
   * Cancel the current goal.
   */
  cancel() {
    const t3 = {
      id: this.goalID
    };
    this.actionClient.cancelTopic.publish(t3);
  }
};
var Oe = class _Oe {
  constructor(t3) {
    this.x = (t3 == null ? void 0 : t3.x) ?? 0, this.y = (t3 == null ? void 0 : t3.y) ?? 0, this.z = (t3 == null ? void 0 : t3.z) ?? 0;
  }
  /**
   * Set the values of this vector to the sum of itself and the given vector.
   *
   * @param v - The vector to add with.
   */
  add(t3) {
    this.x += t3.x, this.y += t3.y, this.z += t3.z;
  }
  /**
   * Set the values of this vector to the difference of itself and the given vector.
   *
   * @param v - The vector to subtract with.
   */
  subtract(t3) {
    this.x -= t3.x, this.y -= t3.y, this.z -= t3.z;
  }
  /**
   * Multiply the given Quaternion with this vector.
   *
   * @param q - The quaternion to multiply with.
   */
  multiplyQuaternion(t3) {
    const u2 = t3.w * this.x + t3.y * this.z - t3.z * this.y, s4 = t3.w * this.y + t3.z * this.x - t3.x * this.z, c4 = t3.w * this.z + t3.x * this.y - t3.y * this.x, o5 = -t3.x * this.x - t3.y * this.y - t3.z * this.z;
    this.x = u2 * t3.w + o5 * -t3.x + s4 * -t3.z - c4 * -t3.y, this.y = s4 * t3.w + o5 * -t3.y + c4 * -t3.x - u2 * -t3.z, this.z = c4 * t3.w + o5 * -t3.z + u2 * -t3.y - s4 * -t3.x;
  }
  /**
   * Clone a copy of this vector.
   *
   * @returns The cloned vector.
   */
  clone() {
    return new _Oe(this);
  }
};
var Qe = class _Qe {
  constructor(t3) {
    this.x = (t3 == null ? void 0 : t3.x) ?? 0, this.y = (t3 == null ? void 0 : t3.y) ?? 0, this.z = (t3 == null ? void 0 : t3.z) ?? 0, this.w = typeof (t3 == null ? void 0 : t3.w) == "number" ? t3.w : 1;
  }
  /**
   * Perform a conjugation on this quaternion.
   */
  conjugate() {
    this.x *= -1, this.y *= -1, this.z *= -1;
  }
  /**
   * Return the norm of this quaternion.
   */
  norm() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  /**
   * Perform a normalization on this quaternion.
   */
  normalize() {
    let t3 = Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
    t3 === 0 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 1) : (t3 = 1 / t3, this.x = this.x * t3, this.y = this.y * t3, this.z = this.z * t3, this.w = this.w * t3);
  }
  /**
   * Convert this quaternion into its inverse.
   */
  invert() {
    this.conjugate(), this.normalize();
  }
  /**
   * Set the values of this quaternion to the product of itself and the given quaternion.
   *
   * @param q - The quaternion to multiply with.
   */
  multiply(t3) {
    const u2 = this.x * t3.w + this.y * t3.z - this.z * t3.y + this.w * t3.x, s4 = -this.x * t3.z + this.y * t3.w + this.z * t3.x + this.w * t3.y, c4 = this.x * t3.y - this.y * t3.x + this.z * t3.w + this.w * t3.z, o5 = -this.x * t3.x - this.y * t3.y - this.z * t3.z + this.w * t3.w;
    this.x = u2, this.y = s4, this.z = c4, this.w = o5;
  }
  /**
   * Clone a copy of this quaternion.
   *
   * @returns The cloned quaternion.
   */
  clone() {
    return new _Qe(this);
  }
};
var vt = class _vt {
  constructor(t3) {
    this.translation = new Oe(t3.translation), this.rotation = new Qe(t3.rotation);
  }
  /**
   * Clone a copy of this transform.
   *
   * @returns The cloned transform.
   */
  clone() {
    return new _vt(this);
  }
};
var Gt = class {
  /**
   * @param options
   * @param options.ros - The ROSLIB.Ros connection handle.
   * @param [options.fixedFrame=base_link] - The fixed frame.
   * @param [options.angularThres=2.0] - The angular threshold for the TF republisher.
   * @param [options.transThres=0.01] - The translation threshold for the TF republisher.
   * @param [options.rate=10.0] - The rate for the TF republisher.
   * @param [options.updateDelay=50] - The time (in ms) to wait after a new subscription
   *     to update the TF republisher's list of TFs.
   * @param [options.topicTimeout=2.0] - The timeout parameter for the TF republisher.
   * @param [options.serverName="/tf2_web_republisher"] - The name of the tf2_web_republisher server.
   */
  constructor({
    ros: t3,
    fixedFrame: u2 = "base_link",
    angularThres: s4 = 2,
    transThres: c4 = 0.01,
    rate: o5 = 10,
    updateDelay: h4 = 50,
    topicTimeout: v2 = 2,
    serverName: f7 = "/tf2_web_republisher"
  }) {
    this.frameInfos = {}, this.republisherUpdateRequested = false, this.ros = t3, this.fixedFrame = u2, this.angularThres = s4, this.transThres = c4, this.rate = o5, this.updateDelay = h4;
    const g4 = v2, D2 = Math.floor(g4), p4 = Math.floor((g4 - D2) * 1e9);
    this.topicTimeout = {
      secs: D2,
      nsecs: p4
    }, this.serverName = f7;
  }
  /**
   * Process the incoming TF message and send them out using the callback
   * functions.
   *
   * @param tf - The TF message from the server.
   */
  processTFArray(t3) {
    t3.transforms.forEach((u2) => {
      let s4 = u2.child_frame_id;
      s4.startsWith("/") && (s4 = s4.substring(1));
      const c4 = this.frameInfos[s4];
      if (c4) {
        const o5 = new vt({
          translation: u2.transform.translation,
          rotation: u2.transform.rotation
        });
        c4.transform = o5, c4.cbs.forEach((h4) => {
          h4(o5);
        });
      }
    }, this);
  }
  /**
   * Create and send a new goal (or service request) to the tf2_web_republisher
   * based on the current list of TFs.
   * This method should be overridden by subclasses.
   */
  updateGoal() {
    throw new Error("updateGoal() must be implemented by subclass");
  }
  /**
   * Subscribe to the given TF frame.
   *
   * @param frameID - The TF frame to subscribe to.
   * @param callback - Function with the following params:
   */
  subscribe(t3, u2) {
    var _a4, _b2;
    t3.startsWith("/") && (t3 = t3.substring(1)), this.frameInfos[t3] || (this.frameInfos[t3] = {
      cbs: []
    }, this.republisherUpdateRequested || (setTimeout(() => {
      this.updateGoal();
    }, this.updateDelay), this.republisherUpdateRequested = true));
    const s4 = (_a4 = this.frameInfos[t3]) == null ? void 0 : _a4.transform;
    s4 && u2(s4), (_b2 = this.frameInfos[t3]) == null ? void 0 : _b2.cbs.push(u2);
  }
  /**
   * Unsubscribe from the given TF frame.
   *
   * @param frameID - The TF frame to unsubscribe from.
   * @param [callback] - The callback function to remove.
   */
  unsubscribe(t3, u2) {
    t3.startsWith("/") && (t3 = t3.substring(1));
    const s4 = this.frameInfos[t3];
    for (var c4 = (s4 == null ? void 0 : s4.cbs) ?? [], o5 = c4.length; o5--; )
      c4[o5] === u2 && c4.splice(o5, 1);
    (!u2 || c4.length === 0) && delete this.frameInfos[t3];
  }
};
var _e8, _t6;
var tr = class extends Gt {
  /**
   * @param options
   * @param options.ros - The ROSLIB.Ros connection handle.
   * @param [options.fixedFrame=base_link] - The fixed frame.
   * @param [options.angularThres=2.0] - The angular threshold for the TF republisher.
   * @param [options.transThres=0.01] - The translation threshold for the TF republisher.
   * @param [options.rate=10.0] - The rate for the TF republisher.
   * @param [options.updateDelay=50] - The time (in ms) to wait after a new subscription
   *     to update the TF republisher's list of TFs.
   * @param [options.topicTimeout=2.0] - The timeout parameter for the TF republisher.
   * @param [options.serverName="/tf2_web_republisher"] - The name of the tf2_web_republisher server.
   */
  constructor(t3) {
    super(t3);
    __privateAdd(this, _e8);
    __privateAdd(this, _t6);
    this.currentGoal = false, this.currentTopic = false, __privateSet(this, _e8, void 0), __privateSet(this, _t6, false), this.actionClient = new qt({
      ros: this.ros,
      serverName: this.serverName,
      actionName: "tf2_web_republisher/TFSubscriptionAction",
      omitStatus: true,
      omitResult: true
    });
  }
  /**
   * Create and send a new goal (or service request) to the tf2_web_republisher
   * based on the current list of TFs.
   */
  updateGoal() {
    const t3 = {
      source_frames: Object.keys(this.frameInfos),
      target_frame: this.fixedFrame,
      angular_thres: this.angularThres,
      trans_thres: this.transThres,
      rate: this.rate
    };
    this.currentGoal && this.currentGoal.cancel(), this.currentGoal = new er({
      actionClient: this.actionClient,
      goalMessage: t3
    }), this.currentGoal.on("feedback", (u2) => {
      this.processTFArray(u2);
    }), this.currentGoal.send(), this.republisherUpdateRequested = false;
  }
  /**
   * Process the service response and subscribe to the tf republisher
   * topic.
   *
   * @param response - The service response containing the topic name.
   */
  processResponse(t3) {
    __privateGet(this, _t6) || (this.currentTopic && this.currentTopic.unsubscribe(__privateGet(this, _e8)), this.currentTopic = new fe({
      ros: this.ros,
      name: t3.topic_name,
      messageType: "tf2_web_republisher/TFArray"
    }), __privateSet(this, _e8, (u2) => {
      this.processTFArray(u2);
    }), this.currentTopic.subscribe(__privateGet(this, _e8)));
  }
  /**
   * Unsubscribe and unadvertise all topics associated with this TFClient.
   */
  dispose() {
    __privateSet(this, _t6, true), this.actionClient.dispose(), this.currentTopic && this.currentTopic.unsubscribe(__privateGet(this, _e8));
  }
};
_e8 = new WeakMap();
_t6 = new WeakMap();
var rr = class extends import_index.default {
  /**
   * @param options
   * @param options.ros - The ROSLIB.Ros connection handle.
   * @param options.serverName - The action server name, like '/fibonacci'.
   * @param options.actionName - The action message name, like 'actionlib_tutorials/FibonacciAction'.
   */
  constructor({
    ros: t3,
    serverName: u2,
    actionName: s4
  }) {
    super(), this.currentGoal = null, this.nextGoal = null, this.ros = t3, this.serverName = u2, this.actionName = s4, this.feedbackPublisher = new fe({
      ros: this.ros,
      name: `${this.serverName}/feedback`,
      messageType: `${this.actionName}Feedback`
    }), this.feedbackPublisher.advertise();
    const c4 = new fe({
      ros: this.ros,
      name: `${this.serverName}/status`,
      messageType: "actionlib_msgs/GoalStatusArray"
    });
    c4.advertise(), this.resultPublisher = new fe({
      ros: this.ros,
      name: `${this.serverName}/result`,
      messageType: `${this.actionName}Result`
    }), this.resultPublisher.advertise();
    const o5 = new fe({
      ros: this.ros,
      name: `${this.serverName}/goal`,
      messageType: `${this.actionName}Goal`
    }), h4 = new fe({
      ros: this.ros,
      name: `${this.serverName}/cancel`,
      messageType: "actionlib_msgs/GoalID"
    });
    this.statusMessage = {
      header: {
        stamp: { secs: 0, nsecs: 100 },
        frame_id: ""
      },
      /** @type {{goal_id: any, status: number}[]} */
      status_list: []
    }, o5.subscribe((f7) => {
      this.currentGoal ? (this.nextGoal = f7, this.emit("cancel")) : (this.statusMessage.status_list = [
        { goal_id: f7.goal_id, status: 1 }
      ], this.currentGoal = f7, this.emit("goal", f7.goal));
    });
    const v2 = function(f7, g4) {
      return f7.secs > g4.secs ? false : f7.secs < g4.secs ? true : f7.nsecs < g4.nsecs;
    };
    h4.subscribe((f7) => {
      f7.stamp.secs === 0 && f7.stamp.nsecs === 0 && f7.id === "" ? (this.nextGoal = null, this.currentGoal && this.emit("cancel")) : (this.currentGoal && f7.id === this.currentGoal.goal_id.id ? this.emit("cancel") : this.nextGoal && f7.id === this.nextGoal.goal_id.id && (this.nextGoal = null), this.nextGoal && v2(this.nextGoal.goal_id.stamp, f7.stamp) && (this.nextGoal = null), this.currentGoal && v2(this.currentGoal.goal_id.stamp, f7.stamp) && this.emit("cancel"));
    }), setInterval(() => {
      const f7 = /* @__PURE__ */ new Date(), g4 = Math.floor(f7.getTime() / 1e3), D2 = Math.round(
        1e9 * (f7.getTime() / 1e3 - g4)
      );
      this.statusMessage.header = {
        ...this.statusMessage.header,
        stamp: { secs: g4, nsecs: D2 }
      }, c4.publish(this.statusMessage);
    }, 500);
  }
  /**
   * Set action state to succeeded and return to client.
   *
   * @param result - The result to return to the client.
   */
  setSucceeded(t3) {
    if (this.currentGoal !== null) {
      const u2 = {
        status: { goal_id: this.currentGoal.goal_id, status: 3 },
        result: t3
      };
      this.resultPublisher.publish(u2), this.statusMessage.status_list = [], this.nextGoal ? (this.currentGoal = this.nextGoal, this.nextGoal = null, this.emit("goal", this.currentGoal.goal)) : this.currentGoal = null;
    }
  }
  /**
   * Set action state to aborted and return to client.
   *
   * @param result - The result to return to the client.
   */
  setAborted(t3) {
    if (this.currentGoal !== null) {
      const u2 = {
        status: { goal_id: this.currentGoal.goal_id, status: 4 },
        result: t3
      };
      this.resultPublisher.publish(u2), this.statusMessage.status_list = [], this.nextGoal ? (this.currentGoal = this.nextGoal, this.nextGoal = null, this.emit("goal", this.currentGoal.goal)) : this.currentGoal = null;
    }
  }
  /**
   * Send a feedback message.
   *
   * @param feedback - The feedback to send to the client.
   */
  sendFeedback(t3) {
    if (this.currentGoal !== null) {
      const u2 = {
        status: { goal_id: this.currentGoal.goal_id, status: 1 },
        feedback: t3
      };
      this.feedbackPublisher.publish(u2);
    }
  }
  /**
   * Handle case where client requests preemption.
   */
  setPreempted() {
    if (this.currentGoal !== null) {
      this.statusMessage.status_list = [];
      const t3 = {
        status: { goal_id: this.currentGoal.goal_id, status: 2 }
      };
      this.resultPublisher.publish(t3), this.nextGoal ? (this.currentGoal = this.nextGoal, this.nextGoal = null, this.emit("goal", this.currentGoal.goal)) : this.currentGoal = null;
    }
  }
};
var ur = async (n2) => {
  if (typeof WebSocket == "function") {
    const o5 = await import("./NativeWebSocketTransport-CF_ebnyS-A2BKWWJA.js"), { NativeWebSocketTransport: h4 } = o5, v2 = new WebSocket(n2);
    return v2.binaryType = "arraybuffer", new h4(v2);
  }
  const t3 = await import("./browser-Y3XCGJDG.js"), u2 = await import("./WsWebSocketTransport-6-v9C0gj-KCR7VURK.js"), { WsWebSocketTransport: s4 } = u2, c4 = new t3.WebSocket(n2);
  return c4.binaryType = "arraybuffer", new s4(c4);
};
var _e9;
var Lr = class extends import_index.default {
  constructor({
    url: t3,
    transportFactory: u2 = ur
  } = {}) {
    super();
    // private write, public read via getter method
    __privateAdd(this, _e9);
    __privateSet(this, _e9, false), this.transportFactory = u2, t3 && this.connect(t3).catch(console.error);
  }
  get isConnected() {
    return __privateGet(this, _e9);
  }
  async connect(t3) {
    if (this.transport && !this.transport.isClosed())
      return;
    const u2 = await this.transportFactory(t3);
    this.transport = u2, u2.on("open", (s4) => {
      __privateSet(this, _e9, true), this.emit("connection", s4);
    }), u2.on("close", (s4) => {
      __privateSet(this, _e9, false), this.emit("close", s4);
    }), u2.on("error", (s4) => {
      this.emit("error", s4);
    }), u2.on("message", (s4) => {
      this.handleMessage(s4);
    });
  }
  close() {
    var _a4;
    (_a4 = this.transport) == null ? void 0 : _a4.close();
  }
  handleMessage(t3) {
    Bt(t3) ? this.emit(t3.topic, t3) : Ft(t3) ? t3.id ? this.emit(t3.id, t3) : console.error("Received service response without ID") : At(t3) ? this.emit(t3.service, t3) : Lt(t3) ? this.emit(t3.action, t3) : Pt(t3) ? this.emit(t3.id, t3) : kt(t3) ? this.emit(t3.id, t3) : Ut(t3) ? this.emit(t3.id, t3) : Qt(t3) && (t3.id ? this.emit(`status:${t3.id}`, t3) : this.emit("status", t3));
  }
  /**
   * Send an authorization request to the server.
   *
   * @param mac - MAC (hash) string given by the trusted source.
   * @param client - IP of the client.
   * @param dest - IP of the destination.
   * @param rand - Random string given by the trusted source.
   * @param t - Time of the authorization request.
   * @param level - User level as a string given by the client.
   * @param end - End time of the client's session.
   */
  authenticate(t3, u2, s4, c4, o5, h4, v2) {
    this.callOnConnection({
      op: "auth",
      mac: t3,
      client: u2,
      dest: s4,
      rand: c4,
      t: o5,
      level: h4,
      end: v2
    });
  }
  /**
   * Sends the message to the transport.
   * If not connected, queues the message to send once reconnected.
   */
  callOnConnection(t3) {
    var _a4;
    this.isConnected ? (_a4 = this.transport) == null ? void 0 : _a4.send(t3) : this.once("connection", () => {
      var _a5;
      (_a5 = this.transport) == null ? void 0 : _a5.send(t3);
    });
  }
  /**
   * Send a set_level request to the server.
   *
   * @param level - Status level (none, error, warning, info).
   * @param [id] - Operation ID to change status level on.
   */
  setStatusLevel(t3, u2) {
    const s4 = {
      op: "set_level",
      level: t3,
      id: u2
    };
    this.callOnConnection(s4);
  }
  /**
   * Retrieve a list of action servers in ROS as an array of string.
   *
   * @param callback - Function with the following params:
   * @param [failedCallback] - The callback function when the service call failed with params:
   */
  getActionServers(t3, u2 = console.error) {
    const s4 = new re({
      ros: this,
      name: "rosapi/action_servers",
      serviceType: "rosapi/GetActionServers"
    }), c4 = {};
    s4.callService(
      c4,
      function(o5) {
        t3(o5.action_servers);
      },
      function(o5) {
        u2(o5);
      }
    );
  }
  /**
   * Retrieve a list of topics in ROS as an array.
   *
   * @param callback - Function with the following params:
   * @param [failedCallback] - The callback function when the service call failed with params:
   */
  getTopics(t3, u2 = console.error) {
    const s4 = new re({
      ros: this,
      name: "rosapi/topics",
      serviceType: "rosapi/Topics"
    }), c4 = {};
    s4.callService(
      c4,
      function(o5) {
        t3(o5);
      },
      function(o5) {
        u2(o5);
      }
    );
  }
  /**
   * Retrieve a list of topics in ROS as an array of a specific type.
   *
   * @param topicType - The topic type to find.
   * @param callback - Function with the following params:
   * @param [failedCallback] - The callback function when the service call failed with params:
   */
  getTopicsForType(t3, u2, s4 = console.error) {
    const c4 = new re({
      ros: this,
      name: "rosapi/topics_for_type",
      serviceType: "rosapi/TopicsForType"
    }), o5 = {
      type: t3
    };
    c4.callService(
      o5,
      function(h4) {
        u2(h4.topics);
      },
      function(h4) {
        s4(h4);
      }
    );
  }
  /**
   * Retrieve a list of active service names in ROS.
   *
   * @param callback - Function with the following params:
   * @param [failedCallback] - The callback function when the service call failed with params:
   */
  getServices(t3, u2 = console.error) {
    const s4 = new re({
      ros: this,
      name: "rosapi/services",
      serviceType: "rosapi/Services"
    }), c4 = {};
    s4.callService(
      c4,
      function(o5) {
        t3(o5.services);
      },
      function(o5) {
        u2(o5);
      }
    );
  }
  /**
   * Retrieve a list of services in ROS as an array as specific type.
   *
   * @param serviceType - The service type to find.
   * @param callback - Function with the following params:
   * @param [failedCallback] - The callback function when the service call failed with params:
   */
  getServicesForType(t3, u2, s4 = console.error) {
    const c4 = new re({
      ros: this,
      name: "rosapi/services_for_type",
      serviceType: "rosapi/ServicesForType"
    }), o5 = {
      type: t3
    };
    c4.callService(
      o5,
      function(h4) {
        u2(h4.services);
      },
      function(h4) {
        s4(h4);
      }
    );
  }
  /**
   * Retrieve the details of a ROS service request.
   *
   * @param type - The type of the service.
   * @param callback - Function with the following params:
   * @param [failedCallback] - The callback function when the service call failed with params:
   */
  getServiceRequestDetails(t3, u2, s4 = console.error) {
    const c4 = new re({
      ros: this,
      name: "rosapi/service_request_details",
      serviceType: "rosapi/ServiceRequestDetails"
    }), o5 = {
      type: t3
    };
    c4.callService(
      o5,
      function(h4) {
        u2(h4);
      },
      function(h4) {
        s4(h4);
      }
    );
  }
  /**
   * Retrieve the details of a ROS service response.
   *
   * @param type - The type of the service.
   * @param callback - Function with the following params:
   * @param [failedCallback] - The callback function when the service call failed with params:
   */
  getServiceResponseDetails(t3, u2, s4 = console.error) {
    const c4 = new re({
      ros: this,
      name: "rosapi/service_response_details",
      serviceType: "rosapi/ServiceResponseDetails"
    }), o5 = {
      type: t3
    };
    c4.callService(
      o5,
      function(h4) {
        u2(h4);
      },
      function(h4) {
        s4(h4);
      }
    );
  }
  /**
   * Retrieve a list of active node names in ROS.
   *
   * @param callback - Function with the following params:
   * @param [failedCallback] - The callback function when the service call failed with params:
   */
  getNodes(t3, u2 = console.error) {
    const s4 = new re({
      ros: this,
      name: "rosapi/nodes",
      serviceType: "rosapi/Nodes"
    }), c4 = {};
    s4.callService(
      c4,
      function(o5) {
        t3(o5.nodes);
      },
      function(o5) {
        u2(o5);
      }
    );
  }
  /**
   * Retrieve a list of subscribed topics, publishing topics and services of a specific node.
   *
   * @param node - Name of the node.
   */
  getNodeDetails(t3, u2, s4 = console.error) {
    new re({
      ros: this,
      name: "rosapi/node_details",
      serviceType: "rosapi/NodeDetails"
    }).callService({ node: t3 }, u2, s4);
  }
  /**
   * Retrieve a list of parameter names from the ROS Parameter Server.
   *
   * @param callback - Function with the following params:
   * @param failedCallback - The callback function when the service call failed with params:
   */
  getParams(t3, u2 = console.error) {
    const s4 = new re({
      ros: this,
      name: "rosapi/get_param_names",
      serviceType: "rosapi/GetParamNames"
    }), c4 = {};
    s4.callService(
      c4,
      function(o5) {
        t3(o5.names);
      },
      function(o5) {
        u2(o5);
      }
    );
  }
  /**
   * Retrieve the type of a ROS topic.
   *
   * @param topic - Name of the topic.
   * @param callback - Function with the following params:
   * @param [failedCallback] - The callback function when the service call failed with params:
   */
  getTopicType(t3, u2, s4 = console.error) {
    const c4 = new re({
      ros: this,
      name: "rosapi/topic_type",
      serviceType: "rosapi/TopicType"
    }), o5 = {
      topic: t3
    };
    c4.callService(
      o5,
      function(h4) {
        u2(h4.type);
      },
      function(h4) {
        s4(h4);
      }
    );
  }
  /**
   * Retrieve the type of a ROS service.
   *
   * @param service - Name of the service.
   * @param callback - Function with the following params:
   * @param [failedCallback] - The callback function when the service call failed with params:
   */
  getServiceType(t3, u2, s4 = console.error) {
    const c4 = new re({
      ros: this,
      name: "rosapi/service_type",
      serviceType: "rosapi/ServiceType"
    }), o5 = {
      service: t3
    };
    c4.callService(
      o5,
      function(h4) {
        u2(h4.type);
      },
      function(h4) {
        s4(h4);
      }
    );
  }
  /**
   * Retrieve the details of a ROS message.
   *
   * @param message - The name of the message type.
   * @param callback - Function with the following params:
   * @param [failedCallback] - The callback function when the service call failed with params:
   */
  getMessageDetails(t3, u2, s4 = console.error) {
    const c4 = new re({
      ros: this,
      name: "rosapi/message_details",
      serviceType: "rosapi/MessageDetails"
    }), o5 = {
      type: t3
    };
    c4.callService(
      o5,
      function(h4) {
        u2(h4.typedefs);
      },
      function(h4) {
        s4(h4);
      }
    );
  }
  /**
   * Decode a typedef array into a dictionary like `rosmsg show foo/bar`.
   *
   * @param defs - Array of type_def dictionary.
   */
  decodeTypeDefs(t3) {
    const u2 = (s4, c4) => {
      const o5 = {};
      for (let h4 = 0; h4 < s4.fieldnames.length; h4++) {
        const v2 = s4.fieldarraylen[h4], f7 = s4.fieldnames[h4], g4 = s4.fieldtypes[h4];
        if (f7 === void 0 || g4 === void 0)
          throw new Error(
            "Received mismatched type definition vector lengths!"
          );
        if (!g4.includes("/"))
          v2 === -1 ? o5[f7] = g4 : o5[f7] = [g4];
        else {
          let D2;
          for (const p4 of c4)
            if (p4.type === g4) {
              D2 = p4;
              break;
            }
          if (D2) {
            const p4 = u2(D2, c4);
            v2 === -1 ? o5[f7] = p4 : o5[f7] = [p4];
          } else
            this.emit("error", `Cannot find ${g4} in decodeTypeDefs`);
        }
      }
      return o5;
    };
    return t3[0] ? u2(t3[0], t3) : {};
  }
  /**
   * @callback getTopicsAndRawTypesCallback
   * @param {Object} result - The result object with the following params:
   * @param {string[]} result.topics - Array of topic names.
   * @param {string[]} result.types - Array of message type names.
   * @param {string[]} result.typedefs_full_text - Array of full definitions of message types, similar to `gendeps --cat`.
   */
  /**
   * @callback getTopicsAndRawTypesFailedCallback
   * @param {string} error - The error message reported by ROS.
   */
  /**
   * Retrieve a list of topics and their associated type definitions.
   *
   * @param callback - Function with the following params:
   * @param [failedCallback] - The callback function when the service call failed with params:
   */
  getTopicsAndRawTypes(t3, u2 = console.error) {
    const s4 = new re({
      ros: this,
      name: "rosapi/topics_and_raw_types",
      serviceType: "rosapi/TopicsAndRawTypes"
    }), c4 = {};
    s4.callService(
      c4,
      function(o5) {
        t3(o5);
      },
      function(o5) {
        u2(o5);
      }
    );
  }
  Topic(t3) {
    return new fe({ ros: this, ...t3 });
  }
  Param(t3) {
    return new Kt({ ros: this, ...t3 });
  }
  Service(t3) {
    return new re({ ros: this, ...t3 });
  }
  TFClient(t3) {
    return new tr({ ros: this, ...t3 });
  }
  ActionClient(t3) {
    return new qt({
      ros: this,
      ...t3
    });
  }
  SimpleActionServer(t3) {
    return new rr({
      ros: this,
      ...t3
    });
  }
};
_e9 = new WeakMap();
var Be = ((n2) => (n2[n2.STATUS_UNKNOWN = 0] = "STATUS_UNKNOWN", n2[n2.STATUS_ACCEPTED = 1] = "STATUS_ACCEPTED", n2[n2.STATUS_EXECUTING = 2] = "STATUS_EXECUTING", n2[n2.STATUS_CANCELING = 3] = "STATUS_CANCELING", n2[n2.STATUS_SUCCEEDED = 4] = "STATUS_SUCCEEDED", n2[n2.STATUS_CANCELED = 5] = "STATUS_CANCELED", n2[n2.STATUS_ABORTED = 6] = "STATUS_ABORTED", n2))(Be || {});
var Nt = class extends Error {
  constructor(t3, u2) {
    super(`${ir(t3)}${u2 ? `: ${u2}` : ""}`), this.name = "GoalError";
  }
};
function ir(n2) {
  switch (n2) {
    case Be.STATUS_CANCELED:
      return "Action was canceled";
    case Be.STATUS_ABORTED:
      return "Action was aborted";
    case Be.STATUS_CANCELING:
      return "Action is canceling";
    case Be.STATUS_UNKNOWN:
      return "Action status unknown";
    default:
      return `Action failed with status ${String(n2)}`;
  }
}
var _e10, _t7, _nr_instances, r_fn2;
var nr = class {
  /**
   * @param options
   * @param options.ros - The ROSLIB.Ros connection handle.
   * @param options.name - The action name, like '/fibonacci'.
   * @param options.actionType - The action type, like 'example_interfaces/Fibonacci'.
   */
  constructor({
    ros: t3,
    name: u2,
    actionType: s4
  }) {
    __privateAdd(this, _nr_instances);
    __privateAdd(this, _e10);
    __privateAdd(this, _t7);
    this.isAdvertised = false, __privateSet(this, _e10, null), __privateSet(this, _t7, null), this.ros = t3, this.name = u2, this.actionType = s4;
  }
  /**
   * Sends an action goal. Returns the feedback in the feedback callback while the action is running
   * and the result in the result callback when the action is completed.
   * Does nothing if this action is currently advertised.
   *
   * @param goal - The action goal to send.
   * @param resultCallback - The callback function when the action is completed.
   * @param [feedbackCallback] - The callback function when the action pulishes feedback.
   * @param [failedCallback] - The callback function when the action failed.
   */
  sendGoal(t3, u2, s4, c4 = console.error) {
    if (this.isAdvertised)
      return;
    const o5 = `send_action_goal:${this.name}:${v4_default()}`;
    return this.ros.on(o5, (h4) => {
      if (Ut(h4)) {
        const v2 = h4.status;
        h4.result ? v2 !== Be.STATUS_SUCCEEDED ? c4(
          String(new Nt(v2, JSON.stringify(h4.values)))
        ) : u2(h4.values) : c4(String(new Nt(v2, h4.values)));
      } else kt(h4) && (s4 == null ? void 0 : s4(h4.values));
    }), this.ros.callOnConnection({
      op: "send_action_goal",
      id: o5,
      action: this.name,
      action_type: this.actionType,
      args: t3,
      feedback: true
    }), o5;
  }
  /**
   * Cancels an action goal.
   *
   * @param id - The ID of the action goal to cancel.
   */
  cancelGoal(t3) {
    this.ros.callOnConnection({
      op: "cancel_action_goal",
      id: t3,
      action: this.name
    });
  }
  /**
   * Advertise the action. This turns the Action object from a client
   * into a server. The callback will be called with every goal sent to this action.
   *
   * @param actionCallback - This works similarly to the callback for a C++ action.
   * @param cancelCallback - A callback function to execute when the action is canceled.
   */
  advertise(t3, u2) {
    this.isAdvertised || typeof t3 != "function" || (__privateSet(this, _e10, t3), __privateSet(this, _t7, u2), this.ros.on(this.name, (s4) => {
      if (Lt(s4))
        __privateMethod(this, _nr_instances, r_fn2).call(this, s4);
      else
        throw new Error(
          "Received unrelated message on Action server event stream!"
        );
    }), this.ros.callOnConnection({
      op: "advertise_action",
      type: this.actionType,
      action: this.name
    }), this.isAdvertised = true);
  }
  /**
   * Unadvertise a previously advertised action.
   */
  unadvertise() {
    this.isAdvertised && (this.ros.callOnConnection({
      op: "unadvertise_action",
      action: this.name
    }), this.isAdvertised = false);
  }
  /**
   * Helper function to send action feedback inside an action handler.
   *
   * @param id - The action goal ID.
   * @param feedback - The feedback to send.
   */
  sendFeedback(t3, u2) {
    this.ros.callOnConnection({
      op: "action_feedback",
      id: t3,
      action: this.name,
      values: u2
    });
  }
  /**
   * Helper function to set an action as succeeded.
   *
   * @param id - The action goal ID.
   * @param result - The result to set.
   */
  setSucceeded(t3, u2) {
    this.ros.callOnConnection({
      op: "action_result",
      id: t3,
      action: this.name,
      values: u2,
      status: Be.STATUS_SUCCEEDED,
      result: true
    });
  }
  /**
   * Helper function to set an action as canceled.
   *
   * @param id - The action goal ID.
   * @param result - The result to set.
   */
  setCanceled(t3, u2) {
    this.ros.callOnConnection({
      op: "action_result",
      id: t3,
      action: this.name,
      values: u2,
      status: Be.STATUS_CANCELED,
      result: true
    });
  }
  /**
   * Helper function to set an action as failed.
   *
   * @param id - The action goal ID.
   */
  setFailed(t3) {
    this.ros.callOnConnection({
      op: "action_result",
      id: t3,
      action: this.name,
      status: Be.STATUS_ABORTED,
      result: false
    });
  }
};
_e10 = new WeakMap();
_t7 = new WeakMap();
_nr_instances = new WeakSet();
/**
 * Helper function that executes an action by calling the provided
 * action callback with the auto-generated ID as a user-accessible input.
 * Should not be called manually.
 *
 * @param rosbridgeRequest - The rosbridge request containing the action goal to send and its ID.
 * @param rosbridgeRequest.id - The ID of the action goal.
 * @param rosbridgeRequest.args - The arguments of the action goal.
 */
r_fn2 = function(t3) {
  const u2 = t3.id;
  if (typeof u2 == "string" && this.ros.on(u2, (s4) => {
    Pt(s4) && __privateGet(this, _t7) && __privateGet(this, _t7).call(this, u2);
  }), __privateGet(this, _e10))
    if (t3.args)
      __privateGet(this, _e10).call(this, t3.args, u2);
    else
      throw new Error(
        "Received Action goal with no arguments! This should never happen, because rosbridge should fill in blanks!"
      );
};
var sr = new TextDecoder();
function ar(n2) {
  const t3 = Uint8Array.from(atob(n2), (s4) => s4.charCodeAt(0)), u2 = or(t3);
  try {
    return JSON.parse(sr.decode(u2.data));
  } catch (s4) {
    throw new Error("Error parsing PNG JSON contents", { cause: s4 });
  }
}
function or(n2) {
  try {
    return decodePng(n2);
  } catch (t3) {
    throw new Error("Error decoding PNG buffer", { cause: t3 });
  }
}
var _e11;
var Pr = class extends import_index.default {
  constructor() {
    super(...arguments);
    /**
     * Buffer Map for incoming message fragments.
     */
    __privateAdd(this, _e11, /* @__PURE__ */ new Map());
  }
  /**
   * Decodes a raw message received from the transport
   * and emits it as a RosbridgeMessage over the "message" event.
   * If an error occurs, it is emitted as an "error" event.
   *
   * The default implementation handles multiple compression formats
   * and fragment messages. Subclasses may override this method to provide
   * custom handling of raw messages and when to emit messages.
   */
  handleRawMessage(t3) {
    try {
      ut(t3) ? this.handleRosbridgeMessage(t3) : typeof Blob < "u" && t3 instanceof Blob ? this.handleBsonMessage(t3) : t3 instanceof ArrayBuffer ? this.handleCborMessage(t3) : this.handleJsonMessage(String(t3));
    } catch (u2) {
      this.emit("error", u2);
    }
  }
  /**
   * Handles a RosbridgeMessage.
   * If the message is a fragment, it is appended to the fragment buffer.
   * If the message is a PNG, it is decompressed and reprocessed.
   * Otherwise, the message is emitted.
   */
  handleRosbridgeMessage(t3) {
    Jt(t3) ? this.handleRosbridgeFragmentMessage(t3) : Zt(t3) ? this.handleRosbridgePngMessage(t3) : this.emit("message", t3);
  }
  /**
   * Appends a fragment to the current fragment buffer for the message id.
   * If all fragments are received, the message is reconstructed and processed.
   */
  handleRosbridgeFragmentMessage(t3) {
    const { id: u2, data: s4, num: c4, total: o5 } = t3;
    if (!u2 || typeof c4 != "number" || typeof o5 != "number" || typeof s4 != "string")
      return;
    const h4 = Math.floor(o5);
    __privateGet(this, _e11).has(u2) || __privateGet(this, _e11).set(u2, {
      fragments: [],
      received: 0,
      total: h4
    });
    const v2 = __privateGet(this, _e11).get(u2);
    if (!v2)
      throw new Error(`Fragment buffer entry missing for id: ${u2}`);
    if (c4 < h4 && typeof v2.fragments[c4] > "u" && (v2.fragments[c4] = s4, v2.received++), v2.received === h4) {
      const f7 = v2.fragments.join("");
      let g4;
      try {
        g4 = JSON.parse(f7);
      } catch (D2) {
        throw new Error("Fragments did not form a valid JSON message!", {
          cause: D2
        });
      } finally {
        __privateGet(this, _e11).delete(u2);
      }
      if (ut(g4))
        this.handleRosbridgeMessage(g4);
      else
        throw new Error("Received invalid rosbridge message!");
    }
  }
  /**
   * Decompresses a PNG image expecting the result to be a RosbridgeMessage.
   * It is one technique for compressing JSON data.
   */
  handleRosbridgePngMessage(t3) {
    const u2 = ar(t3.data);
    if (ut(u2))
      this.handleRosbridgeMessage(u2);
    else
      throw new Error("Decompressed PNG data was invalid!");
  }
  /**
   * Deserializes a Blob of BSON expecting the result to be a RosbridgeMessage.
   * It is one technique for compressing JSON data.
   */
  handleBsonMessage(t3) {
    const u2 = new FileReader();
    u2.onload = () => {
      if (u2.result instanceof ArrayBuffer) {
        const s4 = new Uint8Array(u2.result), c4 = deserialize(s4);
        ut(c4) ? this.handleRosbridgeMessage(c4) : this.emit("error", new Error("Decoded BSON data was invalid!"));
      }
    }, u2.readAsArrayBuffer(t3);
  }
  /**
   * Deserializes an ArrayBuffer of CBOR expecting the result to be a RosbridgeMessage.
   * It is one technique for compressing JSON data.
   */
  handleCborMessage(t3) {
    const u2 = l4(new Uint8Array(t3));
    if (ut(u2))
      this.handleRosbridgeMessage(u2);
    else
      throw new Error("Decoded CBOR data was invalid!");
  }
  /**
   * Deserializes a JSON string expecting the result to be a RosbridgeMessage.
   */
  handleJsonMessage(t3) {
    const u2 = JSON.parse(t3);
    if (ut(u2))
      this.handleRosbridgeMessage(u2);
    else
      throw new Error("Received invalid rosbridge message!");
  }
};
_e11 = new WeakMap();
var kr = class extends import_index.default {
  /**
   * @param options
   * @param options.ros - The ROSLIB.Ros connection handle.
   * @param options.serverName - The action server name, like '/fibonacci'.
   * @param options.actionName - The action message name, like 'actionlib_tutorials/FibonacciAction'.
   */
  constructor({
    ros: t3,
    serverName: u2,
    actionName: s4
  }) {
    super(), this.ros = t3, this.serverName = u2, this.actionName = s4;
    const c4 = new fe({
      ros: this.ros,
      name: `${this.serverName}/goal`,
      messageType: `${this.actionName}Goal`
    }), o5 = new fe({
      ros: this.ros,
      name: `${this.serverName}/feedback`,
      messageType: `${this.actionName}Feedback`
    }), h4 = new fe({
      ros: this.ros,
      name: `${this.serverName}/status`,
      messageType: "actionlib_msgs/GoalStatusArray"
    }), v2 = new fe({
      ros: this.ros,
      name: `${this.serverName}/result`,
      messageType: `${this.actionName}Result`
    });
    c4.subscribe((f7) => {
      this.emit("goal", f7);
    }), h4.subscribe((f7) => {
      f7.status_list.forEach((g4) => {
        this.emit("status", g4);
      });
    }), o5.subscribe((f7) => {
      this.emit("status", f7.status), this.emit("feedback", f7.feedback);
    }), v2.subscribe((f7) => {
      this.emit("status", f7.status), this.emit("result", f7.result);
    });
  }
};
var pt = class _pt {
  constructor(t3) {
    this.position = new Oe(t3 == null ? void 0 : t3.position), this.orientation = new Qe(t3 == null ? void 0 : t3.orientation);
  }
  /**
   * Apply a transform against this pose.
   *
   * @param tf - The transform to be applied.
   */
  applyTransform(t3) {
    this.position.multiplyQuaternion(t3.rotation), this.position.add(t3.translation);
    const u2 = new Qe(t3.rotation);
    u2.multiply(this.orientation), this.orientation = u2;
  }
  /**
   * Clone a copy of this pose.
   *
   * @returns The cloned pose.
   */
  clone() {
    return new _pt(this);
  }
  /**
   * Multiply this pose with another pose without altering this pose.
   *
   * @returns The result of the multiplication.
   */
  multiply(t3) {
    const u2 = t3.clone();
    return u2.applyTransform({
      rotation: this.orientation,
      translation: this.position
    }), u2;
  }
  /**
   * Compute the inverse of this pose.
   *
   * @returns The inverse of the pose.
   */
  getInverse() {
    const t3 = this.clone();
    return t3.orientation.invert(), t3.position.multiplyQuaternion(t3.orientation), t3.position.x *= -1, t3.position.y *= -1, t3.position.z *= -1, t3;
  }
};
var Ur = class extends Gt {
  constructor(t3) {
    super(t3), this.goal_id = "", this.actionClient = new nr({
      ros: this.ros,
      name: this.serverName,
      actionType: "tf2_web_republisher_interfaces/TFSubscription"
    });
  }
  /**
   * Create and send a new goal (or service request) to the tf2_web_republisher
   * based on the current list of TFs.
   */
  updateGoal() {
    const t3 = {
      source_frames: Object.keys(this.frameInfos),
      target_frame: this.fixedFrame,
      angular_thres: this.angularThres,
      trans_thres: this.transThres,
      rate: this.rate
    };
    this.goal_id !== "" && this.actionClient.cancelGoal(this.goal_id), this.currentGoal = t3;
    const u2 = this.actionClient.sendGoal(
      t3,
      () => {
      },
      (s4) => {
        this.processTFArray(s4);
      }
    );
    typeof u2 == "string" && (this.goal_id = u2), this.republisherUpdateRequested = false;
  }
  /**
   * Unsubscribe and unadvertise all topics associated with this TFClient.
   */
  dispose() {
    this.goal_id !== "" && this.actionClient.cancelGoal(this.goal_id);
  }
};
var ft = ((n2) => (n2[n2.SPHERE = 0] = "SPHERE", n2[n2.BOX = 1] = "BOX", n2[n2.CYLINDER = 2] = "CYLINDER", n2[n2.MESH = 3] = "MESH", n2))(ft || {});
var H3 = ((n2) => (n2.Name = "name", n2.Type = "type", n2.Parent = "parent", n2.Link = "link", n2.Child = "child", n2.Limit = "limit", n2.Upper = "upper", n2.Lower = "lower", n2.Origin = "origin", n2.Xyz = "xyz", n2.Rpy = "rpy", n2.Size = "size", n2.Rgba = "rgba", n2.Length = "length", n2.Radius = "radius", n2.Visuals = "visual", n2.Texture = "texture", n2.Filename = "filename", n2.Color = "color", n2.Geometry = "geometry", n2.Material = "material", n2.Scale = "scale", n2.Axis = "axis", n2))(H3 || {});
var cr = class {
  constructor({ xml: t3 }) {
    var _a4;
    this.dimension = null, this.type = ft.BOX;
    const u2 = (_a4 = t3.getAttribute(H3.Size)) == null ? void 0 : _a4.split(" ");
    (u2 == null ? void 0 : u2[0]) && u2[1] && u2[2] && (this.dimension = new Oe({
      x: parseFloat(u2[0]),
      y: parseFloat(u2[1]),
      z: parseFloat(u2[2])
    }));
  }
};
var lr = class {
  constructor({ xml: t3 }) {
    var _a4;
    this.r = 0, this.g = 0, this.b = 0, this.a = 1;
    const u2 = (_a4 = t3.getAttribute(H3.Rgba)) == null ? void 0 : _a4.split(" ");
    (u2 == null ? void 0 : u2[0]) && u2[1] && u2[2] && u2[3] && (this.r = parseFloat(u2[0]), this.g = parseFloat(u2[1]), this.b = parseFloat(u2[2]), this.a = parseFloat(u2[3]));
  }
};
var hr = class {
  constructor({ xml: t3 }) {
    this.type = ft.CYLINDER, this.length = parseFloat(t3.getAttribute(H3.Length) ?? "NaN"), this.radius = parseFloat(t3.getAttribute(H3.Radius) ?? "NaN");
  }
};
var Vt = class {
  constructor({ xml: t3 }) {
    this.textureFilename = null, this.color = null, this.name = t3.getAttribute(H3.Name) ?? "unknown_name";
    const u2 = t3.getElementsByTagName(H3.Texture);
    u2[0] && (this.textureFilename = u2[0].getAttribute(H3.Filename));
    const s4 = t3.getElementsByTagName(H3.Color);
    s4[0] && (this.color = new lr({
      xml: s4[0]
    }));
  }
  isLink() {
    return this.color === null && this.textureFilename === null;
  }
  assign(t3) {
    return Object.assign(this, t3);
  }
};
var pr = class {
  constructor({ xml: t3 }) {
    var _a4;
    this.scale = null, this.type = ft.MESH, this.filename = t3.getAttribute(H3.Filename);
    const u2 = (_a4 = t3.getAttribute(H3.Scale)) == null ? void 0 : _a4.split(" ");
    (u2 == null ? void 0 : u2[0]) && u2[1] && u2[2] && (this.scale = new Oe({
      x: parseFloat(u2[0]),
      y: parseFloat(u2[1]),
      z: parseFloat(u2[2])
    }));
  }
};
var fr = class {
  constructor({ xml: t3 }) {
    this.radius = NaN, this.type = ft.SPHERE, this.radius = parseFloat(t3.getAttribute(H3.Radius) ?? "NaN");
  }
};
function zt(n2) {
  var _a4, _b2;
  const t3 = (_a4 = n2.getAttribute(H3.Xyz)) == null ? void 0 : _a4.split(" ");
  let u2 = new Oe();
  (t3 == null ? void 0 : t3[0]) && t3[1] && t3[2] && (u2 = new Oe({
    x: parseFloat(t3[0]),
    y: parseFloat(t3[1]),
    z: parseFloat(t3[2])
  }));
  const s4 = (_b2 = n2.getAttribute(H3.Rpy)) == null ? void 0 : _b2.split(" ");
  let c4 = new Qe();
  if ((s4 == null ? void 0 : s4[0]) && s4[1] && s4[2]) {
    const o5 = parseFloat(s4[0]), h4 = parseFloat(s4[1]), v2 = parseFloat(s4[2]), f7 = o5 / 2, g4 = h4 / 2, D2 = v2 / 2, p4 = Math.sin(f7) * Math.cos(g4) * Math.cos(D2) - Math.cos(f7) * Math.sin(g4) * Math.sin(D2), B2 = Math.cos(f7) * Math.sin(g4) * Math.cos(D2) + Math.sin(f7) * Math.cos(g4) * Math.sin(D2), k4 = Math.cos(f7) * Math.cos(g4) * Math.sin(D2) - Math.sin(f7) * Math.sin(g4) * Math.cos(D2), Y2 = Math.cos(f7) * Math.cos(g4) * Math.cos(D2) + Math.sin(f7) * Math.sin(g4) * Math.sin(D2);
    c4 = new Qe({
      x: p4,
      y: B2,
      z: k4,
      w: Y2
    }), c4.normalize();
  }
  return new pt({
    position: u2,
    orientation: c4
  });
}
function Ht(n2) {
  return n2.nodeType === 1;
}
function dr(n2) {
  let t3 = null;
  for (const s4 of n2.childNodes)
    if (Ht(s4)) {
      t3 = s4;
      break;
    }
  if (!t3)
    return null;
  const u2 = {
    xml: t3
  };
  switch (t3.nodeName) {
    case "sphere":
      return new fr(u2);
    case "box":
      return new cr(u2);
    case "cylinder":
      return new hr(u2);
    case "mesh":
      return new pr(u2);
    default:
      return console.warn(`Unknown geometry type ${t3.nodeName}`), null;
  }
}
var mr = class {
  constructor({ xml: t3 }) {
    this.origin = new pt(), this.geometry = null, this.material = null, this.name = t3.getAttribute(H3.Name);
    const u2 = t3.getElementsByTagName(H3.Origin);
    u2[0] && (this.origin = zt(u2[0]));
    const s4 = t3.getElementsByTagName(H3.Geometry);
    s4[0] && (this.geometry = dr(s4[0]));
    const c4 = t3.getElementsByTagName(H3.Material);
    c4[0] && (this.material = new Vt({
      xml: c4[0]
    }));
  }
};
var Er = class {
  constructor({ xml: t3 }) {
    this.visuals = [], this.name = t3.getAttribute(H3.Name) ?? "unknown_name";
    const u2 = t3.getElementsByTagName(H3.Visuals);
    for (const s4 of u2)
      this.visuals.push(
        new mr({
          xml: s4
        })
      );
  }
};
var G = {};
var ae = {};
var wt;
function st() {
  if (wt) return ae;
  wt = 1;
  function n2(M2, q3, W) {
    if (W === void 0 && (W = Array.prototype), M2 && typeof W.find == "function")
      return W.find.call(M2, q3);
    for (var ue = 0; ue < M2.length; ue++)
      if (u2(M2, ue)) {
        var de2 = M2[ue];
        if (q3.call(void 0, de2, ue, M2))
          return de2;
      }
  }
  function t3(M2, q3) {
    return q3 === void 0 && (q3 = Object), q3 && typeof q3.getOwnPropertyDescriptors == "function" && (M2 = q3.create(null, q3.getOwnPropertyDescriptors(M2))), q3 && typeof q3.freeze == "function" ? q3.freeze(M2) : M2;
  }
  function u2(M2, q3) {
    return Object.prototype.hasOwnProperty.call(M2, q3);
  }
  function s4(M2, q3) {
    if (M2 === null || typeof M2 != "object")
      throw new TypeError("target is not an object");
    for (var W in q3)
      u2(q3, W) && (M2[W] = q3[W]);
    return M2;
  }
  var c4 = t3({
    allowfullscreen: true,
    async: true,
    autofocus: true,
    autoplay: true,
    checked: true,
    controls: true,
    default: true,
    defer: true,
    disabled: true,
    formnovalidate: true,
    hidden: true,
    ismap: true,
    itemscope: true,
    loop: true,
    multiple: true,
    muted: true,
    nomodule: true,
    novalidate: true,
    open: true,
    playsinline: true,
    readonly: true,
    required: true,
    reversed: true,
    selected: true
  });
  function o5(M2) {
    return u2(c4, M2.toLowerCase());
  }
  var h4 = t3({
    area: true,
    base: true,
    br: true,
    col: true,
    embed: true,
    hr: true,
    img: true,
    input: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true
  });
  function v2(M2) {
    return u2(h4, M2.toLowerCase());
  }
  var f7 = t3({
    script: false,
    style: false,
    textarea: true,
    title: true
  });
  function g4(M2) {
    var q3 = M2.toLowerCase();
    return u2(f7, q3) && !f7[q3];
  }
  function D2(M2) {
    var q3 = M2.toLowerCase();
    return u2(f7, q3) && f7[q3];
  }
  function p4(M2) {
    return M2 === k4.HTML;
  }
  function B2(M2) {
    return p4(M2) || M2 === k4.XML_XHTML_APPLICATION;
  }
  var k4 = t3({
    /**
     * `text/html`, the only mime type that triggers treating an XML document as HTML.
     *
     * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/HTML Wikipedia
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring
     *      WHATWG HTML Spec
     */
    HTML: "text/html",
    /**
     * `application/xml`, the standard mime type for XML documents.
     *
     * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType
     *      registration
     * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
     */
    XML_APPLICATION: "application/xml",
    /**
     * `text/xml`, an alias for `application/xml`.
     *
     * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
     * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
     */
    XML_TEXT: "text/xml",
    /**
     * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
     * but is parsed as an XML document.
     *
     * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType
     *      registration
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
     * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
     */
    XML_XHTML_APPLICATION: "application/xhtml+xml",
    /**
     * `image/svg+xml`,
     *
     * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
     * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
     * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
     */
    XML_SVG_IMAGE: "image/svg+xml"
  }), Y2 = Object.keys(k4).map(function(M2) {
    return k4[M2];
  });
  function X2(M2) {
    return Y2.indexOf(M2) > -1;
  }
  var te = t3({
    /**
     * The XHTML namespace.
     *
     * @see http://www.w3.org/1999/xhtml
     */
    HTML: "http://www.w3.org/1999/xhtml",
    /**
     * The SVG namespace.
     *
     * @see http://www.w3.org/2000/svg
     */
    SVG: "http://www.w3.org/2000/svg",
    /**
     * The `xml:` namespace.
     *
     * @see http://www.w3.org/XML/1998/namespace
     */
    XML: "http://www.w3.org/XML/1998/namespace",
    /**
     * The `xmlns:` namespace.
     *
     * @see https://www.w3.org/2000/xmlns/
     */
    XMLNS: "http://www.w3.org/2000/xmlns/"
  });
  return ae.assign = s4, ae.find = n2, ae.freeze = t3, ae.HTML_BOOLEAN_ATTRIBUTES = c4, ae.HTML_RAW_TEXT_ELEMENTS = f7, ae.HTML_VOID_ELEMENTS = h4, ae.hasDefaultHTMLNamespace = B2, ae.hasOwn = u2, ae.isHTMLBooleanAttribute = o5, ae.isHTMLRawTextElement = g4, ae.isHTMLEscapableRawTextElement = D2, ae.isHTMLMimeType = p4, ae.isHTMLVoidElement = v2, ae.isValidMimeType = X2, ae.MIME_TYPE = k4, ae.NAMESPACE = te, ae;
}
var it = {};
var yt;
function mt() {
  if (yt) return it;
  yt = 1;
  var n2 = st();
  function t3(B2, k4) {
    B2.prototype = Object.create(Error.prototype, {
      constructor: { value: B2 },
      name: { value: B2.name, enumerable: true, writable: k4 }
    });
  }
  var u2 = n2.freeze({
    /**
     * the default value as defined by the spec
     */
    Error: "Error",
    /**
     * @deprecated
     * Use RangeError instead.
     */
    IndexSizeError: "IndexSizeError",
    /**
     * @deprecated
     * Just to match the related static code, not part of the spec.
     */
    DomstringSizeError: "DomstringSizeError",
    HierarchyRequestError: "HierarchyRequestError",
    WrongDocumentError: "WrongDocumentError",
    InvalidCharacterError: "InvalidCharacterError",
    /**
     * @deprecated
     * Just to match the related static code, not part of the spec.
     */
    NoDataAllowedError: "NoDataAllowedError",
    NoModificationAllowedError: "NoModificationAllowedError",
    NotFoundError: "NotFoundError",
    NotSupportedError: "NotSupportedError",
    InUseAttributeError: "InUseAttributeError",
    InvalidStateError: "InvalidStateError",
    SyntaxError: "SyntaxError",
    InvalidModificationError: "InvalidModificationError",
    NamespaceError: "NamespaceError",
    /**
     * @deprecated
     * Use TypeError for invalid arguments,
     * "NotSupportedError" DOMException for unsupported operations,
     * and "NotAllowedError" DOMException for denied requests instead.
     */
    InvalidAccessError: "InvalidAccessError",
    /**
     * @deprecated
     * Just to match the related static code, not part of the spec.
     */
    ValidationError: "ValidationError",
    /**
     * @deprecated
     * Use TypeError instead.
     */
    TypeMismatchError: "TypeMismatchError",
    SecurityError: "SecurityError",
    NetworkError: "NetworkError",
    AbortError: "AbortError",
    /**
     * @deprecated
     * Just to match the related static code, not part of the spec.
     */
    URLMismatchError: "URLMismatchError",
    QuotaExceededError: "QuotaExceededError",
    TimeoutError: "TimeoutError",
    InvalidNodeTypeError: "InvalidNodeTypeError",
    DataCloneError: "DataCloneError",
    EncodingError: "EncodingError",
    NotReadableError: "NotReadableError",
    UnknownError: "UnknownError",
    ConstraintError: "ConstraintError",
    DataError: "DataError",
    TransactionInactiveError: "TransactionInactiveError",
    ReadOnlyError: "ReadOnlyError",
    VersionError: "VersionError",
    OperationError: "OperationError",
    NotAllowedError: "NotAllowedError",
    OptOutError: "OptOutError"
  }), s4 = Object.keys(u2);
  function c4(B2) {
    return typeof B2 == "number" && B2 >= 1 && B2 <= 25;
  }
  function o5(B2) {
    return typeof B2 == "string" && B2.substring(B2.length - u2.Error.length) === u2.Error;
  }
  function h4(B2, k4) {
    c4(B2) ? (this.name = s4[B2], this.message = k4 || "") : (this.message = B2, this.name = o5(k4) ? k4 : u2.Error), Error.captureStackTrace && Error.captureStackTrace(this, h4);
  }
  t3(h4, true), Object.defineProperties(h4.prototype, {
    code: {
      enumerable: true,
      get: function() {
        var B2 = s4.indexOf(this.name);
        return c4(B2) ? B2 : 0;
      }
    }
  });
  for (var v2 = {
    INDEX_SIZE_ERR: 1,
    DOMSTRING_SIZE_ERR: 2,
    HIERARCHY_REQUEST_ERR: 3,
    WRONG_DOCUMENT_ERR: 4,
    INVALID_CHARACTER_ERR: 5,
    NO_DATA_ALLOWED_ERR: 6,
    NO_MODIFICATION_ALLOWED_ERR: 7,
    NOT_FOUND_ERR: 8,
    NOT_SUPPORTED_ERR: 9,
    INUSE_ATTRIBUTE_ERR: 10,
    INVALID_STATE_ERR: 11,
    SYNTAX_ERR: 12,
    INVALID_MODIFICATION_ERR: 13,
    NAMESPACE_ERR: 14,
    INVALID_ACCESS_ERR: 15,
    VALIDATION_ERR: 16,
    TYPE_MISMATCH_ERR: 17,
    SECURITY_ERR: 18,
    NETWORK_ERR: 19,
    ABORT_ERR: 20,
    URL_MISMATCH_ERR: 21,
    QUOTA_EXCEEDED_ERR: 22,
    TIMEOUT_ERR: 23,
    INVALID_NODE_TYPE_ERR: 24,
    DATA_CLONE_ERR: 25
  }, f7 = Object.entries(v2), g4 = 0; g4 < f7.length; g4++) {
    var D2 = f7[g4][0];
    h4[D2] = f7[g4][1];
  }
  function p4(B2, k4) {
    this.message = B2, this.locator = k4, Error.captureStackTrace && Error.captureStackTrace(this, p4);
  }
  return t3(p4), it.DOMException = h4, it.DOMExceptionName = u2, it.ExceptionCode = v2, it.ParseError = p4, it;
}
var K2 = {};
var L2 = {};
var _t8;
function Yt() {
  if (_t8) return L2;
  _t8 = 1;
  function n2(ee) {
    try {
      typeof ee != "function" && (ee = RegExp);
      var le = new ee("", "u").exec("");
      return !!le && le[0].length === 2;
    } catch {
    }
    return false;
  }
  var t3 = n2();
  function u2(ee) {
    if (ee.source[0] !== "[")
      throw new Error(ee + " can not be used with chars");
    return ee.source.slice(1, ee.source.lastIndexOf("]"));
  }
  function s4(ee, le) {
    if (ee.source[0] !== "[")
      throw new Error("/" + ee.source + "/ can not be used with chars_without");
    if (!le || typeof le != "string")
      throw new Error(JSON.stringify(le) + " is not a valid search");
    if (ee.source.indexOf(le) === -1)
      throw new Error('"' + le + '" is not is /' + ee.source + "/");
    if (le === "-" && ee.source.indexOf(le) !== 1)
      throw new Error('"' + le + '" is not at the first postion of /' + ee.source + "/");
    return new RegExp(ee.source.replace(le, ""), t3 ? "u" : "");
  }
  function c4(ee) {
    var le = this;
    return new RegExp(
      Array.prototype.slice.call(arguments).map(function(Me) {
        var xe = typeof Me == "string";
        if (xe && le === void 0 && Me === "|")
          throw new Error("use regg instead of reg to wrap expressions with `|`!");
        return xe ? Me : Me.source;
      }).join(""),
      t3 ? "mu" : "m"
    );
  }
  function o5(ee) {
    if (arguments.length === 0)
      throw new Error("no parameters provided");
    return c4.apply(o5, ["(?:"].concat(Array.prototype.slice.call(arguments), [")"]));
  }
  var h4 = "", v2 = /[-\x09\x0A\x0D\x20-\x2C\x2E-\uD7FF\uE000-\uFFFD]/;
  t3 && (v2 = c4("[", u2(v2), "\\u{10000}-\\u{10FFFF}", "]"));
  var f7 = /[\x20\x09\x0D\x0A]/, g4 = u2(f7), D2 = c4(f7, "+"), p4 = c4(f7, "*"), B2 = /[:_a-zA-Z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
  t3 && (B2 = c4("[", u2(B2), "\\u{10000}-\\u{10FFFF}", "]"));
  var k4 = u2(B2), Y2 = c4("[", k4, u2(/[-.0-9\xB7]/), u2(/[\u0300-\u036F\u203F-\u2040]/), "]"), X2 = c4(B2, Y2, "*"), te = c4(Y2, "+"), M2 = c4("&", X2, ";"), q3 = o5(/&#[0-9]+;|&#x[0-9a-fA-F]+;/), W = o5(M2, "|", q3), ue = c4("%", X2, ";"), de2 = o5(
    c4('"', o5(/[^%&"]/, "|", ue, "|", W), "*", '"'),
    "|",
    c4("'", o5(/[^%&']/, "|", ue, "|", W), "*", "'")
  ), m2 = o5('"', o5(/[^<&"]/, "|", W), "*", '"', "|", "'", o5(/[^<&']/, "|", W), "*", "'"), _2 = s4(B2, ":"), I2 = s4(Y2, ":"), U4 = c4(_2, I2, "*"), $3 = c4(U4, o5(":", U4), "?"), J2 = c4("^", $3, "$"), Ne = c4("(", $3, ")"), Z2 = o5(/"[^"]*"|'[^']*'/), we = c4(/^<\?/, "(", X2, ")", o5(D2, "(", v2, "*?)"), "?", /\?>/), l6 = /[\x20\x0D\x0Aa-zA-Z0-9-'()+,./:=?;!*#@$_%]/, A4 = o5('"', l6, '*"', "|", "'", s4(l6, "'"), "*'"), b4 = "<!--", T4 = "-->", y6 = c4(b4, o5(s4(v2, "-"), "|", c4("-", s4(v2, "-"))), "*", T4), E2 = "#PCDATA", S3 = o5(
    c4(/\(/, p4, E2, o5(p4, /\|/, p4, $3), "*", p4, /\)\*/),
    "|",
    c4(/\(/, p4, E2, p4, /\)/)
  ), V2 = /[?*+]?/, O5 = c4(
    /\([^>]+\)/,
    V2
    /*regg(choice, '|', seq), _children_quantity*/
  ), C = o5("EMPTY", "|", "ANY", "|", S3, "|", O5), w3 = "<!ELEMENT", x4 = c4(w3, D2, o5($3, "|", ue), D2, o5(C, "|", ue), p4, ">"), P2 = c4("NOTATION", D2, /\(/, p4, X2, o5(p4, /\|/, p4, X2), "*", p4, /\)/), oe = c4(/\(/, p4, te, o5(p4, /\|/, p4, te), "*", p4, /\)/), Te = o5(P2, "|", oe), Ee = o5(/CDATA|ID|IDREF|IDREFS|ENTITY|ENTITIES|NMTOKEN|NMTOKENS/, "|", Te), ie = o5(/#REQUIRED|#IMPLIED/, "|", o5(o5("#FIXED", D2), "?", m2)), R3 = o5(D2, X2, D2, Ee, D2, ie), Fe = "<!ATTLIST", ye = c4(Fe, D2, X2, R3, "*", p4, ">"), ce2 = "about:legacy-compat", Le = o5('"' + ce2 + '"', "|", "'" + ce2 + "'"), _e12 = "SYSTEM", Ce = "PUBLIC", Re = o5(o5(_e12, D2, Z2), "|", o5(Ce, D2, A4, D2, Z2)), Ue = c4(
    "^",
    o5(
      o5(_e12, D2, "(?<SystemLiteralOnly>", Z2, ")"),
      "|",
      o5(Ce, D2, "(?<PubidLiteral>", A4, ")", D2, "(?<SystemLiteral>", Z2, ")")
    )
  ), qe = o5(D2, "NDATA", D2, X2), Ae = o5(de2, "|", o5(Re, qe, "?")), j2 = "<!ENTITY", Pe = c4(j2, D2, X2, D2, Ae, p4, ">"), ne = o5(de2, "|", Re), Ge = c4(j2, D2, "%", D2, X2, D2, ne, p4, ">"), at = o5(Pe, "|", Ge), Ve = c4(Ce, D2, A4), ze = c4("<!NOTATION", D2, X2, D2, o5(Re, "|", Ve), p4, ">"), F2 = c4(p4, "=", p4), Q2 = /1[.]\d+/, De = c4(D2, "version", F2, o5("'", Q2, "'", "|", '"', Q2, '"')), ge = /[A-Za-z][-A-Za-z0-9._]*/, He = o5(D2, "encoding", F2, o5('"', ge, '"', "|", "'", ge, "'")), Je = o5(D2, "standalone", F2, o5("'", o5("yes", "|", "no"), "'", "|", '"', o5("yes", "|", "no"), '"')), Ze = c4(/^<\?xml/, De, He, "?", Je, "?", p4, /\?>/), Ke = "<!DOCTYPE", ot = "<![CDATA[", ct = "]]>", et = /<!\[CDATA\[/, Ye = /\]\]>/, tt = c4(v2, "*?", Ye), dt = c4(et, tt);
  return L2.chars = u2, L2.chars_without = s4, L2.detectUnicodeSupport = n2, L2.reg = c4, L2.regg = o5, L2.ABOUT_LEGACY_COMPAT = ce2, L2.ABOUT_LEGACY_COMPAT_SystemLiteral = Le, L2.AttlistDecl = ye, L2.CDATA_START = ot, L2.CDATA_END = ct, L2.CDSect = dt, L2.Char = v2, L2.Comment = y6, L2.COMMENT_START = b4, L2.COMMENT_END = T4, L2.DOCTYPE_DECL_START = Ke, L2.elementdecl = x4, L2.EntityDecl = at, L2.EntityValue = de2, L2.ExternalID = Re, L2.ExternalID_match = Ue, L2.Name = X2, L2.NotationDecl = ze, L2.Reference = W, L2.PEReference = ue, L2.PI = we, L2.PUBLIC = Ce, L2.PubidLiteral = A4, L2.QName = $3, L2.QName_exact = J2, L2.QName_group = Ne, L2.S = D2, L2.SChar_s = g4, L2.S_OPT = p4, L2.SYSTEM = _e12, L2.SystemLiteral = Z2, L2.UNICODE_REPLACEMENT_CHARACTER = h4, L2.UNICODE_SUPPORT = t3, L2.XMLDecl = Ze, L2;
}
var St;
function Xt() {
  if (St) return K2;
  St = 1;
  var n2 = st(), t3 = n2.find, u2 = n2.hasDefaultHTMLNamespace, s4 = n2.hasOwn, c4 = n2.isHTMLMimeType, o5 = n2.isHTMLRawTextElement, h4 = n2.isHTMLVoidElement, v2 = n2.MIME_TYPE, f7 = n2.NAMESPACE, g4 = Symbol(), D2 = mt(), p4 = D2.DOMException, B2 = D2.DOMExceptionName, k4 = Yt();
  function Y2(e2) {
    if (e2 !== g4)
      throw new TypeError("Illegal constructor");
  }
  function X2(e2) {
    return e2 !== "";
  }
  function te(e2) {
    return e2 ? e2.split(/[\t\n\f\r ]+/).filter(X2) : [];
  }
  function M2(e2, r2) {
    return s4(e2, r2) || (e2[r2] = true), e2;
  }
  function q3(e2) {
    if (!e2) return [];
    var r2 = te(e2);
    return Object.keys(r2.reduce(M2, {}));
  }
  function W(e2) {
    return function(r2) {
      return e2 && e2.indexOf(r2) !== -1;
    };
  }
  function ue(e2) {
    if (!k4.QName_exact.test(e2))
      throw new p4(p4.INVALID_CHARACTER_ERR, 'invalid character in qualified name "' + e2 + '"');
  }
  function de2(e2, r2) {
    ue(r2), e2 = e2 || null;
    var i3 = null, a3 = r2;
    if (r2.indexOf(":") >= 0) {
      var d5 = r2.split(":");
      i3 = d5[0], a3 = d5[1];
    }
    if (i3 !== null && e2 === null)
      throw new p4(p4.NAMESPACE_ERR, "prefix is non-null and namespace is null");
    if (i3 === "xml" && e2 !== n2.NAMESPACE.XML)
      throw new p4(p4.NAMESPACE_ERR, 'prefix is "xml" and namespace is not the XML namespace');
    if ((i3 === "xmlns" || r2 === "xmlns") && e2 !== n2.NAMESPACE.XMLNS)
      throw new p4(
        p4.NAMESPACE_ERR,
        'either qualifiedName or prefix is "xmlns" and namespace is not the XMLNS namespace'
      );
    if (e2 === n2.NAMESPACE.XMLNS && i3 !== "xmlns" && r2 !== "xmlns")
      throw new p4(
        p4.NAMESPACE_ERR,
        'namespace is the XMLNS namespace and neither qualifiedName nor prefix is "xmlns"'
      );
    return [e2, i3, a3];
  }
  function m2(e2, r2) {
    for (var i3 in e2)
      s4(e2, i3) && (r2[i3] = e2[i3]);
  }
  function _2(e2, r2) {
    var i3 = e2.prototype;
    if (!(i3 instanceof r2)) {
      let a3 = function() {
      };
      a3.prototype = r2.prototype, a3 = new a3(), m2(i3, a3), e2.prototype = i3 = a3;
    }
    i3.constructor != e2 && (typeof e2 != "function" && console.error("unknown Class:" + e2), i3.constructor = e2);
  }
  var I2 = {}, U4 = I2.ELEMENT_NODE = 1, $3 = I2.ATTRIBUTE_NODE = 2, J2 = I2.TEXT_NODE = 3, Ne = I2.CDATA_SECTION_NODE = 4, Z2 = I2.ENTITY_REFERENCE_NODE = 5, we = I2.ENTITY_NODE = 6, l6 = I2.PROCESSING_INSTRUCTION_NODE = 7, A4 = I2.COMMENT_NODE = 8, b4 = I2.DOCUMENT_NODE = 9, T4 = I2.DOCUMENT_TYPE_NODE = 10, y6 = I2.DOCUMENT_FRAGMENT_NODE = 11, E2 = I2.NOTATION_NODE = 12, S3 = n2.freeze({
    DOCUMENT_POSITION_DISCONNECTED: 1,
    DOCUMENT_POSITION_PRECEDING: 2,
    DOCUMENT_POSITION_FOLLOWING: 4,
    DOCUMENT_POSITION_CONTAINS: 8,
    DOCUMENT_POSITION_CONTAINED_BY: 16,
    DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 32
  });
  function V2(e2, r2) {
    if (r2.length < e2.length) return V2(r2, e2);
    var i3 = null;
    for (var a3 in e2) {
      if (e2[a3] !== r2[a3]) return i3;
      i3 = e2[a3];
    }
    return i3;
  }
  function O5(e2) {
    return e2.guid || (e2.guid = Math.random()), e2.guid;
  }
  function C() {
  }
  C.prototype = {
    /**
     * The number of nodes in the list. The range of valid child node indices is 0 to length-1
     * inclusive.
     *
     * @type {number}
     */
    length: 0,
    /**
     * Returns the item at `index`. If index is greater than or equal to the number of nodes in
     * the list, this returns null.
     *
     * @param index
     * Unsigned long Index into the collection.
     * @returns {Node | null}
     * The node at position `index` in the NodeList,
     * or null if that is not a valid index.
     */
    item: function(e2) {
      return e2 >= 0 && e2 < this.length ? this[e2] : null;
    },
    /**
     * Returns a string representation of the NodeList.
     *
     * @param {unknown} nodeFilter
     * __A filter function? Not implemented according to the spec?__.
     * @returns {string}
     * A string representation of the NodeList.
     */
    toString: function(e2) {
      for (var r2 = [], i3 = 0; i3 < this.length; i3++)
        xe(this[i3], r2, e2);
      return r2.join("");
    },
    /**
     * Filters the NodeList based on a predicate.
     *
     * @param {function(Node): boolean} predicate
     * - A predicate function to filter the NodeList.
     * @returns {Node[]}
     * An array of nodes that satisfy the predicate.
     * @private
     */
    filter: function(e2) {
      return Array.prototype.filter.call(this, e2);
    },
    /**
     * Returns the first index at which a given node can be found in the NodeList, or -1 if it is
     * not present.
     *
     * @param {Node} item
     * - The Node item to locate in the NodeList.
     * @returns {number}
     * The first index of the node in the NodeList; -1 if not found.
     * @private
     */
    indexOf: function(e2) {
      return Array.prototype.indexOf.call(this, e2);
    }
  }, C.prototype[Symbol.iterator] = function() {
    var e2 = this, r2 = 0;
    return {
      next: function() {
        return r2 < e2.length ? {
          value: e2[r2++],
          done: false
        } : {
          done: true
        };
      },
      return: function() {
        return {
          done: true
        };
      }
    };
  };
  function w3(e2, r2) {
    this._node = e2, this._refresh = r2, x4(this);
  }
  function x4(e2) {
    var r2 = e2._node._inc || e2._node.ownerDocument._inc;
    if (e2._inc !== r2) {
      var i3 = e2._refresh(e2._node);
      if (Ct(e2, "length", i3.length), !e2.$$length || i3.length < e2.$$length)
        for (var a3 = i3.length; a3 in e2; a3++)
          s4(e2, a3) && delete e2[a3];
      m2(i3, e2), e2._inc = r2;
    }
  }
  w3.prototype.item = function(e2) {
    return x4(this), this[e2] || null;
  }, _2(w3, C);
  function P2() {
  }
  function oe(e2, r2) {
    for (var i3 = 0; i3 < e2.length; ) {
      if (e2[i3] === r2)
        return i3;
      i3++;
    }
  }
  function Te(e2, r2, i3, a3) {
    if (a3 ? r2[oe(r2, a3)] = i3 : (r2[r2.length] = i3, r2.length++), e2) {
      i3.ownerElement = e2;
      var d5 = e2.ownerDocument;
      d5 && (a3 && _e12(d5, e2, a3), Le(d5, e2, i3));
    }
  }
  function Ee(e2, r2, i3) {
    var a3 = oe(r2, i3);
    if (a3 >= 0) {
      for (var d5 = r2.length - 1; a3 <= d5; )
        r2[a3] = r2[++a3];
      if (r2.length = d5, e2) {
        var N4 = e2.ownerDocument;
        N4 && _e12(N4, e2, i3), i3.ownerElement = null;
      }
    }
  }
  P2.prototype = {
    length: 0,
    item: C.prototype.item,
    /**
     * Get an attribute by name. Note: Name is in lower case in case of HTML namespace and
     * document.
     *
     * @param {string} localName
     * The local name of the attribute.
     * @returns {Attr | null}
     * The attribute with the given local name, or null if no such attribute exists.
     * @see https://dom.spec.whatwg.org/#concept-element-attributes-get-by-name
     */
    getNamedItem: function(e2) {
      this._ownerElement && this._ownerElement._isInHTMLDocumentAndNamespace() && (e2 = e2.toLowerCase());
      for (var r2 = 0; r2 < this.length; ) {
        var i3 = this[r2];
        if (i3.nodeName === e2)
          return i3;
        r2++;
      }
      return null;
    },
    /**
     * Set an attribute.
     *
     * @param {Attr} attr
     * The attribute to set.
     * @returns {Attr | null}
     * The old attribute with the same local name and namespace URI as the new one, or null if no
     * such attribute exists.
     * @throws {DOMException}
     * With code:
     * - {@link INUSE_ATTRIBUTE_ERR} - If the attribute is already an attribute of another
     * element.
     * @see https://dom.spec.whatwg.org/#concept-element-attributes-set
     */
    setNamedItem: function(e2) {
      var r2 = e2.ownerElement;
      if (r2 && r2 !== this._ownerElement)
        throw new p4(p4.INUSE_ATTRIBUTE_ERR);
      var i3 = this.getNamedItemNS(e2.namespaceURI, e2.localName);
      return i3 === e2 ? e2 : (Te(this._ownerElement, this, e2, i3), i3);
    },
    /**
     * Set an attribute, replacing an existing attribute with the same local name and namespace
     * URI if one exists.
     *
     * @param {Attr} attr
     * The attribute to set.
     * @returns {Attr | null}
     * The old attribute with the same local name and namespace URI as the new one, or null if no
     * such attribute exists.
     * @throws {DOMException}
     * Throws a DOMException with the name "InUseAttributeError" if the attribute is already an
     * attribute of another element.
     * @see https://dom.spec.whatwg.org/#concept-element-attributes-set
     */
    setNamedItemNS: function(e2) {
      return this.setNamedItem(e2);
    },
    /**
     * Removes an attribute specified by the local name.
     *
     * @param {string} localName
     * The local name of the attribute to be removed.
     * @returns {Attr}
     * The attribute node that was removed.
     * @throws {DOMException}
     * With code:
     * - {@link DOMException.NOT_FOUND_ERR} if no attribute with the given name is found.
     * @see https://dom.spec.whatwg.org/#dom-namednodemap-removenameditem
     * @see https://dom.spec.whatwg.org/#concept-element-attributes-remove-by-name
     */
    removeNamedItem: function(e2) {
      var r2 = this.getNamedItem(e2);
      if (!r2)
        throw new p4(p4.NOT_FOUND_ERR, e2);
      return Ee(this._ownerElement, this, r2), r2;
    },
    /**
     * Removes an attribute specified by the namespace and local name.
     *
     * @param {string | null} namespaceURI
     * The namespace URI of the attribute to be removed.
     * @param {string} localName
     * The local name of the attribute to be removed.
     * @returns {Attr}
     * The attribute node that was removed.
     * @throws {DOMException}
     * With code:
     * - {@link DOMException.NOT_FOUND_ERR} if no attribute with the given namespace URI and local
     * name is found.
     * @see https://dom.spec.whatwg.org/#dom-namednodemap-removenameditemns
     * @see https://dom.spec.whatwg.org/#concept-element-attributes-remove-by-namespace
     */
    removeNamedItemNS: function(e2, r2) {
      var i3 = this.getNamedItemNS(e2, r2);
      if (!i3)
        throw new p4(p4.NOT_FOUND_ERR, e2 ? e2 + " : " + r2 : r2);
      return Ee(this._ownerElement, this, i3), i3;
    },
    /**
     * Get an attribute by namespace and local name.
     *
     * @param {string | null} namespaceURI
     * The namespace URI of the attribute.
     * @param {string} localName
     * The local name of the attribute.
     * @returns {Attr | null}
     * The attribute with the given namespace URI and local name, or null if no such attribute
     * exists.
     * @see https://dom.spec.whatwg.org/#concept-element-attributes-get-by-namespace
     */
    getNamedItemNS: function(e2, r2) {
      e2 || (e2 = null);
      for (var i3 = 0; i3 < this.length; ) {
        var a3 = this[i3];
        if (a3.localName === r2 && a3.namespaceURI === e2)
          return a3;
        i3++;
      }
      return null;
    }
  }, P2.prototype[Symbol.iterator] = function() {
    var e2 = this, r2 = 0;
    return {
      next: function() {
        return r2 < e2.length ? {
          value: e2[r2++],
          done: false
        } : {
          done: true
        };
      },
      return: function() {
        return {
          done: true
        };
      }
    };
  };
  function ie() {
  }
  ie.prototype = {
    /**
     * Test if the DOM implementation implements a specific feature and version, as specified in
     * {@link https://www.w3.org/TR/DOM-Level-3-Core/core.html#DOMFeatures DOM Features}.
     *
     * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given
     * feature is supported. The different implementations fairly diverged in what kind of
     * features were reported. The latest version of the spec settled to force this method to
     * always return true, where the functionality was accurate and in use.
     *
     * @deprecated
     * It is deprecated and modern browsers return true in all cases.
     * @function DOMImplementation#hasFeature
     * @param {string} feature
     * The name of the feature to test.
     * @param {string} [version]
     * This is the version number of the feature to test.
     * @returns {boolean}
     * Always returns true.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
     * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-5CED94D7 DOM Level 3 Core
     */
    hasFeature: function(e2, r2) {
      return true;
    },
    /**
     * Creates a DOM Document object of the specified type with its document element. Note that
     * based on the {@link DocumentType}
     * given to create the document, the implementation may instantiate specialized
     * {@link Document} objects that support additional features than the "Core", such as "HTML"
     * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#DOM2HTML DOM Level 2 HTML}.
     * On the other hand, setting the {@link DocumentType} after the document was created makes
     * this very unlikely to happen. Alternatively, specialized {@link Document} creation methods,
     * such as createHTMLDocument
     * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#DOM2HTML DOM Level 2 HTML},
     * can be used to obtain specific types of {@link Document} objects.
     *
     * __It behaves slightly different from the description in the living standard__:
     * - There is no interface/class `XMLDocument`, it returns a `Document`
     * instance (with it's `type` set to `'xml'`).
     * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.
     *
     * @function DOMImplementation.createDocument
     * @param {string | null} namespaceURI
     * The
     * {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-namespaceURI namespace URI}
     * of the document element to create or null.
     * @param {string | null} qualifiedName
     * The
     * {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-qualifiedname qualified name}
     * of the document element to be created or null.
     * @param {DocumentType | null} [doctype=null]
     * The type of document to be created or null. When doctype is not null, its
     * {@link Node#ownerDocument} attribute is set to the document being created. Default is
     * `null`
     * @returns {Document}
     * A new {@link Document} object with its document element. If the NamespaceURI,
     * qualifiedName, and doctype are null, the returned {@link Document} is empty with no
     * document element.
     * @throws {DOMException}
     * With code:
     *
     * - `INVALID_CHARACTER_ERR`: Raised if the specified qualified name is not an XML name
     * according to {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#XML XML 1.0}.
     * - `NAMESPACE_ERR`: Raised if the qualifiedName is malformed, if the qualifiedName has a
     * prefix and the namespaceURI is null, or if the qualifiedName is null and the namespaceURI
     * is different from null, or if the qualifiedName has a prefix that is "xml" and the
     * namespaceURI is different from "{@link http://www.w3.org/XML/1998/namespace}"
     * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#Namespaces XML Namespaces},
     * or if the DOM implementation does not support the "XML" feature but a non-null namespace
     * URI was provided, since namespaces were defined by XML.
     * - `WRONG_DOCUMENT_ERR`: Raised if doctype has already been used with a different document
     * or was created from a different implementation.
     * - `NOT_SUPPORTED_ERR`: May be raised if the implementation does not support the feature
     * "XML" and the language exposed through the Document does not support XML Namespaces (such
     * as {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#HTML40 HTML 4.01}).
     * @since DOM Level 2.
     * @see {@link #createHTMLDocument}
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument DOM Living Standard
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Level-2-Core-DOM-createDocument DOM
     *      Level 3 Core
     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM
     *      Level 2 Core (initial)
     */
    createDocument: function(e2, r2, i3) {
      var a3 = v2.XML_APPLICATION;
      e2 === f7.HTML ? a3 = v2.XML_XHTML_APPLICATION : e2 === f7.SVG && (a3 = v2.XML_SVG_IMAGE);
      var d5 = new ce2(g4, { contentType: a3 });
      if (d5.implementation = this, d5.childNodes = new C(), d5.doctype = i3 || null, i3 && d5.appendChild(i3), r2) {
        var N4 = d5.createElementNS(e2, r2);
        d5.appendChild(N4);
      }
      return d5;
    },
    /**
     * Creates an empty DocumentType node. Entity declarations and notations are not made
     * available. Entity reference expansions and default attribute additions do not occur.
     *
     * **This behavior is slightly different from the one in the specs**:
     * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.
     * - `publicId` and `systemId` contain the raw data including any possible quotes,
     *   so they can always be serialized back to the original value
     * - `internalSubset` contains the raw string between `[` and `]` if present,
     *   but is not parsed or validated in any form.
     *
     * @function DOMImplementation#createDocumentType
     * @param {string} qualifiedName
     * The {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-qualifiedname qualified
     * name} of the document type to be created.
     * @param {string} [publicId]
     * The external subset public identifier.
     * @param {string} [systemId]
     * The external subset system identifier.
     * @param {string} [internalSubset]
     * the internal subset or an empty string if it is not present
     * @returns {DocumentType}
     * A new {@link DocumentType} node with {@link Node#ownerDocument} set to null.
     * @throws {DOMException}
     * With code:
     *
     * - `INVALID_CHARACTER_ERR`: Raised if the specified qualified name is not an XML name
     * according to {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#XML XML 1.0}.
     * - `NAMESPACE_ERR`: Raised if the qualifiedName is malformed.
     * - `NOT_SUPPORTED_ERR`: May be raised if the implementation does not support the feature
     * "XML" and the language exposed through the Document does not support XML Namespaces (such
     * as {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#HTML40 HTML 4.01}).
     * @since DOM Level 2.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType
     *      MDN
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living
     *      Standard
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Level-3-Core-DOM-createDocType DOM
     *      Level 3 Core
     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM
     *      Level 2 Core
     * @see https://github.com/xmldom/xmldom/blob/master/CHANGELOG.md#050
     * @see https://www.w3.org/TR/DOM-Level-2-Core/#core-ID-Core-DocType-internalSubset
     * @prettierignore
     */
    createDocumentType: function(e2, r2, i3, a3) {
      ue(e2);
      var d5 = new Ke(g4);
      return d5.name = e2, d5.nodeName = e2, d5.publicId = r2 || "", d5.systemId = i3 || "", d5.internalSubset = a3 || "", d5.childNodes = new C(), d5;
    },
    /**
     * Returns an HTML document, that might already have a basic DOM structure.
     *
     * __It behaves slightly different from the description in the living standard__:
     * - If the first argument is `false` no initial nodes are added (steps 3-7 in the specs are
     * omitted)
     * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.
     *
     * @param {string | false} [title]
     * A string containing the title to give the new HTML document.
     * @returns {Document}
     * The HTML document.
     * @since WHATWG Living Standard.
     * @see {@link #createDocument}
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createhtmldocument
     * @see https://dom.spec.whatwg.org/#html-document
     */
    createHTMLDocument: function(e2) {
      var r2 = new ce2(g4, { contentType: v2.HTML });
      if (r2.implementation = this, r2.childNodes = new C(), e2 !== false) {
        r2.doctype = this.createDocumentType("html"), r2.doctype.ownerDocument = r2, r2.appendChild(r2.doctype);
        var i3 = r2.createElement("html");
        r2.appendChild(i3);
        var a3 = r2.createElement("head");
        if (i3.appendChild(a3), typeof e2 == "string") {
          var d5 = r2.createElement("title");
          d5.appendChild(r2.createTextNode(e2)), a3.appendChild(d5);
        }
        i3.appendChild(r2.createElement("body"));
      }
      return r2;
    }
  };
  function R3(e2) {
    Y2(e2);
  }
  R3.prototype = {
    /**
     * The first child of this node.
     *
     * @type {Node | null}
     */
    firstChild: null,
    /**
     * The last child of this node.
     *
     * @type {Node | null}
     */
    lastChild: null,
    /**
     * The previous sibling of this node.
     *
     * @type {Node | null}
     */
    previousSibling: null,
    /**
     * The next sibling of this node.
     *
     * @type {Node | null}
     */
    nextSibling: null,
    /**
     * The parent node of this node.
     *
     * @type {Node | null}
     */
    parentNode: null,
    /**
     * The parent element of this node.
     *
     * @type {Element | null}
     */
    get parentElement() {
      return this.parentNode && this.parentNode.nodeType === this.ELEMENT_NODE ? this.parentNode : null;
    },
    /**
     * The child nodes of this node.
     *
     * @type {NodeList}
     */
    childNodes: null,
    /**
     * The document object associated with this node.
     *
     * @type {Document | null}
     */
    ownerDocument: null,
    /**
     * The value of this node.
     *
     * @type {string | null}
     */
    nodeValue: null,
    /**
     * The namespace URI of this node.
     *
     * @type {string | null}
     */
    namespaceURI: null,
    /**
     * The prefix of the namespace for this node.
     *
     * @type {string | null}
     */
    prefix: null,
    /**
     * The local part of the qualified name of this node.
     *
     * @type {string | null}
     */
    localName: null,
    /**
     * The baseURI is currently always `about:blank`,
     * since that's what happens when you create a document from scratch.
     *
     * @type {'about:blank'}
     */
    baseURI: "about:blank",
    /**
     * Is true if this node is part of a document.
     *
     * @type {boolean}
     */
    get isConnected() {
      var e2 = this.getRootNode();
      return e2 && e2.nodeType === e2.DOCUMENT_NODE;
    },
    /**
     * Checks whether `other` is an inclusive descendant of this node.
     *
     * @param {Node | null | undefined} other
     * The node to check.
     * @returns {boolean}
     * True if `other` is an inclusive descendant of this node; false otherwise.
     * @see https://dom.spec.whatwg.org/#dom-node-contains
     */
    contains: function(e2) {
      if (!e2) return false;
      var r2 = e2;
      do {
        if (this === r2) return true;
        r2 = e2.parentNode;
      } while (r2);
      return false;
    },
    /**
     * @typedef GetRootNodeOptions
     * @property {boolean} [composed=false]
     */
    /**
     * Searches for the root node of this node.
     *
     * **This behavior is slightly different from the in the specs**:
     * - ignores `options.composed`, since `ShadowRoot`s are unsupported, always returns root.
     *
     * @param {GetRootNodeOptions} [options]
     * @returns {Node}
     * Root node.
     * @see https://dom.spec.whatwg.org/#dom-node-getrootnode
     * @see https://dom.spec.whatwg.org/#concept-shadow-including-root
     */
    getRootNode: function(e2) {
      var r2 = this;
      do {
        if (!r2.parentNode)
          return r2;
        r2 = r2.parentNode;
      } while (r2);
    },
    /**
     * Checks whether the given node is equal to this node.
     *
     * @param {Node} [otherNode]
     * @see https://dom.spec.whatwg.org/#concept-node-equals
     */
    isEqualNode: function(e2) {
      if (!e2 || this.nodeType !== e2.nodeType) return false;
      switch (this.nodeType) {
        case this.DOCUMENT_TYPE_NODE:
          if (this.name !== e2.name || this.publicId !== e2.publicId || this.systemId !== e2.systemId) return false;
          break;
        case this.ELEMENT_NODE:
          if (this.namespaceURI !== e2.namespaceURI || this.prefix !== e2.prefix || this.localName !== e2.localName || this.attributes.length !== e2.attributes.length) return false;
          for (var r2 = 0; r2 < this.attributes.length; r2++) {
            var i3 = this.attributes.item(r2);
            if (!i3.isEqualNode(e2.getAttributeNodeNS(i3.namespaceURI, i3.localName)))
              return false;
          }
          break;
        case this.ATTRIBUTE_NODE:
          if (this.namespaceURI !== e2.namespaceURI || this.localName !== e2.localName || this.value !== e2.value) return false;
          break;
        case this.PROCESSING_INSTRUCTION_NODE:
          if (this.target !== e2.target || this.data !== e2.data)
            return false;
          break;
        case this.TEXT_NODE:
        case this.COMMENT_NODE:
          if (this.data !== e2.data) return false;
          break;
      }
      if (this.childNodes.length !== e2.childNodes.length)
        return false;
      for (var r2 = 0; r2 < this.childNodes.length; r2++)
        if (!this.childNodes[r2].isEqualNode(e2.childNodes[r2]))
          return false;
      return true;
    },
    /**
     * Checks whether or not the given node is this node.
     *
     * @param {Node} [otherNode]
     */
    isSameNode: function(e2) {
      return this === e2;
    },
    /**
     * Inserts a node before a reference node as a child of this node.
     *
     * @param {Node} newChild
     * The new child node to be inserted.
     * @param {Node | null} refChild
     * The reference node before which newChild will be inserted.
     * @returns {Node}
     * The new child node successfully inserted.
     * @throws {DOMException}
     * Throws a DOMException if inserting the node would result in a DOM tree that is not
     * well-formed, or if `child` is provided but is not a child of `parent`.
     * See {@link _insertBefore} for more details.
     * @since Modified in DOM L2
     */
    insertBefore: function(e2, r2) {
      return F2(this, e2, r2);
    },
    /**
     * Replaces an old child node with a new child node within this node.
     *
     * @param {Node} newChild
     * The new node that is to replace the old node.
     * If it already exists in the DOM, it is removed from its original position.
     * @param {Node} oldChild
     * The existing child node to be replaced.
     * @returns {Node}
     * Returns the replaced child node.
     * @throws {DOMException}
     * Throws a DOMException if replacing the node would result in a DOM tree that is not
     * well-formed, or if `oldChild` is not a child of `this`.
     * This can also occur if the pre-replacement validity assertion fails.
     * See {@link _insertBefore}, {@link Node.removeChild}, and
     * {@link assertPreReplacementValidityInDocument} for more details.
     * @see https://dom.spec.whatwg.org/#concept-node-replace
     */
    replaceChild: function(e2, r2) {
      F2(this, e2, r2, ze), r2 && this.removeChild(r2);
    },
    /**
     * Removes an existing child node from this node.
     *
     * @param {Node} oldChild
     * The child node to be removed.
     * @returns {Node}
     * Returns the removed child node.
     * @throws {DOMException}
     * Throws a DOMException if `oldChild` is not a child of `this`.
     * See {@link _removeChild} for more details.
     */
    removeChild: function(e2) {
      return Re(this, e2);
    },
    /**
     * Appends a child node to this node.
     *
     * @param {Node} newChild
     * The child node to be appended to this node.
     * If it already exists in the DOM, it is removed from its original position.
     * @returns {Node}
     * Returns the appended child node.
     * @throws {DOMException}
     * Throws a DOMException if appending the node would result in a DOM tree that is not
     * well-formed, or if `newChild` is not a valid Node.
     * See {@link insertBefore} for more details.
     */
    appendChild: function(e2) {
      return this.insertBefore(e2, null);
    },
    /**
     * Determines whether this node has any child nodes.
     *
     * @returns {boolean}
     * Returns true if this node has any child nodes, and false otherwise.
     */
    hasChildNodes: function() {
      return this.firstChild != null;
    },
    /**
     * Creates a copy of the calling node.
     *
     * @param {boolean} deep
     * If true, the contents of the node are recursively copied.
     * If false, only the node itself (and its attributes, if it is an element) are copied.
     * @returns {Node}
     * Returns the newly created copy of the node.
     * @throws {DOMException}
     * May throw a DOMException if operations within {@link Element#setAttributeNode} or
     * {@link Node#appendChild} (which are potentially invoked in this method) do not meet their
     * specific constraints.
     * @see {@link cloneNode}
     */
    cloneNode: function(e2) {
      return Et(this.ownerDocument || this, this, e2);
    },
    /**
     * Puts the specified node and all of its subtree into a "normalized" form. In a normalized
     * subtree, no text nodes in the subtree are empty and there are no adjacent text nodes.
     *
     * Specifically, this method merges any adjacent text nodes (i.e., nodes for which `nodeType`
     * is `TEXT_NODE`) into a single node with the combined data. It also removes any empty text
     * nodes.
     *
     * This method operates recursively, so it also normalizes any and all descendent nodes within
     * the subtree.
     *
     * @throws {DOMException}
     * May throw a DOMException if operations within removeChild or appendData (which are
     * potentially invoked in this method) do not meet their specific constraints.
     * @since Modified in DOM Level 2
     * @see {@link Node.removeChild}
     * @see {@link CharacterData.appendData}
     */
    normalize: function() {
      for (var e2 = this.firstChild; e2; ) {
        var r2 = e2.nextSibling;
        r2 && r2.nodeType == J2 && e2.nodeType == J2 ? (this.removeChild(r2), e2.appendData(r2.data)) : (e2.normalize(), e2 = r2);
      }
    },
    /**
     * Checks whether the DOM implementation implements a specific feature and its version.
     *
     * @deprecated
     * Since `DOMImplementation.hasFeature` is deprecated and always returns true.
     * @param {string} feature
     * The package name of the feature to test. This is the same name that can be passed to the
     * method `hasFeature` on `DOMImplementation`.
     * @param {string} version
     * This is the version number of the package name to test.
     * @returns {boolean}
     * Returns true in all cases in the current implementation.
     * @since Introduced in DOM Level 2
     * @see {@link DOMImplementation.hasFeature}
     */
    isSupported: function(e2, r2) {
      return this.ownerDocument.implementation.hasFeature(e2, r2);
    },
    /**
     * Look up the prefix associated to the given namespace URI, starting from this node.
     * **The default namespace declarations are ignored by this method.**
     * See Namespace Prefix Lookup for details on the algorithm used by this method.
     *
     * **This behavior is different from the in the specs**:
     * - no node type specific handling
     * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes
     *
     * @param {string | null} namespaceURI
     * The namespace URI for which to find the associated prefix.
     * @returns {string | null}
     * The associated prefix, if found; otherwise, null.
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
     * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
     * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
     * @see https://github.com/xmldom/xmldom/issues/322
     * @prettierignore
     */
    lookupPrefix: function(e2) {
      for (var r2 = this; r2; ) {
        var i3 = r2._nsMap;
        if (i3) {
          for (var a3 in i3)
            if (s4(i3, a3) && i3[a3] === e2)
              return a3;
        }
        r2 = r2.nodeType == $3 ? r2.ownerDocument : r2.parentNode;
      }
      return null;
    },
    /**
     * This function is used to look up the namespace URI associated with the given prefix,
     * starting from this node.
     *
     * **This behavior is different from the in the specs**:
     * - no node type specific handling
     * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes
     *
     * @param {string | null} prefix
     * The prefix for which to find the associated namespace URI.
     * @returns {string | null}
     * The associated namespace URI, if found; otherwise, null.
     * @since DOM Level 3
     * @see https://dom.spec.whatwg.org/#dom-node-lookupnamespaceuri
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespaceURI
     * @prettierignore
     */
    lookupNamespaceURI: function(e2) {
      for (var r2 = this; r2; ) {
        var i3 = r2._nsMap;
        if (i3 && s4(i3, e2))
          return i3[e2];
        r2 = r2.nodeType == $3 ? r2.ownerDocument : r2.parentNode;
      }
      return null;
    },
    /**
     * Determines whether the given namespace URI is the default namespace.
     *
     * The function works by looking up the prefix associated with the given namespace URI. If no
     * prefix is found (i.e., the namespace URI is not registered in the namespace map of this
     * node or any of its ancestors), it returns `true`, implying the namespace URI is considered
     * the default.
     *
     * **This behavior is different from the in the specs**:
     * - no node type specific handling
     * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes
     *
     * @param {string | null} namespaceURI
     * The namespace URI to be checked.
     * @returns {boolean}
     * Returns true if the given namespace URI is the default namespace, false otherwise.
     * @since DOM Level 3
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isDefaultNamespace
     * @see https://dom.spec.whatwg.org/#dom-node-isdefaultnamespace
     * @prettierignore
     */
    isDefaultNamespace: function(e2) {
      var r2 = this.lookupPrefix(e2);
      return r2 == null;
    },
    /**
     * Compares the reference node with a node with regard to their position in the document and
     * according to the document order.
     *
     * @param {Node} other
     * The node to compare the reference node to.
     * @returns {number}
     * Returns how the node is positioned relatively to the reference node according to the
     * bitmask. 0 if reference node and given node are the same.
     * @since DOM Level 3
     * @see https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#Node3-compare
     * @see https://dom.spec.whatwg.org/#dom-node-comparedocumentposition
     */
    compareDocumentPosition: function(e2) {
      if (this === e2) return 0;
      var r2 = e2, i3 = this, a3 = null, d5 = null;
      if (r2 instanceof De && (a3 = r2, r2 = a3.ownerElement), i3 instanceof De && (d5 = i3, i3 = d5.ownerElement, a3 && r2 && i3 === r2))
        for (var N4 = 0, z2; z2 = i3.attributes[N4]; N4++) {
          if (z2 === a3)
            return S3.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + S3.DOCUMENT_POSITION_PRECEDING;
          if (z2 === d5)
            return S3.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + S3.DOCUMENT_POSITION_FOLLOWING;
        }
      if (!r2 || !i3 || i3.ownerDocument !== r2.ownerDocument)
        return S3.DOCUMENT_POSITION_DISCONNECTED + S3.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + (O5(i3.ownerDocument) > O5(r2.ownerDocument) ? S3.DOCUMENT_POSITION_FOLLOWING : S3.DOCUMENT_POSITION_PRECEDING);
      if (d5 && r2 === i3)
        return S3.DOCUMENT_POSITION_CONTAINS + S3.DOCUMENT_POSITION_PRECEDING;
      if (a3 && r2 === i3)
        return S3.DOCUMENT_POSITION_CONTAINED_BY + S3.DOCUMENT_POSITION_FOLLOWING;
      for (var se2 = [], he = r2.parentNode; he; ) {
        if (!d5 && he === i3)
          return S3.DOCUMENT_POSITION_CONTAINED_BY + S3.DOCUMENT_POSITION_FOLLOWING;
        se2.push(he), he = he.parentNode;
      }
      se2.reverse();
      for (var ve = [], me = i3.parentNode; me; ) {
        if (!a3 && me === r2)
          return S3.DOCUMENT_POSITION_CONTAINS + S3.DOCUMENT_POSITION_PRECEDING;
        ve.push(me), me = me.parentNode;
      }
      ve.reverse();
      var Xe = V2(se2, ve);
      for (var Ie in Xe.childNodes) {
        var be = Xe.childNodes[Ie];
        if (be === i3) return S3.DOCUMENT_POSITION_FOLLOWING;
        if (be === r2) return S3.DOCUMENT_POSITION_PRECEDING;
        if (ve.indexOf(be) >= 0) return S3.DOCUMENT_POSITION_FOLLOWING;
        if (se2.indexOf(be) >= 0) return S3.DOCUMENT_POSITION_PRECEDING;
      }
      return 0;
    }
  };
  function Fe(e2) {
    return e2 == "<" && "&lt;" || e2 == ">" && "&gt;" || e2 == "&" && "&amp;" || e2 == '"' && "&quot;" || "&#" + e2.charCodeAt() + ";";
  }
  m2(I2, R3), m2(I2, R3.prototype), m2(S3, R3), m2(S3, R3.prototype);
  function ye(e2, r2) {
    if (r2(e2))
      return true;
    if (e2 = e2.firstChild)
      do
        if (ye(e2, r2))
          return true;
      while (e2 = e2.nextSibling);
  }
  function ce2(e2, r2) {
    Y2(e2);
    var i3 = r2 || {};
    this.ownerDocument = this, this.contentType = i3.contentType || v2.XML_APPLICATION, this.type = c4(this.contentType) ? "html" : "xml";
  }
  function Le(e2, r2, i3) {
    e2 && e2._inc++;
    var a3 = i3.namespaceURI;
    a3 === f7.XMLNS && (r2._nsMap[i3.prefix ? i3.localName : ""] = i3.value);
  }
  function _e12(e2, r2, i3, a3) {
    e2 && e2._inc++;
    var d5 = i3.namespaceURI;
    d5 === f7.XMLNS && delete r2._nsMap[i3.prefix ? i3.localName : ""];
  }
  function Ce(e2, r2, i3) {
    if (e2 && e2._inc) {
      e2._inc++;
      var a3 = r2.childNodes;
      if (i3 && !i3.nextSibling)
        a3[a3.length++] = i3;
      else {
        for (var d5 = r2.firstChild, N4 = 0; d5; )
          a3[N4++] = d5, d5 = d5.nextSibling;
        a3.length = N4, delete a3[a3.length];
      }
    }
  }
  function Re(e2, r2) {
    if (e2 !== r2.parentNode)
      throw new p4(p4.NOT_FOUND_ERR, "child's parent is not parent");
    var i3 = r2.previousSibling, a3 = r2.nextSibling;
    return i3 ? i3.nextSibling = a3 : e2.firstChild = a3, a3 ? a3.previousSibling = i3 : e2.lastChild = i3, Ce(e2.ownerDocument, e2), r2.parentNode = null, r2.previousSibling = null, r2.nextSibling = null, r2;
  }
  function Ue(e2) {
    return e2 && (e2.nodeType === R3.DOCUMENT_NODE || e2.nodeType === R3.DOCUMENT_FRAGMENT_NODE || e2.nodeType === R3.ELEMENT_NODE);
  }
  function qe(e2) {
    return e2 && (e2.nodeType === R3.CDATA_SECTION_NODE || e2.nodeType === R3.COMMENT_NODE || e2.nodeType === R3.DOCUMENT_FRAGMENT_NODE || e2.nodeType === R3.DOCUMENT_TYPE_NODE || e2.nodeType === R3.ELEMENT_NODE || e2.nodeType === R3.PROCESSING_INSTRUCTION_NODE || e2.nodeType === R3.TEXT_NODE);
  }
  function Ae(e2) {
    return e2 && e2.nodeType === R3.DOCUMENT_TYPE_NODE;
  }
  function j2(e2) {
    return e2 && e2.nodeType === R3.ELEMENT_NODE;
  }
  function Pe(e2) {
    return e2 && e2.nodeType === R3.TEXT_NODE;
  }
  function ne(e2, r2) {
    var i3 = e2.childNodes || [];
    if (t3(i3, j2) || Ae(r2))
      return false;
    var a3 = t3(i3, Ae);
    return !(r2 && a3 && i3.indexOf(a3) > i3.indexOf(r2));
  }
  function Ge(e2, r2) {
    var i3 = e2.childNodes || [];
    function a3(N4) {
      return j2(N4) && N4 !== r2;
    }
    if (t3(i3, a3))
      return false;
    var d5 = t3(i3, Ae);
    return !(r2 && d5 && i3.indexOf(d5) > i3.indexOf(r2));
  }
  function at(e2, r2, i3) {
    if (!Ue(e2))
      throw new p4(p4.HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + e2.nodeType);
    if (i3 && i3.parentNode !== e2)
      throw new p4(p4.NOT_FOUND_ERR, "child not in parent");
    if (
      // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
      !qe(r2) || // 5. If either `node` is a Text node and `parent` is a document,
      // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
      // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
      // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
      Ae(r2) && e2.nodeType !== R3.DOCUMENT_NODE
    )
      throw new p4(
        p4.HIERARCHY_REQUEST_ERR,
        "Unexpected node type " + r2.nodeType + " for parent node type " + e2.nodeType
      );
  }
  function Ve(e2, r2, i3) {
    var a3 = e2.childNodes || [], d5 = r2.childNodes || [];
    if (r2.nodeType === R3.DOCUMENT_FRAGMENT_NODE) {
      var N4 = d5.filter(j2);
      if (N4.length > 1 || t3(d5, Pe))
        throw new p4(p4.HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
      if (N4.length === 1 && !ne(e2, i3))
        throw new p4(p4.HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
    }
    if (j2(r2) && !ne(e2, i3))
      throw new p4(p4.HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
    if (Ae(r2)) {
      if (t3(a3, Ae))
        throw new p4(p4.HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
      var z2 = t3(a3, j2);
      if (i3 && a3.indexOf(z2) < a3.indexOf(i3))
        throw new p4(p4.HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
      if (!i3 && z2)
        throw new p4(p4.HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
    }
  }
  function ze(e2, r2, i3) {
    var a3 = e2.childNodes || [], d5 = r2.childNodes || [];
    if (r2.nodeType === R3.DOCUMENT_FRAGMENT_NODE) {
      var N4 = d5.filter(j2);
      if (N4.length > 1 || t3(d5, Pe))
        throw new p4(p4.HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
      if (N4.length === 1 && !Ge(e2, i3))
        throw new p4(p4.HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
    }
    if (j2(r2) && !Ge(e2, i3))
      throw new p4(p4.HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
    if (Ae(r2)) {
      if (t3(a3, function(he) {
        return Ae(he) && he !== i3;
      }))
        throw new p4(p4.HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
      var z2 = t3(a3, j2);
      if (i3 && a3.indexOf(z2) < a3.indexOf(i3))
        throw new p4(p4.HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
    }
  }
  function F2(e2, r2, i3, a3) {
    at(e2, r2, i3), e2.nodeType === R3.DOCUMENT_NODE && (a3 || Ve)(e2, r2, i3);
    var d5 = r2.parentNode;
    if (d5 && d5.removeChild(r2), r2.nodeType === y6) {
      var N4 = r2.firstChild;
      if (N4 == null)
        return r2;
      var z2 = r2.lastChild;
    } else
      N4 = z2 = r2;
    var se2 = i3 ? i3.previousSibling : e2.lastChild;
    N4.previousSibling = se2, z2.nextSibling = i3, se2 ? se2.nextSibling = N4 : e2.firstChild = N4, i3 == null ? e2.lastChild = z2 : i3.previousSibling = z2;
    do
      N4.parentNode = e2;
    while (N4 !== z2 && (N4 = N4.nextSibling));
    return Ce(e2.ownerDocument || e2, e2, r2), r2.nodeType == y6 && (r2.firstChild = r2.lastChild = null), r2;
  }
  ce2.prototype = {
    /**
     * The implementation that created this document.
     *
     * @type DOMImplementation
     * @readonly
     */
    implementation: null,
    nodeName: "#document",
    nodeType: b4,
    /**
     * The DocumentType node of the document.
     *
     * @type DocumentType
     * @readonly
     */
    doctype: null,
    documentElement: null,
    _inc: 1,
    insertBefore: function(e2, r2) {
      if (e2.nodeType === y6) {
        for (var i3 = e2.firstChild; i3; ) {
          var a3 = i3.nextSibling;
          this.insertBefore(i3, r2), i3 = a3;
        }
        return e2;
      }
      return F2(this, e2, r2), e2.ownerDocument = this, this.documentElement === null && e2.nodeType === U4 && (this.documentElement = e2), e2;
    },
    removeChild: function(e2) {
      var r2 = Re(this, e2);
      return r2 === this.documentElement && (this.documentElement = null), r2;
    },
    replaceChild: function(e2, r2) {
      F2(this, e2, r2, ze), e2.ownerDocument = this, r2 && this.removeChild(r2), j2(e2) && (this.documentElement = e2);
    },
    // Introduced in DOM Level 2:
    importNode: function(e2, r2) {
      return Tt(this, e2, r2);
    },
    // Introduced in DOM Level 2:
    getElementById: function(e2) {
      var r2 = null;
      return ye(this.documentElement, function(i3) {
        if (i3.nodeType == U4 && i3.getAttribute("id") == e2)
          return r2 = i3, true;
      }), r2;
    },
    /**
     * Creates a new `Element` that is owned by this `Document`.
     * In HTML Documents `localName` is the lower cased `tagName`,
     * otherwise no transformation is being applied.
     * When `contentType` implies the HTML namespace, it will be set as `namespaceURI`.
     *
     * __This implementation differs from the specification:__ - The provided name is not checked
     * against the `Name` production,
     * so no related error will be thrown.
     * - There is no interface `HTMLElement`, it is always an `Element`.
     * - There is no support for a second argument to indicate using custom elements.
     *
     * @param {string} tagName
     * @returns {Element}
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement
     * @see https://dom.spec.whatwg.org/#dom-document-createelement
     * @see https://dom.spec.whatwg.org/#concept-create-element
     */
    createElement: function(e2) {
      var r2 = new Q2(g4);
      r2.ownerDocument = this, this.type === "html" && (e2 = e2.toLowerCase()), u2(this.contentType) && (r2.namespaceURI = f7.HTML), r2.nodeName = e2, r2.tagName = e2, r2.localName = e2, r2.childNodes = new C();
      var i3 = r2.attributes = new P2();
      return i3._ownerElement = r2, r2;
    },
    /**
     * @returns {DocumentFragment}
     */
    createDocumentFragment: function() {
      var e2 = new Ye(g4);
      return e2.ownerDocument = this, e2.childNodes = new C(), e2;
    },
    /**
     * @param {string} data
     * @returns {Text}
     */
    createTextNode: function(e2) {
      var r2 = new He(g4);
      return r2.ownerDocument = this, r2.childNodes = new C(), r2.appendData(e2), r2;
    },
    /**
     * @param {string} data
     * @returns {Comment}
     */
    createComment: function(e2) {
      var r2 = new Je(g4);
      return r2.ownerDocument = this, r2.childNodes = new C(), r2.appendData(e2), r2;
    },
    /**
     * @param {string} data
     * @returns {CDATASection}
     */
    createCDATASection: function(e2) {
      var r2 = new Ze(g4);
      return r2.ownerDocument = this, r2.childNodes = new C(), r2.appendData(e2), r2;
    },
    /**
     * @param {string} target
     * @param {string} data
     * @returns {ProcessingInstruction}
     */
    createProcessingInstruction: function(e2, r2) {
      var i3 = new tt(g4);
      return i3.ownerDocument = this, i3.childNodes = new C(), i3.nodeName = i3.target = e2, i3.nodeValue = i3.data = r2, i3;
    },
    /**
     * Creates an `Attr` node that is owned by this document.
     * In HTML Documents `localName` is the lower cased `name`,
     * otherwise no transformation is being applied.
     *
     * __This implementation differs from the specification:__ - The provided name is not checked
     * against the `Name` production,
     * so no related error will be thrown.
     *
     * @param {string} name
     * @returns {Attr}
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/createAttribute
     * @see https://dom.spec.whatwg.org/#dom-document-createattribute
     */
    createAttribute: function(e2) {
      if (!k4.QName_exact.test(e2))
        throw new p4(p4.INVALID_CHARACTER_ERR, 'invalid character in name "' + e2 + '"');
      return this.type === "html" && (e2 = e2.toLowerCase()), this._createAttribute(e2);
    },
    _createAttribute: function(e2) {
      var r2 = new De(g4);
      return r2.ownerDocument = this, r2.childNodes = new C(), r2.name = e2, r2.nodeName = e2, r2.localName = e2, r2.specified = true, r2;
    },
    /**
     * Creates an EntityReference object.
     * The current implementation does not fill the `childNodes` with those of the corresponding
     * `Entity`
     *
     * @deprecated
     * In DOM Level 4.
     * @param {string} name
     * The name of the entity to reference. No namespace well-formedness checks are performed.
     * @returns {EntityReference}
     * @throws {DOMException}
     * With code `INVALID_CHARACTER_ERR` when `name` is not valid.
     * @throws {DOMException}
     * with code `NOT_SUPPORTED_ERR` when the document is of type `html`
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-392B75AE
     */
    createEntityReference: function(e2) {
      if (!k4.Name.test(e2))
        throw new p4(p4.INVALID_CHARACTER_ERR, 'not a valid xml name "' + e2 + '"');
      if (this.type === "html")
        throw new p4("document is an html document", B2.NotSupportedError);
      var r2 = new et(g4);
      return r2.ownerDocument = this, r2.childNodes = new C(), r2.nodeName = e2, r2;
    },
    // Introduced in DOM Level 2:
    /**
     * @param {string} namespaceURI
     * @param {string} qualifiedName
     * @returns {Element}
     */
    createElementNS: function(e2, r2) {
      var i3 = de2(e2, r2), a3 = new Q2(g4), d5 = a3.attributes = new P2();
      return a3.childNodes = new C(), a3.ownerDocument = this, a3.nodeName = r2, a3.tagName = r2, a3.namespaceURI = i3[0], a3.prefix = i3[1], a3.localName = i3[2], d5._ownerElement = a3, a3;
    },
    // Introduced in DOM Level 2:
    /**
     * @param {string} namespaceURI
     * @param {string} qualifiedName
     * @returns {Attr}
     */
    createAttributeNS: function(e2, r2) {
      var i3 = de2(e2, r2), a3 = new De(g4);
      return a3.ownerDocument = this, a3.childNodes = new C(), a3.nodeName = r2, a3.name = r2, a3.specified = true, a3.namespaceURI = i3[0], a3.prefix = i3[1], a3.localName = i3[2], a3;
    }
  }, _2(ce2, R3);
  function Q2(e2) {
    Y2(e2), this._nsMap = /* @__PURE__ */ Object.create(null);
  }
  Q2.prototype = {
    nodeType: U4,
    /**
     * The attributes of this element.
     *
     * @type {NamedNodeMap | null}
     */
    attributes: null,
    getQualifiedName: function() {
      return this.prefix ? this.prefix + ":" + this.localName : this.localName;
    },
    _isInHTMLDocumentAndNamespace: function() {
      return this.ownerDocument.type === "html" && this.namespaceURI === f7.HTML;
    },
    /**
     * Implementaton of Level2 Core function hasAttributes.
     *
     * @returns {boolean}
     * True if attribute list is not empty.
     * @see https://www.w3.org/TR/DOM-Level-2-Core/#core-ID-NodeHasAttrs
     */
    hasAttributes: function() {
      return !!(this.attributes && this.attributes.length);
    },
    hasAttribute: function(e2) {
      return !!this.getAttributeNode(e2);
    },
    /**
     * Returns elements first attribute whose qualified name is `name`, and `null`
     * if there is no such attribute.
     *
     * @param {string} name
     * @returns {string | null}
     */
    getAttribute: function(e2) {
      var r2 = this.getAttributeNode(e2);
      return r2 ? r2.value : null;
    },
    getAttributeNode: function(e2) {
      return this._isInHTMLDocumentAndNamespace() && (e2 = e2.toLowerCase()), this.attributes.getNamedItem(e2);
    },
    /**
     * Sets the value of elements first attribute whose qualified name is qualifiedName to value.
     *
     * @param {string} name
     * @param {string} value
     */
    setAttribute: function(e2, r2) {
      this._isInHTMLDocumentAndNamespace() && (e2 = e2.toLowerCase());
      var i3 = this.getAttributeNode(e2);
      i3 ? i3.value = i3.nodeValue = "" + r2 : (i3 = this.ownerDocument._createAttribute(e2), i3.value = i3.nodeValue = "" + r2, this.setAttributeNode(i3));
    },
    removeAttribute: function(e2) {
      var r2 = this.getAttributeNode(e2);
      r2 && this.removeAttributeNode(r2);
    },
    setAttributeNode: function(e2) {
      return this.attributes.setNamedItem(e2);
    },
    setAttributeNodeNS: function(e2) {
      return this.attributes.setNamedItemNS(e2);
    },
    removeAttributeNode: function(e2) {
      return this.attributes.removeNamedItem(e2.nodeName);
    },
    //get real attribute name,and remove it by removeAttributeNode
    removeAttributeNS: function(e2, r2) {
      var i3 = this.getAttributeNodeNS(e2, r2);
      i3 && this.removeAttributeNode(i3);
    },
    hasAttributeNS: function(e2, r2) {
      return this.getAttributeNodeNS(e2, r2) != null;
    },
    /**
     * Returns elements attribute whose namespace is `namespaceURI` and local name is
     * `localName`,
     * or `null` if there is no such attribute.
     *
     * @param {string} namespaceURI
     * @param {string} localName
     * @returns {string | null}
     */
    getAttributeNS: function(e2, r2) {
      var i3 = this.getAttributeNodeNS(e2, r2);
      return i3 ? i3.value : null;
    },
    /**
     * Sets the value of elements attribute whose namespace is `namespaceURI` and local name is
     * `localName` to value.
     *
     * @param {string} namespaceURI
     * @param {string} qualifiedName
     * @param {string} value
     * @see https://dom.spec.whatwg.org/#dom-element-setattributens
     */
    setAttributeNS: function(e2, r2, i3) {
      var a3 = de2(e2, r2), d5 = a3[2], N4 = this.getAttributeNodeNS(e2, d5);
      N4 ? N4.value = N4.nodeValue = "" + i3 : (N4 = this.ownerDocument.createAttributeNS(e2, r2), N4.value = N4.nodeValue = "" + i3, this.setAttributeNode(N4));
    },
    getAttributeNodeNS: function(e2, r2) {
      return this.attributes.getNamedItemNS(e2, r2);
    },
    /**
     * Returns a LiveNodeList of all child elements which have **all** of the given class name(s).
     *
     * Returns an empty list if `classNames` is an empty string or only contains HTML white space
     * characters.
     *
     * Warning: This returns a live LiveNodeList.
     * Changes in the DOM will reflect in the array as the changes occur.
     * If an element selected by this array no longer qualifies for the selector,
     * it will automatically be removed. Be aware of this for iteration purposes.
     *
     * @param {string} classNames
     * Is a string representing the class name(s) to match; multiple class names are separated by
     * (ASCII-)whitespace.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByClassName
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
     * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
     */
    getElementsByClassName: function(e2) {
      var r2 = q3(e2);
      return new w3(this, function(i3) {
        var a3 = [];
        return r2.length > 0 && ye(i3, function(d5) {
          if (d5 !== i3 && d5.nodeType === U4) {
            var N4 = d5.getAttribute("class");
            if (N4) {
              var z2 = e2 === N4;
              if (!z2) {
                var se2 = q3(N4);
                z2 = r2.every(W(se2));
              }
              z2 && a3.push(d5);
            }
          }
        }), a3;
      });
    },
    /**
     * Returns a LiveNodeList of elements with the given qualifiedName.
     * Searching for all descendants can be done by passing `*` as `qualifiedName`.
     *
     * All descendants of the specified element are searched, but not the element itself.
     * The returned list is live, which means it updates itself with the DOM tree automatically.
     * Therefore, there is no need to call `Element.getElementsByTagName()`
     * with the same element and arguments repeatedly if the DOM changes in between calls.
     *
     * When called on an HTML element in an HTML document,
     * `getElementsByTagName` lower-cases the argument before searching for it.
     * This is undesirable when trying to match camel-cased SVG elements (such as
     * `<linearGradient>`) in an HTML document.
     * Instead, use `Element.getElementsByTagNameNS()`,
     * which preserves the capitalization of the tag name.
     *
     * `Element.getElementsByTagName` is similar to `Document.getElementsByTagName()`,
     * except that it only searches for elements that are descendants of the specified element.
     *
     * @param {string} qualifiedName
     * @returns {LiveNodeList}
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName
     * @see https://dom.spec.whatwg.org/#concept-getelementsbytagname
     */
    getElementsByTagName: function(e2) {
      var r2 = (this.nodeType === b4 ? this : this.ownerDocument).type === "html", i3 = e2.toLowerCase();
      return new w3(this, function(a3) {
        var d5 = [];
        return ye(a3, function(N4) {
          if (!(N4 === a3 || N4.nodeType !== U4))
            if (e2 === "*")
              d5.push(N4);
            else {
              var z2 = N4.getQualifiedName(), se2 = r2 && N4.namespaceURI === f7.HTML ? i3 : e2;
              z2 === se2 && d5.push(N4);
            }
        }), d5;
      });
    },
    getElementsByTagNameNS: function(e2, r2) {
      return new w3(this, function(i3) {
        var a3 = [];
        return ye(i3, function(d5) {
          d5 !== i3 && d5.nodeType === U4 && (e2 === "*" || d5.namespaceURI === e2) && (r2 === "*" || d5.localName == r2) && a3.push(d5);
        }), a3;
      });
    }
  }, ce2.prototype.getElementsByClassName = Q2.prototype.getElementsByClassName, ce2.prototype.getElementsByTagName = Q2.prototype.getElementsByTagName, ce2.prototype.getElementsByTagNameNS = Q2.prototype.getElementsByTagNameNS, _2(Q2, R3);
  function De(e2) {
    Y2(e2), this.namespaceURI = null, this.prefix = null, this.ownerElement = null;
  }
  De.prototype.nodeType = $3, _2(De, R3);
  function ge(e2) {
    Y2(e2);
  }
  ge.prototype = {
    data: "",
    substringData: function(e2, r2) {
      return this.data.substring(e2, e2 + r2);
    },
    appendData: function(e2) {
      e2 = this.data + e2, this.nodeValue = this.data = e2, this.length = e2.length;
    },
    insertData: function(e2, r2) {
      this.replaceData(e2, 0, r2);
    },
    deleteData: function(e2, r2) {
      this.replaceData(e2, r2, "");
    },
    replaceData: function(e2, r2, i3) {
      var a3 = this.data.substring(0, e2), d5 = this.data.substring(e2 + r2);
      i3 = a3 + i3 + d5, this.nodeValue = this.data = i3, this.length = i3.length;
    }
  }, _2(ge, R3);
  function He(e2) {
    Y2(e2);
  }
  He.prototype = {
    nodeName: "#text",
    nodeType: J2,
    splitText: function(e2) {
      var r2 = this.data, i3 = r2.substring(e2);
      r2 = r2.substring(0, e2), this.data = this.nodeValue = r2, this.length = r2.length;
      var a3 = this.ownerDocument.createTextNode(i3);
      return this.parentNode && this.parentNode.insertBefore(a3, this.nextSibling), a3;
    }
  }, _2(He, ge);
  function Je(e2) {
    Y2(e2);
  }
  Je.prototype = {
    nodeName: "#comment",
    nodeType: A4
  }, _2(Je, ge);
  function Ze(e2) {
    Y2(e2);
  }
  Ze.prototype = {
    nodeName: "#cdata-section",
    nodeType: Ne
  }, _2(Ze, He);
  function Ke(e2) {
    Y2(e2);
  }
  Ke.prototype.nodeType = T4, _2(Ke, R3);
  function ot(e2) {
    Y2(e2);
  }
  ot.prototype.nodeType = E2, _2(ot, R3);
  function ct(e2) {
    Y2(e2);
  }
  ct.prototype.nodeType = we, _2(ct, R3);
  function et(e2) {
    Y2(e2);
  }
  et.prototype.nodeType = Z2, _2(et, R3);
  function Ye(e2) {
    Y2(e2);
  }
  Ye.prototype.nodeName = "#document-fragment", Ye.prototype.nodeType = y6, _2(Ye, R3);
  function tt(e2) {
    Y2(e2);
  }
  tt.prototype.nodeType = l6, _2(tt, ge);
  function dt() {
  }
  dt.prototype.serializeToString = function(e2, r2) {
    return ee.call(e2, r2);
  }, R3.prototype.toString = ee;
  function ee(e2) {
    var r2 = [], i3 = this.nodeType === b4 && this.documentElement || this, a3 = i3.prefix, d5 = i3.namespaceURI;
    if (d5 && a3 == null) {
      var a3 = i3.lookupPrefix(d5);
      if (a3 == null)
        var N4 = [
          { namespace: d5, prefix: null }
          //{namespace:uri,prefix:''}
        ];
    }
    return xe(this, r2, e2, N4), r2.join("");
  }
  function le(e2, r2, i3) {
    var a3 = e2.prefix || "", d5 = e2.namespaceURI;
    if (!d5 || a3 === "xml" && d5 === f7.XML || d5 === f7.XMLNS)
      return false;
    for (var N4 = i3.length; N4--; ) {
      var z2 = i3[N4];
      if (z2.prefix === a3)
        return z2.namespace !== d5;
    }
    return true;
  }
  function Me(e2, r2, i3) {
    e2.push(" ", r2, '="', i3.replace(/[<>&"\t\n\r]/g, Fe), '"');
  }
  function xe(e2, r2, i3, a3) {
    a3 || (a3 = []);
    var d5 = e2.nodeType === b4 ? e2 : e2.ownerDocument, N4 = d5.type === "html";
    if (i3)
      if (e2 = i3(e2), e2) {
        if (typeof e2 == "string") {
          r2.push(e2);
          return;
        }
      } else
        return;
    switch (e2.nodeType) {
      case U4:
        var z2 = e2.attributes, se2 = z2.length, pe = e2.firstChild, he = e2.tagName, ve = he;
        if (!N4 && !e2.prefix && e2.namespaceURI) {
          for (var me, Xe = 0; Xe < z2.length; Xe++)
            if (z2.item(Xe).name === "xmlns") {
              me = z2.item(Xe).value;
              break;
            }
          if (!me)
            for (var Ie = a3.length - 1; Ie >= 0; Ie--) {
              var be = a3[Ie];
              if (be.prefix === "" && be.namespace === e2.namespaceURI) {
                me = be.namespace;
                break;
              }
            }
          if (me !== e2.namespaceURI)
            for (var Ie = a3.length - 1; Ie >= 0; Ie--) {
              var be = a3[Ie];
              if (be.namespace === e2.namespaceURI) {
                be.prefix && (ve = be.prefix + ":" + he);
                break;
              }
            }
        }
        r2.push("<", ve);
        for (var $e = 0; $e < se2; $e++) {
          var Se = z2.item($e);
          Se.prefix == "xmlns" ? a3.push({
            prefix: Se.localName,
            namespace: Se.value
          }) : Se.nodeName == "xmlns" && a3.push({ prefix: "", namespace: Se.value });
        }
        for (var $e = 0; $e < se2; $e++) {
          var Se = z2.item($e);
          if (le(Se, N4, a3)) {
            var je = Se.prefix || "", lt = Se.namespaceURI;
            Me(r2, je ? "xmlns:" + je : "xmlns", lt), a3.push({ prefix: je, namespace: lt });
          }
          xe(Se, r2, i3, a3);
        }
        if (he === ve && le(e2, N4, a3)) {
          var je = e2.prefix || "", lt = e2.namespaceURI;
          Me(r2, je ? "xmlns:" + je : "xmlns", lt), a3.push({ prefix: je, namespace: lt });
        }
        var Dt = !pe;
        if (Dt && (N4 || e2.namespaceURI === f7.HTML) && (Dt = h4(he)), Dt)
          r2.push("/>");
        else {
          if (r2.push(">"), N4 && o5(he))
            for (; pe; )
              pe.data ? r2.push(pe.data) : xe(pe, r2, i3, a3.slice()), pe = pe.nextSibling;
          else
            for (; pe; )
              xe(pe, r2, i3, a3.slice()), pe = pe.nextSibling;
          r2.push("</", ve, ">");
        }
        return;
      case b4:
      case y6:
        for (var pe = e2.firstChild; pe; )
          xe(pe, r2, i3, a3.slice()), pe = pe.nextSibling;
        return;
      case $3:
        return Me(r2, e2.name, e2.value);
      case J2:
        return r2.push(e2.data.replace(/[<&>]/g, Fe));
      case Ne:
        return r2.push(k4.CDATA_START, e2.data, k4.CDATA_END);
      case A4:
        return r2.push(k4.COMMENT_START, e2.data, k4.COMMENT_END);
      case T4:
        var bt = e2.publicId, rt = e2.systemId;
        r2.push(k4.DOCTYPE_DECL_START, " ", e2.name), bt ? (r2.push(" ", k4.PUBLIC, " ", bt), rt && rt !== "." && r2.push(" ", rt)) : rt && rt !== "." && r2.push(" ", k4.SYSTEM, " ", rt), e2.internalSubset && r2.push(" [", e2.internalSubset, "]"), r2.push(">");
        return;
      case l6:
        return r2.push("<?", e2.target, " ", e2.data, "?>");
      case Z2:
        return r2.push("&", e2.nodeName, ";");
      //case ENTITY_NODE:
      //case NOTATION_NODE:
      default:
        r2.push("??", e2.nodeName);
    }
  }
  function Tt(e2, r2, i3) {
    var a3;
    switch (r2.nodeType) {
      case U4:
        a3 = r2.cloneNode(false), a3.ownerDocument = e2;
      //var attrs = node2.attributes;
      //var len = attrs.length;
      //for(var i=0;i<len;i++){
      //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
      //}
      case y6:
        break;
      case $3:
        i3 = true;
        break;
    }
    if (a3 || (a3 = r2.cloneNode(false)), a3.ownerDocument = e2, a3.parentNode = null, i3)
      for (var d5 = r2.firstChild; d5; )
        a3.appendChild(Tt(e2, d5, i3)), d5 = d5.nextSibling;
    return a3;
  }
  function Et(e2, r2, i3) {
    var a3 = new r2.constructor(g4);
    for (var d5 in r2)
      if (s4(r2, d5)) {
        var N4 = r2[d5];
        typeof N4 != "object" && N4 != a3[d5] && (a3[d5] = N4);
      }
    switch (r2.childNodes && (a3.childNodes = new C()), a3.ownerDocument = e2, a3.nodeType) {
      case U4:
        var z2 = r2.attributes, se2 = a3.attributes = new P2(), he = z2.length;
        se2._ownerElement = a3;
        for (var ve = 0; ve < he; ve++)
          a3.setAttributeNode(Et(e2, z2.item(ve), true));
        break;
      case $3:
        i3 = true;
    }
    if (i3)
      for (var me = r2.firstChild; me; )
        a3.appendChild(Et(e2, me, i3)), me = me.nextSibling;
    return a3;
  }
  function Ct(e2, r2, i3) {
    e2[r2] = i3;
  }
  try {
    if (Object.defineProperty) {
      let e2 = function(r2) {
        switch (r2.nodeType) {
          case U4:
          case y6:
            var i3 = [];
            for (r2 = r2.firstChild; r2; )
              r2.nodeType !== 7 && r2.nodeType !== 8 && i3.push(e2(r2)), r2 = r2.nextSibling;
            return i3.join("");
          default:
            return r2.nodeValue;
        }
      };
      Object.defineProperty(w3.prototype, "length", {
        get: function() {
          return x4(this), this.$$length;
        }
      }), Object.defineProperty(R3.prototype, "textContent", {
        get: function() {
          return e2(this);
        },
        set: function(r2) {
          switch (this.nodeType) {
            case U4:
            case y6:
              for (; this.firstChild; )
                this.removeChild(this.firstChild);
              (r2 || String(r2)) && this.appendChild(this.ownerDocument.createTextNode(r2));
              break;
            default:
              this.data = r2, this.value = r2, this.nodeValue = r2;
          }
        }
      }), Ct = function(r2, i3, a3) {
        r2["$$" + i3] = a3;
      };
    }
  } catch {
  }
  return K2._updateLiveList = x4, K2.Attr = De, K2.CDATASection = Ze, K2.CharacterData = ge, K2.Comment = Je, K2.Document = ce2, K2.DocumentFragment = Ye, K2.DocumentType = Ke, K2.DOMImplementation = ie, K2.Element = Q2, K2.Entity = ct, K2.EntityReference = et, K2.LiveNodeList = w3, K2.NamedNodeMap = P2, K2.Node = R3, K2.NodeList = C, K2.Notation = ot, K2.Text = He, K2.ProcessingInstruction = tt, K2.XMLSerializer = dt, K2;
}
var We = {};
var gt = {};
var Ot;
function Dr() {
  return Ot || (Ot = 1, (function(n2) {
    var t3 = st().freeze;
    n2.XML_ENTITIES = t3({
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    }), n2.HTML_ENTITIES = t3({
      Aacute: "",
      aacute: "",
      Abreve: "",
      abreve: "",
      ac: "",
      acd: "",
      acE: "",
      Acirc: "",
      acirc: "",
      acute: "",
      Acy: "",
      acy: "",
      AElig: "",
      aelig: "",
      af: "",
      Afr: "",
      afr: "",
      Agrave: "",
      agrave: "",
      alefsym: "",
      aleph: "",
      Alpha: "",
      alpha: "",
      Amacr: "",
      amacr: "",
      amalg: "",
      AMP: "&",
      amp: "&",
      And: "",
      and: "",
      andand: "",
      andd: "",
      andslope: "",
      andv: "",
      ang: "",
      ange: "",
      angle: "",
      angmsd: "",
      angmsdaa: "",
      angmsdab: "",
      angmsdac: "",
      angmsdad: "",
      angmsdae: "",
      angmsdaf: "",
      angmsdag: "",
      angmsdah: "",
      angrt: "",
      angrtvb: "",
      angrtvbd: "",
      angsph: "",
      angst: "",
      angzarr: "",
      Aogon: "",
      aogon: "",
      Aopf: "",
      aopf: "",
      ap: "",
      apacir: "",
      apE: "",
      ape: "",
      apid: "",
      apos: "'",
      ApplyFunction: "",
      approx: "",
      approxeq: "",
      Aring: "",
      aring: "",
      Ascr: "",
      ascr: "",
      Assign: "",
      ast: "*",
      asymp: "",
      asympeq: "",
      Atilde: "",
      atilde: "",
      Auml: "",
      auml: "",
      awconint: "",
      awint: "",
      backcong: "",
      backepsilon: "",
      backprime: "",
      backsim: "",
      backsimeq: "",
      Backslash: "",
      Barv: "",
      barvee: "",
      Barwed: "",
      barwed: "",
      barwedge: "",
      bbrk: "",
      bbrktbrk: "",
      bcong: "",
      Bcy: "",
      bcy: "",
      bdquo: "",
      becaus: "",
      Because: "",
      because: "",
      bemptyv: "",
      bepsi: "",
      bernou: "",
      Bernoullis: "",
      Beta: "",
      beta: "",
      beth: "",
      between: "",
      Bfr: "",
      bfr: "",
      bigcap: "",
      bigcirc: "",
      bigcup: "",
      bigodot: "",
      bigoplus: "",
      bigotimes: "",
      bigsqcup: "",
      bigstar: "",
      bigtriangledown: "",
      bigtriangleup: "",
      biguplus: "",
      bigvee: "",
      bigwedge: "",
      bkarow: "",
      blacklozenge: "",
      blacksquare: "",
      blacktriangle: "",
      blacktriangledown: "",
      blacktriangleleft: "",
      blacktriangleright: "",
      blank: "",
      blk12: "",
      blk14: "",
      blk34: "",
      block: "",
      bne: "=",
      bnequiv: "",
      bNot: "",
      bnot: "",
      Bopf: "",
      bopf: "",
      bot: "",
      bottom: "",
      bowtie: "",
      boxbox: "",
      boxDL: "",
      boxDl: "",
      boxdL: "",
      boxdl: "",
      boxDR: "",
      boxDr: "",
      boxdR: "",
      boxdr: "",
      boxH: "",
      boxh: "",
      boxHD: "",
      boxHd: "",
      boxhD: "",
      boxhd: "",
      boxHU: "",
      boxHu: "",
      boxhU: "",
      boxhu: "",
      boxminus: "",
      boxplus: "",
      boxtimes: "",
      boxUL: "",
      boxUl: "",
      boxuL: "",
      boxul: "",
      boxUR: "",
      boxUr: "",
      boxuR: "",
      boxur: "",
      boxV: "",
      boxv: "",
      boxVH: "",
      boxVh: "",
      boxvH: "",
      boxvh: "",
      boxVL: "",
      boxVl: "",
      boxvL: "",
      boxvl: "",
      boxVR: "",
      boxVr: "",
      boxvR: "",
      boxvr: "",
      bprime: "",
      Breve: "",
      breve: "",
      brvbar: "",
      Bscr: "",
      bscr: "",
      bsemi: "",
      bsim: "",
      bsime: "",
      bsol: "\\",
      bsolb: "",
      bsolhsub: "",
      bull: "",
      bullet: "",
      bump: "",
      bumpE: "",
      bumpe: "",
      Bumpeq: "",
      bumpeq: "",
      Cacute: "",
      cacute: "",
      Cap: "",
      cap: "",
      capand: "",
      capbrcup: "",
      capcap: "",
      capcup: "",
      capdot: "",
      CapitalDifferentialD: "",
      caps: "",
      caret: "",
      caron: "",
      Cayleys: "",
      ccaps: "",
      Ccaron: "",
      ccaron: "",
      Ccedil: "",
      ccedil: "",
      Ccirc: "",
      ccirc: "",
      Cconint: "",
      ccups: "",
      ccupssm: "",
      Cdot: "",
      cdot: "",
      cedil: "",
      Cedilla: "",
      cemptyv: "",
      cent: "",
      CenterDot: "",
      centerdot: "",
      Cfr: "",
      cfr: "",
      CHcy: "",
      chcy: "",
      check: "",
      checkmark: "",
      Chi: "",
      chi: "",
      cir: "",
      circ: "",
      circeq: "",
      circlearrowleft: "",
      circlearrowright: "",
      circledast: "",
      circledcirc: "",
      circleddash: "",
      CircleDot: "",
      circledR: "",
      circledS: "",
      CircleMinus: "",
      CirclePlus: "",
      CircleTimes: "",
      cirE: "",
      cire: "",
      cirfnint: "",
      cirmid: "",
      cirscir: "",
      ClockwiseContourIntegral: "",
      CloseCurlyDoubleQuote: "",
      CloseCurlyQuote: "",
      clubs: "",
      clubsuit: "",
      Colon: "",
      colon: ":",
      Colone: "",
      colone: "",
      coloneq: "",
      comma: ",",
      commat: "@",
      comp: "",
      compfn: "",
      complement: "",
      complexes: "",
      cong: "",
      congdot: "",
      Congruent: "",
      Conint: "",
      conint: "",
      ContourIntegral: "",
      Copf: "",
      copf: "",
      coprod: "",
      Coproduct: "",
      COPY: "",
      copy: "",
      copysr: "",
      CounterClockwiseContourIntegral: "",
      crarr: "",
      Cross: "",
      cross: "",
      Cscr: "",
      cscr: "",
      csub: "",
      csube: "",
      csup: "",
      csupe: "",
      ctdot: "",
      cudarrl: "",
      cudarrr: "",
      cuepr: "",
      cuesc: "",
      cularr: "",
      cularrp: "",
      Cup: "",
      cup: "",
      cupbrcap: "",
      CupCap: "",
      cupcap: "",
      cupcup: "",
      cupdot: "",
      cupor: "",
      cups: "",
      curarr: "",
      curarrm: "",
      curlyeqprec: "",
      curlyeqsucc: "",
      curlyvee: "",
      curlywedge: "",
      curren: "",
      curvearrowleft: "",
      curvearrowright: "",
      cuvee: "",
      cuwed: "",
      cwconint: "",
      cwint: "",
      cylcty: "",
      Dagger: "",
      dagger: "",
      daleth: "",
      Darr: "",
      dArr: "",
      darr: "",
      dash: "",
      Dashv: "",
      dashv: "",
      dbkarow: "",
      dblac: "",
      Dcaron: "",
      dcaron: "",
      Dcy: "",
      dcy: "",
      DD: "",
      dd: "",
      ddagger: "",
      ddarr: "",
      DDotrahd: "",
      ddotseq: "",
      deg: "",
      Del: "",
      Delta: "",
      delta: "",
      demptyv: "",
      dfisht: "",
      Dfr: "",
      dfr: "",
      dHar: "",
      dharl: "",
      dharr: "",
      DiacriticalAcute: "",
      DiacriticalDot: "",
      DiacriticalDoubleAcute: "",
      DiacriticalGrave: "`",
      DiacriticalTilde: "",
      diam: "",
      Diamond: "",
      diamond: "",
      diamondsuit: "",
      diams: "",
      die: "",
      DifferentialD: "",
      digamma: "",
      disin: "",
      div: "",
      divide: "",
      divideontimes: "",
      divonx: "",
      DJcy: "",
      djcy: "",
      dlcorn: "",
      dlcrop: "",
      dollar: "$",
      Dopf: "",
      dopf: "",
      Dot: "",
      dot: "",
      DotDot: "",
      doteq: "",
      doteqdot: "",
      DotEqual: "",
      dotminus: "",
      dotplus: "",
      dotsquare: "",
      doublebarwedge: "",
      DoubleContourIntegral: "",
      DoubleDot: "",
      DoubleDownArrow: "",
      DoubleLeftArrow: "",
      DoubleLeftRightArrow: "",
      DoubleLeftTee: "",
      DoubleLongLeftArrow: "",
      DoubleLongLeftRightArrow: "",
      DoubleLongRightArrow: "",
      DoubleRightArrow: "",
      DoubleRightTee: "",
      DoubleUpArrow: "",
      DoubleUpDownArrow: "",
      DoubleVerticalBar: "",
      DownArrow: "",
      Downarrow: "",
      downarrow: "",
      DownArrowBar: "",
      DownArrowUpArrow: "",
      DownBreve: "",
      downdownarrows: "",
      downharpoonleft: "",
      downharpoonright: "",
      DownLeftRightVector: "",
      DownLeftTeeVector: "",
      DownLeftVector: "",
      DownLeftVectorBar: "",
      DownRightTeeVector: "",
      DownRightVector: "",
      DownRightVectorBar: "",
      DownTee: "",
      DownTeeArrow: "",
      drbkarow: "",
      drcorn: "",
      drcrop: "",
      Dscr: "",
      dscr: "",
      DScy: "",
      dscy: "",
      dsol: "",
      Dstrok: "",
      dstrok: "",
      dtdot: "",
      dtri: "",
      dtrif: "",
      duarr: "",
      duhar: "",
      dwangle: "",
      DZcy: "",
      dzcy: "",
      dzigrarr: "",
      Eacute: "",
      eacute: "",
      easter: "",
      Ecaron: "",
      ecaron: "",
      ecir: "",
      Ecirc: "",
      ecirc: "",
      ecolon: "",
      Ecy: "",
      ecy: "",
      eDDot: "",
      Edot: "",
      eDot: "",
      edot: "",
      ee: "",
      efDot: "",
      Efr: "",
      efr: "",
      eg: "",
      Egrave: "",
      egrave: "",
      egs: "",
      egsdot: "",
      el: "",
      Element: "",
      elinters: "",
      ell: "",
      els: "",
      elsdot: "",
      Emacr: "",
      emacr: "",
      empty: "",
      emptyset: "",
      EmptySmallSquare: "",
      emptyv: "",
      EmptyVerySmallSquare: "",
      emsp: "",
      emsp13: "",
      emsp14: "",
      ENG: "",
      eng: "",
      ensp: "",
      Eogon: "",
      eogon: "",
      Eopf: "",
      eopf: "",
      epar: "",
      eparsl: "",
      eplus: "",
      epsi: "",
      Epsilon: "",
      epsilon: "",
      epsiv: "",
      eqcirc: "",
      eqcolon: "",
      eqsim: "",
      eqslantgtr: "",
      eqslantless: "",
      Equal: "",
      equals: "=",
      EqualTilde: "",
      equest: "",
      Equilibrium: "",
      equiv: "",
      equivDD: "",
      eqvparsl: "",
      erarr: "",
      erDot: "",
      Escr: "",
      escr: "",
      esdot: "",
      Esim: "",
      esim: "",
      Eta: "",
      eta: "",
      ETH: "",
      eth: "",
      Euml: "",
      euml: "",
      euro: "",
      excl: "!",
      exist: "",
      Exists: "",
      expectation: "",
      ExponentialE: "",
      exponentiale: "",
      fallingdotseq: "",
      Fcy: "",
      fcy: "",
      female: "",
      ffilig: "",
      fflig: "",
      ffllig: "",
      Ffr: "",
      ffr: "",
      filig: "",
      FilledSmallSquare: "",
      FilledVerySmallSquare: "",
      fjlig: "fj",
      flat: "",
      fllig: "",
      fltns: "",
      fnof: "",
      Fopf: "",
      fopf: "",
      ForAll: "",
      forall: "",
      fork: "",
      forkv: "",
      Fouriertrf: "",
      fpartint: "",
      frac12: "",
      frac13: "",
      frac14: "",
      frac15: "",
      frac16: "",
      frac18: "",
      frac23: "",
      frac25: "",
      frac34: "",
      frac35: "",
      frac38: "",
      frac45: "",
      frac56: "",
      frac58: "",
      frac78: "",
      frasl: "",
      frown: "",
      Fscr: "",
      fscr: "",
      gacute: "",
      Gamma: "",
      gamma: "",
      Gammad: "",
      gammad: "",
      gap: "",
      Gbreve: "",
      gbreve: "",
      Gcedil: "",
      Gcirc: "",
      gcirc: "",
      Gcy: "",
      gcy: "",
      Gdot: "",
      gdot: "",
      gE: "",
      ge: "",
      gEl: "",
      gel: "",
      geq: "",
      geqq: "",
      geqslant: "",
      ges: "",
      gescc: "",
      gesdot: "",
      gesdoto: "",
      gesdotol: "",
      gesl: "",
      gesles: "",
      Gfr: "",
      gfr: "",
      Gg: "",
      gg: "",
      ggg: "",
      gimel: "",
      GJcy: "",
      gjcy: "",
      gl: "",
      gla: "",
      glE: "",
      glj: "",
      gnap: "",
      gnapprox: "",
      gnE: "",
      gne: "",
      gneq: "",
      gneqq: "",
      gnsim: "",
      Gopf: "",
      gopf: "",
      grave: "`",
      GreaterEqual: "",
      GreaterEqualLess: "",
      GreaterFullEqual: "",
      GreaterGreater: "",
      GreaterLess: "",
      GreaterSlantEqual: "",
      GreaterTilde: "",
      Gscr: "",
      gscr: "",
      gsim: "",
      gsime: "",
      gsiml: "",
      Gt: "",
      GT: ">",
      gt: ">",
      gtcc: "",
      gtcir: "",
      gtdot: "",
      gtlPar: "",
      gtquest: "",
      gtrapprox: "",
      gtrarr: "",
      gtrdot: "",
      gtreqless: "",
      gtreqqless: "",
      gtrless: "",
      gtrsim: "",
      gvertneqq: "",
      gvnE: "",
      Hacek: "",
      hairsp: "",
      half: "",
      hamilt: "",
      HARDcy: "",
      hardcy: "",
      hArr: "",
      harr: "",
      harrcir: "",
      harrw: "",
      Hat: "^",
      hbar: "",
      Hcirc: "",
      hcirc: "",
      hearts: "",
      heartsuit: "",
      hellip: "",
      hercon: "",
      Hfr: "",
      hfr: "",
      HilbertSpace: "",
      hksearow: "",
      hkswarow: "",
      hoarr: "",
      homtht: "",
      hookleftarrow: "",
      hookrightarrow: "",
      Hopf: "",
      hopf: "",
      horbar: "",
      HorizontalLine: "",
      Hscr: "",
      hscr: "",
      hslash: "",
      Hstrok: "",
      hstrok: "",
      HumpDownHump: "",
      HumpEqual: "",
      hybull: "",
      hyphen: "",
      Iacute: "",
      iacute: "",
      ic: "",
      Icirc: "",
      icirc: "",
      Icy: "",
      icy: "",
      Idot: "",
      IEcy: "",
      iecy: "",
      iexcl: "",
      iff: "",
      Ifr: "",
      ifr: "",
      Igrave: "",
      igrave: "",
      ii: "",
      iiiint: "",
      iiint: "",
      iinfin: "",
      iiota: "",
      IJlig: "",
      ijlig: "",
      Im: "",
      Imacr: "",
      imacr: "",
      image: "",
      ImaginaryI: "",
      imagline: "",
      imagpart: "",
      imath: "",
      imof: "",
      imped: "",
      Implies: "",
      in: "",
      incare: "",
      infin: "",
      infintie: "",
      inodot: "",
      Int: "",
      int: "",
      intcal: "",
      integers: "",
      Integral: "",
      intercal: "",
      Intersection: "",
      intlarhk: "",
      intprod: "",
      InvisibleComma: "",
      InvisibleTimes: "",
      IOcy: "",
      iocy: "",
      Iogon: "",
      iogon: "",
      Iopf: "",
      iopf: "",
      Iota: "",
      iota: "",
      iprod: "",
      iquest: "",
      Iscr: "",
      iscr: "",
      isin: "",
      isindot: "",
      isinE: "",
      isins: "",
      isinsv: "",
      isinv: "",
      it: "",
      Itilde: "",
      itilde: "",
      Iukcy: "",
      iukcy: "",
      Iuml: "",
      iuml: "",
      Jcirc: "",
      jcirc: "",
      Jcy: "",
      jcy: "",
      Jfr: "",
      jfr: "",
      jmath: "",
      Jopf: "",
      jopf: "",
      Jscr: "",
      jscr: "",
      Jsercy: "",
      jsercy: "",
      Jukcy: "",
      jukcy: "",
      Kappa: "",
      kappa: "",
      kappav: "",
      Kcedil: "",
      kcedil: "",
      Kcy: "",
      kcy: "",
      Kfr: "",
      kfr: "",
      kgreen: "",
      KHcy: "",
      khcy: "",
      KJcy: "",
      kjcy: "",
      Kopf: "",
      kopf: "",
      Kscr: "",
      kscr: "",
      lAarr: "",
      Lacute: "",
      lacute: "",
      laemptyv: "",
      lagran: "",
      Lambda: "",
      lambda: "",
      Lang: "",
      lang: "",
      langd: "",
      langle: "",
      lap: "",
      Laplacetrf: "",
      laquo: "",
      Larr: "",
      lArr: "",
      larr: "",
      larrb: "",
      larrbfs: "",
      larrfs: "",
      larrhk: "",
      larrlp: "",
      larrpl: "",
      larrsim: "",
      larrtl: "",
      lat: "",
      lAtail: "",
      latail: "",
      late: "",
      lates: "",
      lBarr: "",
      lbarr: "",
      lbbrk: "",
      lbrace: "{",
      lbrack: "[",
      lbrke: "",
      lbrksld: "",
      lbrkslu: "",
      Lcaron: "",
      lcaron: "",
      Lcedil: "",
      lcedil: "",
      lceil: "",
      lcub: "{",
      Lcy: "",
      lcy: "",
      ldca: "",
      ldquo: "",
      ldquor: "",
      ldrdhar: "",
      ldrushar: "",
      ldsh: "",
      lE: "",
      le: "",
      LeftAngleBracket: "",
      LeftArrow: "",
      Leftarrow: "",
      leftarrow: "",
      LeftArrowBar: "",
      LeftArrowRightArrow: "",
      leftarrowtail: "",
      LeftCeiling: "",
      LeftDoubleBracket: "",
      LeftDownTeeVector: "",
      LeftDownVector: "",
      LeftDownVectorBar: "",
      LeftFloor: "",
      leftharpoondown: "",
      leftharpoonup: "",
      leftleftarrows: "",
      LeftRightArrow: "",
      Leftrightarrow: "",
      leftrightarrow: "",
      leftrightarrows: "",
      leftrightharpoons: "",
      leftrightsquigarrow: "",
      LeftRightVector: "",
      LeftTee: "",
      LeftTeeArrow: "",
      LeftTeeVector: "",
      leftthreetimes: "",
      LeftTriangle: "",
      LeftTriangleBar: "",
      LeftTriangleEqual: "",
      LeftUpDownVector: "",
      LeftUpTeeVector: "",
      LeftUpVector: "",
      LeftUpVectorBar: "",
      LeftVector: "",
      LeftVectorBar: "",
      lEg: "",
      leg: "",
      leq: "",
      leqq: "",
      leqslant: "",
      les: "",
      lescc: "",
      lesdot: "",
      lesdoto: "",
      lesdotor: "",
      lesg: "",
      lesges: "",
      lessapprox: "",
      lessdot: "",
      lesseqgtr: "",
      lesseqqgtr: "",
      LessEqualGreater: "",
      LessFullEqual: "",
      LessGreater: "",
      lessgtr: "",
      LessLess: "",
      lesssim: "",
      LessSlantEqual: "",
      LessTilde: "",
      lfisht: "",
      lfloor: "",
      Lfr: "",
      lfr: "",
      lg: "",
      lgE: "",
      lHar: "",
      lhard: "",
      lharu: "",
      lharul: "",
      lhblk: "",
      LJcy: "",
      ljcy: "",
      Ll: "",
      ll: "",
      llarr: "",
      llcorner: "",
      Lleftarrow: "",
      llhard: "",
      lltri: "",
      Lmidot: "",
      lmidot: "",
      lmoust: "",
      lmoustache: "",
      lnap: "",
      lnapprox: "",
      lnE: "",
      lne: "",
      lneq: "",
      lneqq: "",
      lnsim: "",
      loang: "",
      loarr: "",
      lobrk: "",
      LongLeftArrow: "",
      Longleftarrow: "",
      longleftarrow: "",
      LongLeftRightArrow: "",
      Longleftrightarrow: "",
      longleftrightarrow: "",
      longmapsto: "",
      LongRightArrow: "",
      Longrightarrow: "",
      longrightarrow: "",
      looparrowleft: "",
      looparrowright: "",
      lopar: "",
      Lopf: "",
      lopf: "",
      loplus: "",
      lotimes: "",
      lowast: "",
      lowbar: "_",
      LowerLeftArrow: "",
      LowerRightArrow: "",
      loz: "",
      lozenge: "",
      lozf: "",
      lpar: "(",
      lparlt: "",
      lrarr: "",
      lrcorner: "",
      lrhar: "",
      lrhard: "",
      lrm: "",
      lrtri: "",
      lsaquo: "",
      Lscr: "",
      lscr: "",
      Lsh: "",
      lsh: "",
      lsim: "",
      lsime: "",
      lsimg: "",
      lsqb: "[",
      lsquo: "",
      lsquor: "",
      Lstrok: "",
      lstrok: "",
      Lt: "",
      LT: "<",
      lt: "<",
      ltcc: "",
      ltcir: "",
      ltdot: "",
      lthree: "",
      ltimes: "",
      ltlarr: "",
      ltquest: "",
      ltri: "",
      ltrie: "",
      ltrif: "",
      ltrPar: "",
      lurdshar: "",
      luruhar: "",
      lvertneqq: "",
      lvnE: "",
      macr: "",
      male: "",
      malt: "",
      maltese: "",
      Map: "",
      map: "",
      mapsto: "",
      mapstodown: "",
      mapstoleft: "",
      mapstoup: "",
      marker: "",
      mcomma: "",
      Mcy: "",
      mcy: "",
      mdash: "",
      mDDot: "",
      measuredangle: "",
      MediumSpace: "",
      Mellintrf: "",
      Mfr: "",
      mfr: "",
      mho: "",
      micro: "",
      mid: "",
      midast: "*",
      midcir: "",
      middot: "",
      minus: "",
      minusb: "",
      minusd: "",
      minusdu: "",
      MinusPlus: "",
      mlcp: "",
      mldr: "",
      mnplus: "",
      models: "",
      Mopf: "",
      mopf: "",
      mp: "",
      Mscr: "",
      mscr: "",
      mstpos: "",
      Mu: "",
      mu: "",
      multimap: "",
      mumap: "",
      nabla: "",
      Nacute: "",
      nacute: "",
      nang: "",
      nap: "",
      napE: "",
      napid: "",
      napos: "",
      napprox: "",
      natur: "",
      natural: "",
      naturals: "",
      nbsp: "",
      nbump: "",
      nbumpe: "",
      ncap: "",
      Ncaron: "",
      ncaron: "",
      Ncedil: "",
      ncedil: "",
      ncong: "",
      ncongdot: "",
      ncup: "",
      Ncy: "",
      ncy: "",
      ndash: "",
      ne: "",
      nearhk: "",
      neArr: "",
      nearr: "",
      nearrow: "",
      nedot: "",
      NegativeMediumSpace: "",
      NegativeThickSpace: "",
      NegativeThinSpace: "",
      NegativeVeryThinSpace: "",
      nequiv: "",
      nesear: "",
      nesim: "",
      NestedGreaterGreater: "",
      NestedLessLess: "",
      NewLine: `
`,
      nexist: "",
      nexists: "",
      Nfr: "",
      nfr: "",
      ngE: "",
      nge: "",
      ngeq: "",
      ngeqq: "",
      ngeqslant: "",
      nges: "",
      nGg: "",
      ngsim: "",
      nGt: "",
      ngt: "",
      ngtr: "",
      nGtv: "",
      nhArr: "",
      nharr: "",
      nhpar: "",
      ni: "",
      nis: "",
      nisd: "",
      niv: "",
      NJcy: "",
      njcy: "",
      nlArr: "",
      nlarr: "",
      nldr: "",
      nlE: "",
      nle: "",
      nLeftarrow: "",
      nleftarrow: "",
      nLeftrightarrow: "",
      nleftrightarrow: "",
      nleq: "",
      nleqq: "",
      nleqslant: "",
      nles: "",
      nless: "",
      nLl: "",
      nlsim: "",
      nLt: "",
      nlt: "",
      nltri: "",
      nltrie: "",
      nLtv: "",
      nmid: "",
      NoBreak: "",
      NonBreakingSpace: "",
      Nopf: "",
      nopf: "",
      Not: "",
      not: "",
      NotCongruent: "",
      NotCupCap: "",
      NotDoubleVerticalBar: "",
      NotElement: "",
      NotEqual: "",
      NotEqualTilde: "",
      NotExists: "",
      NotGreater: "",
      NotGreaterEqual: "",
      NotGreaterFullEqual: "",
      NotGreaterGreater: "",
      NotGreaterLess: "",
      NotGreaterSlantEqual: "",
      NotGreaterTilde: "",
      NotHumpDownHump: "",
      NotHumpEqual: "",
      notin: "",
      notindot: "",
      notinE: "",
      notinva: "",
      notinvb: "",
      notinvc: "",
      NotLeftTriangle: "",
      NotLeftTriangleBar: "",
      NotLeftTriangleEqual: "",
      NotLess: "",
      NotLessEqual: "",
      NotLessGreater: "",
      NotLessLess: "",
      NotLessSlantEqual: "",
      NotLessTilde: "",
      NotNestedGreaterGreater: "",
      NotNestedLessLess: "",
      notni: "",
      notniva: "",
      notnivb: "",
      notnivc: "",
      NotPrecedes: "",
      NotPrecedesEqual: "",
      NotPrecedesSlantEqual: "",
      NotReverseElement: "",
      NotRightTriangle: "",
      NotRightTriangleBar: "",
      NotRightTriangleEqual: "",
      NotSquareSubset: "",
      NotSquareSubsetEqual: "",
      NotSquareSuperset: "",
      NotSquareSupersetEqual: "",
      NotSubset: "",
      NotSubsetEqual: "",
      NotSucceeds: "",
      NotSucceedsEqual: "",
      NotSucceedsSlantEqual: "",
      NotSucceedsTilde: "",
      NotSuperset: "",
      NotSupersetEqual: "",
      NotTilde: "",
      NotTildeEqual: "",
      NotTildeFullEqual: "",
      NotTildeTilde: "",
      NotVerticalBar: "",
      npar: "",
      nparallel: "",
      nparsl: "",
      npart: "",
      npolint: "",
      npr: "",
      nprcue: "",
      npre: "",
      nprec: "",
      npreceq: "",
      nrArr: "",
      nrarr: "",
      nrarrc: "",
      nrarrw: "",
      nRightarrow: "",
      nrightarrow: "",
      nrtri: "",
      nrtrie: "",
      nsc: "",
      nsccue: "",
      nsce: "",
      Nscr: "",
      nscr: "",
      nshortmid: "",
      nshortparallel: "",
      nsim: "",
      nsime: "",
      nsimeq: "",
      nsmid: "",
      nspar: "",
      nsqsube: "",
      nsqsupe: "",
      nsub: "",
      nsubE: "",
      nsube: "",
      nsubset: "",
      nsubseteq: "",
      nsubseteqq: "",
      nsucc: "",
      nsucceq: "",
      nsup: "",
      nsupE: "",
      nsupe: "",
      nsupset: "",
      nsupseteq: "",
      nsupseteqq: "",
      ntgl: "",
      Ntilde: "",
      ntilde: "",
      ntlg: "",
      ntriangleleft: "",
      ntrianglelefteq: "",
      ntriangleright: "",
      ntrianglerighteq: "",
      Nu: "",
      nu: "",
      num: "#",
      numero: "",
      numsp: "",
      nvap: "",
      nVDash: "",
      nVdash: "",
      nvDash: "",
      nvdash: "",
      nvge: "",
      nvgt: ">",
      nvHarr: "",
      nvinfin: "",
      nvlArr: "",
      nvle: "",
      nvlt: "<",
      nvltrie: "",
      nvrArr: "",
      nvrtrie: "",
      nvsim: "",
      nwarhk: "",
      nwArr: "",
      nwarr: "",
      nwarrow: "",
      nwnear: "",
      Oacute: "",
      oacute: "",
      oast: "",
      ocir: "",
      Ocirc: "",
      ocirc: "",
      Ocy: "",
      ocy: "",
      odash: "",
      Odblac: "",
      odblac: "",
      odiv: "",
      odot: "",
      odsold: "",
      OElig: "",
      oelig: "",
      ofcir: "",
      Ofr: "",
      ofr: "",
      ogon: "",
      Ograve: "",
      ograve: "",
      ogt: "",
      ohbar: "",
      ohm: "",
      oint: "",
      olarr: "",
      olcir: "",
      olcross: "",
      oline: "",
      olt: "",
      Omacr: "",
      omacr: "",
      Omega: "",
      omega: "",
      Omicron: "",
      omicron: "",
      omid: "",
      ominus: "",
      Oopf: "",
      oopf: "",
      opar: "",
      OpenCurlyDoubleQuote: "",
      OpenCurlyQuote: "",
      operp: "",
      oplus: "",
      Or: "",
      or: "",
      orarr: "",
      ord: "",
      order: "",
      orderof: "",
      ordf: "",
      ordm: "",
      origof: "",
      oror: "",
      orslope: "",
      orv: "",
      oS: "",
      Oscr: "",
      oscr: "",
      Oslash: "",
      oslash: "",
      osol: "",
      Otilde: "",
      otilde: "",
      Otimes: "",
      otimes: "",
      otimesas: "",
      Ouml: "",
      ouml: "",
      ovbar: "",
      OverBar: "",
      OverBrace: "",
      OverBracket: "",
      OverParenthesis: "",
      par: "",
      para: "",
      parallel: "",
      parsim: "",
      parsl: "",
      part: "",
      PartialD: "",
      Pcy: "",
      pcy: "",
      percnt: "%",
      period: ".",
      permil: "",
      perp: "",
      pertenk: "",
      Pfr: "",
      pfr: "",
      Phi: "",
      phi: "",
      phiv: "",
      phmmat: "",
      phone: "",
      Pi: "",
      pi: "",
      pitchfork: "",
      piv: "",
      planck: "",
      planckh: "",
      plankv: "",
      plus: "+",
      plusacir: "",
      plusb: "",
      pluscir: "",
      plusdo: "",
      plusdu: "",
      pluse: "",
      PlusMinus: "",
      plusmn: "",
      plussim: "",
      plustwo: "",
      pm: "",
      Poincareplane: "",
      pointint: "",
      Popf: "",
      popf: "",
      pound: "",
      Pr: "",
      pr: "",
      prap: "",
      prcue: "",
      prE: "",
      pre: "",
      prec: "",
      precapprox: "",
      preccurlyeq: "",
      Precedes: "",
      PrecedesEqual: "",
      PrecedesSlantEqual: "",
      PrecedesTilde: "",
      preceq: "",
      precnapprox: "",
      precneqq: "",
      precnsim: "",
      precsim: "",
      Prime: "",
      prime: "",
      primes: "",
      prnap: "",
      prnE: "",
      prnsim: "",
      prod: "",
      Product: "",
      profalar: "",
      profline: "",
      profsurf: "",
      prop: "",
      Proportion: "",
      Proportional: "",
      propto: "",
      prsim: "",
      prurel: "",
      Pscr: "",
      pscr: "",
      Psi: "",
      psi: "",
      puncsp: "",
      Qfr: "",
      qfr: "",
      qint: "",
      Qopf: "",
      qopf: "",
      qprime: "",
      Qscr: "",
      qscr: "",
      quaternions: "",
      quatint: "",
      quest: "?",
      questeq: "",
      QUOT: '"',
      quot: '"',
      rAarr: "",
      race: "",
      Racute: "",
      racute: "",
      radic: "",
      raemptyv: "",
      Rang: "",
      rang: "",
      rangd: "",
      range: "",
      rangle: "",
      raquo: "",
      Rarr: "",
      rArr: "",
      rarr: "",
      rarrap: "",
      rarrb: "",
      rarrbfs: "",
      rarrc: "",
      rarrfs: "",
      rarrhk: "",
      rarrlp: "",
      rarrpl: "",
      rarrsim: "",
      Rarrtl: "",
      rarrtl: "",
      rarrw: "",
      rAtail: "",
      ratail: "",
      ratio: "",
      rationals: "",
      RBarr: "",
      rBarr: "",
      rbarr: "",
      rbbrk: "",
      rbrace: "}",
      rbrack: "]",
      rbrke: "",
      rbrksld: "",
      rbrkslu: "",
      Rcaron: "",
      rcaron: "",
      Rcedil: "",
      rcedil: "",
      rceil: "",
      rcub: "}",
      Rcy: "",
      rcy: "",
      rdca: "",
      rdldhar: "",
      rdquo: "",
      rdquor: "",
      rdsh: "",
      Re: "",
      real: "",
      realine: "",
      realpart: "",
      reals: "",
      rect: "",
      REG: "",
      reg: "",
      ReverseElement: "",
      ReverseEquilibrium: "",
      ReverseUpEquilibrium: "",
      rfisht: "",
      rfloor: "",
      Rfr: "",
      rfr: "",
      rHar: "",
      rhard: "",
      rharu: "",
      rharul: "",
      Rho: "",
      rho: "",
      rhov: "",
      RightAngleBracket: "",
      RightArrow: "",
      Rightarrow: "",
      rightarrow: "",
      RightArrowBar: "",
      RightArrowLeftArrow: "",
      rightarrowtail: "",
      RightCeiling: "",
      RightDoubleBracket: "",
      RightDownTeeVector: "",
      RightDownVector: "",
      RightDownVectorBar: "",
      RightFloor: "",
      rightharpoondown: "",
      rightharpoonup: "",
      rightleftarrows: "",
      rightleftharpoons: "",
      rightrightarrows: "",
      rightsquigarrow: "",
      RightTee: "",
      RightTeeArrow: "",
      RightTeeVector: "",
      rightthreetimes: "",
      RightTriangle: "",
      RightTriangleBar: "",
      RightTriangleEqual: "",
      RightUpDownVector: "",
      RightUpTeeVector: "",
      RightUpVector: "",
      RightUpVectorBar: "",
      RightVector: "",
      RightVectorBar: "",
      ring: "",
      risingdotseq: "",
      rlarr: "",
      rlhar: "",
      rlm: "",
      rmoust: "",
      rmoustache: "",
      rnmid: "",
      roang: "",
      roarr: "",
      robrk: "",
      ropar: "",
      Ropf: "",
      ropf: "",
      roplus: "",
      rotimes: "",
      RoundImplies: "",
      rpar: ")",
      rpargt: "",
      rppolint: "",
      rrarr: "",
      Rrightarrow: "",
      rsaquo: "",
      Rscr: "",
      rscr: "",
      Rsh: "",
      rsh: "",
      rsqb: "]",
      rsquo: "",
      rsquor: "",
      rthree: "",
      rtimes: "",
      rtri: "",
      rtrie: "",
      rtrif: "",
      rtriltri: "",
      RuleDelayed: "",
      ruluhar: "",
      rx: "",
      Sacute: "",
      sacute: "",
      sbquo: "",
      Sc: "",
      sc: "",
      scap: "",
      Scaron: "",
      scaron: "",
      sccue: "",
      scE: "",
      sce: "",
      Scedil: "",
      scedil: "",
      Scirc: "",
      scirc: "",
      scnap: "",
      scnE: "",
      scnsim: "",
      scpolint: "",
      scsim: "",
      Scy: "",
      scy: "",
      sdot: "",
      sdotb: "",
      sdote: "",
      searhk: "",
      seArr: "",
      searr: "",
      searrow: "",
      sect: "",
      semi: ";",
      seswar: "",
      setminus: "",
      setmn: "",
      sext: "",
      Sfr: "",
      sfr: "",
      sfrown: "",
      sharp: "",
      SHCHcy: "",
      shchcy: "",
      SHcy: "",
      shcy: "",
      ShortDownArrow: "",
      ShortLeftArrow: "",
      shortmid: "",
      shortparallel: "",
      ShortRightArrow: "",
      ShortUpArrow: "",
      shy: "",
      Sigma: "",
      sigma: "",
      sigmaf: "",
      sigmav: "",
      sim: "",
      simdot: "",
      sime: "",
      simeq: "",
      simg: "",
      simgE: "",
      siml: "",
      simlE: "",
      simne: "",
      simplus: "",
      simrarr: "",
      slarr: "",
      SmallCircle: "",
      smallsetminus: "",
      smashp: "",
      smeparsl: "",
      smid: "",
      smile: "",
      smt: "",
      smte: "",
      smtes: "",
      SOFTcy: "",
      softcy: "",
      sol: "/",
      solb: "",
      solbar: "",
      Sopf: "",
      sopf: "",
      spades: "",
      spadesuit: "",
      spar: "",
      sqcap: "",
      sqcaps: "",
      sqcup: "",
      sqcups: "",
      Sqrt: "",
      sqsub: "",
      sqsube: "",
      sqsubset: "",
      sqsubseteq: "",
      sqsup: "",
      sqsupe: "",
      sqsupset: "",
      sqsupseteq: "",
      squ: "",
      Square: "",
      square: "",
      SquareIntersection: "",
      SquareSubset: "",
      SquareSubsetEqual: "",
      SquareSuperset: "",
      SquareSupersetEqual: "",
      SquareUnion: "",
      squarf: "",
      squf: "",
      srarr: "",
      Sscr: "",
      sscr: "",
      ssetmn: "",
      ssmile: "",
      sstarf: "",
      Star: "",
      star: "",
      starf: "",
      straightepsilon: "",
      straightphi: "",
      strns: "",
      Sub: "",
      sub: "",
      subdot: "",
      subE: "",
      sube: "",
      subedot: "",
      submult: "",
      subnE: "",
      subne: "",
      subplus: "",
      subrarr: "",
      Subset: "",
      subset: "",
      subseteq: "",
      subseteqq: "",
      SubsetEqual: "",
      subsetneq: "",
      subsetneqq: "",
      subsim: "",
      subsub: "",
      subsup: "",
      succ: "",
      succapprox: "",
      succcurlyeq: "",
      Succeeds: "",
      SucceedsEqual: "",
      SucceedsSlantEqual: "",
      SucceedsTilde: "",
      succeq: "",
      succnapprox: "",
      succneqq: "",
      succnsim: "",
      succsim: "",
      SuchThat: "",
      Sum: "",
      sum: "",
      sung: "",
      Sup: "",
      sup: "",
      sup1: "",
      sup2: "",
      sup3: "",
      supdot: "",
      supdsub: "",
      supE: "",
      supe: "",
      supedot: "",
      Superset: "",
      SupersetEqual: "",
      suphsol: "",
      suphsub: "",
      suplarr: "",
      supmult: "",
      supnE: "",
      supne: "",
      supplus: "",
      Supset: "",
      supset: "",
      supseteq: "",
      supseteqq: "",
      supsetneq: "",
      supsetneqq: "",
      supsim: "",
      supsub: "",
      supsup: "",
      swarhk: "",
      swArr: "",
      swarr: "",
      swarrow: "",
      swnwar: "",
      szlig: "",
      Tab: "	",
      target: "",
      Tau: "",
      tau: "",
      tbrk: "",
      Tcaron: "",
      tcaron: "",
      Tcedil: "",
      tcedil: "",
      Tcy: "",
      tcy: "",
      tdot: "",
      telrec: "",
      Tfr: "",
      tfr: "",
      there4: "",
      Therefore: "",
      therefore: "",
      Theta: "",
      theta: "",
      thetasym: "",
      thetav: "",
      thickapprox: "",
      thicksim: "",
      ThickSpace: "",
      thinsp: "",
      ThinSpace: "",
      thkap: "",
      thksim: "",
      THORN: "",
      thorn: "",
      Tilde: "",
      tilde: "",
      TildeEqual: "",
      TildeFullEqual: "",
      TildeTilde: "",
      times: "",
      timesb: "",
      timesbar: "",
      timesd: "",
      tint: "",
      toea: "",
      top: "",
      topbot: "",
      topcir: "",
      Topf: "",
      topf: "",
      topfork: "",
      tosa: "",
      tprime: "",
      TRADE: "",
      trade: "",
      triangle: "",
      triangledown: "",
      triangleleft: "",
      trianglelefteq: "",
      triangleq: "",
      triangleright: "",
      trianglerighteq: "",
      tridot: "",
      trie: "",
      triminus: "",
      TripleDot: "",
      triplus: "",
      trisb: "",
      tritime: "",
      trpezium: "",
      Tscr: "",
      tscr: "",
      TScy: "",
      tscy: "",
      TSHcy: "",
      tshcy: "",
      Tstrok: "",
      tstrok: "",
      twixt: "",
      twoheadleftarrow: "",
      twoheadrightarrow: "",
      Uacute: "",
      uacute: "",
      Uarr: "",
      uArr: "",
      uarr: "",
      Uarrocir: "",
      Ubrcy: "",
      ubrcy: "",
      Ubreve: "",
      ubreve: "",
      Ucirc: "",
      ucirc: "",
      Ucy: "",
      ucy: "",
      udarr: "",
      Udblac: "",
      udblac: "",
      udhar: "",
      ufisht: "",
      Ufr: "",
      ufr: "",
      Ugrave: "",
      ugrave: "",
      uHar: "",
      uharl: "",
      uharr: "",
      uhblk: "",
      ulcorn: "",
      ulcorner: "",
      ulcrop: "",
      ultri: "",
      Umacr: "",
      umacr: "",
      uml: "",
      UnderBar: "_",
      UnderBrace: "",
      UnderBracket: "",
      UnderParenthesis: "",
      Union: "",
      UnionPlus: "",
      Uogon: "",
      uogon: "",
      Uopf: "",
      uopf: "",
      UpArrow: "",
      Uparrow: "",
      uparrow: "",
      UpArrowBar: "",
      UpArrowDownArrow: "",
      UpDownArrow: "",
      Updownarrow: "",
      updownarrow: "",
      UpEquilibrium: "",
      upharpoonleft: "",
      upharpoonright: "",
      uplus: "",
      UpperLeftArrow: "",
      UpperRightArrow: "",
      Upsi: "",
      upsi: "",
      upsih: "",
      Upsilon: "",
      upsilon: "",
      UpTee: "",
      UpTeeArrow: "",
      upuparrows: "",
      urcorn: "",
      urcorner: "",
      urcrop: "",
      Uring: "",
      uring: "",
      urtri: "",
      Uscr: "",
      uscr: "",
      utdot: "",
      Utilde: "",
      utilde: "",
      utri: "",
      utrif: "",
      uuarr: "",
      Uuml: "",
      uuml: "",
      uwangle: "",
      vangrt: "",
      varepsilon: "",
      varkappa: "",
      varnothing: "",
      varphi: "",
      varpi: "",
      varpropto: "",
      vArr: "",
      varr: "",
      varrho: "",
      varsigma: "",
      varsubsetneq: "",
      varsubsetneqq: "",
      varsupsetneq: "",
      varsupsetneqq: "",
      vartheta: "",
      vartriangleleft: "",
      vartriangleright: "",
      Vbar: "",
      vBar: "",
      vBarv: "",
      Vcy: "",
      vcy: "",
      VDash: "",
      Vdash: "",
      vDash: "",
      vdash: "",
      Vdashl: "",
      Vee: "",
      vee: "",
      veebar: "",
      veeeq: "",
      vellip: "",
      Verbar: "",
      verbar: "|",
      Vert: "",
      vert: "|",
      VerticalBar: "",
      VerticalLine: "|",
      VerticalSeparator: "",
      VerticalTilde: "",
      VeryThinSpace: "",
      Vfr: "",
      vfr: "",
      vltri: "",
      vnsub: "",
      vnsup: "",
      Vopf: "",
      vopf: "",
      vprop: "",
      vrtri: "",
      Vscr: "",
      vscr: "",
      vsubnE: "",
      vsubne: "",
      vsupnE: "",
      vsupne: "",
      Vvdash: "",
      vzigzag: "",
      Wcirc: "",
      wcirc: "",
      wedbar: "",
      Wedge: "",
      wedge: "",
      wedgeq: "",
      weierp: "",
      Wfr: "",
      wfr: "",
      Wopf: "",
      wopf: "",
      wp: "",
      wr: "",
      wreath: "",
      Wscr: "",
      wscr: "",
      xcap: "",
      xcirc: "",
      xcup: "",
      xdtri: "",
      Xfr: "",
      xfr: "",
      xhArr: "",
      xharr: "",
      Xi: "",
      xi: "",
      xlArr: "",
      xlarr: "",
      xmap: "",
      xnis: "",
      xodot: "",
      Xopf: "",
      xopf: "",
      xoplus: "",
      xotime: "",
      xrArr: "",
      xrarr: "",
      Xscr: "",
      xscr: "",
      xsqcup: "",
      xuplus: "",
      xutri: "",
      xvee: "",
      xwedge: "",
      Yacute: "",
      yacute: "",
      YAcy: "",
      yacy: "",
      Ycirc: "",
      ycirc: "",
      Ycy: "",
      ycy: "",
      yen: "",
      Yfr: "",
      yfr: "",
      YIcy: "",
      yicy: "",
      Yopf: "",
      yopf: "",
      Yscr: "",
      yscr: "",
      YUcy: "",
      yucy: "",
      Yuml: "",
      yuml: "",
      Zacute: "",
      zacute: "",
      Zcaron: "",
      zcaron: "",
      Zcy: "",
      zcy: "",
      Zdot: "",
      zdot: "",
      zeetrf: "",
      ZeroWidthSpace: "",
      Zeta: "",
      zeta: "",
      Zfr: "",
      zfr: "",
      ZHcy: "",
      zhcy: "",
      zigrarr: "",
      Zopf: "",
      zopf: "",
      Zscr: "",
      zscr: "",
      zwj: "",
      zwnj: ""
    }), n2.entityMap = n2.HTML_ENTITIES;
  })(gt)), gt;
}
var ht = {};
var Rt;
function gr() {
  if (Rt) return ht;
  Rt = 1;
  var n2 = st(), t3 = Yt(), u2 = mt(), s4 = n2.isHTMLEscapableRawTextElement, c4 = n2.isHTMLMimeType, o5 = n2.isHTMLRawTextElement, h4 = n2.hasOwn, v2 = n2.NAMESPACE, f7 = u2.ParseError, g4 = u2.DOMException, D2 = 0, p4 = 1, B2 = 2, k4 = 3, Y2 = 4, X2 = 5, te = 6, M2 = 7;
  function q3() {
  }
  q3.prototype = {
    parse: function(l6, A4, b4) {
      var T4 = this.domBuilder;
      T4.startDocument(), U4(A4, A4 = /* @__PURE__ */ Object.create(null)), ue(l6, A4, b4, T4, this.errorHandler), T4.endDocument();
    }
  };
  var W = /&#?\w+;?/g;
  function ue(l6, A4, b4, T4, y6) {
    var E2 = c4(T4.mimeType);
    l6.indexOf(t3.UNICODE_REPLACEMENT_CHARACTER) >= 0 && y6.warning("Unicode replacement character detected, source encoding issues?");
    function S3(F2) {
      if (F2 > 65535) {
        F2 -= 65536;
        var Q2 = 55296 + (F2 >> 10), De = 56320 + (F2 & 1023);
        return String.fromCharCode(Q2, De);
      } else
        return String.fromCharCode(F2);
    }
    function V2(F2) {
      var Q2 = F2[F2.length - 1] === ";" ? F2 : F2 + ";";
      if (!E2 && Q2 !== F2)
        return y6.error("EntityRef: expecting ;"), F2;
      var De = t3.Reference.exec(Q2);
      if (!De || De[0].length !== Q2.length)
        return y6.error("entity not matching Reference production: " + F2), F2;
      var ge = Q2.slice(1, -1);
      return h4(b4, ge) ? b4[ge] : ge.charAt(0) === "#" ? S3(parseInt(ge.substring(1).replace("x", "0x"))) : (y6.error("entity not found:" + F2), F2);
    }
    function O5(F2) {
      if (F2 > ie) {
        var Q2 = l6.substring(ie, F2).replace(W, V2);
        P2 && oe(ie), T4.characters(Q2, 0, F2 - ie), ie = F2;
      }
    }
    var C = 0, w3 = 0, x4 = /\r\n?|\n|$/g, P2 = T4.locator;
    function oe(F2, Q2) {
      for (; F2 >= w3 && (Q2 = x4.exec(l6)); )
        C = w3, w3 = Q2.index + Q2[0].length, P2.lineNumber++;
      P2.columnNumber = F2 - C + 1;
    }
    for (var Te = [{ currentNSMap: A4 }], Ee = [], ie = 0; ; ) {
      try {
        var R3 = l6.indexOf("<", ie);
        if (R3 < 0) {
          if (!E2 && Ee.length > 0)
            return y6.fatalError("unclosed xml tag(s): " + Ee.join(", "));
          if (!l6.substring(ie).match(/^\s*$/)) {
            var Fe = T4.doc, ye = Fe.createTextNode(l6.substring(ie));
            if (Fe.documentElement)
              return y6.error("Extra content at the end of the document");
            Fe.appendChild(ye), T4.currentElement = ye;
          }
          return;
        }
        if (R3 > ie) {
          var ce2 = l6.substring(ie, R3);
          !E2 && Ee.length === 0 && (ce2 = ce2.replace(new RegExp(t3.S_OPT.source, "g"), ""), ce2 && y6.error("Unexpected content outside root element: '" + ce2 + "'")), O5(R3);
        }
        switch (l6.charAt(R3 + 1)) {
          case "/":
            var ne = l6.indexOf(">", R3 + 2), Le = l6.substring(R3 + 2, ne > 0 ? ne : void 0);
            if (!Le)
              return y6.fatalError("end tag name missing");
            var _e12 = ne > 0 && t3.reg("^", t3.QName_group, t3.S_OPT, "$").exec(Le);
            if (!_e12)
              return y6.fatalError('end tag name contains invalid characters: "' + Le + '"');
            if (!T4.currentElement && !T4.doc.documentElement)
              return;
            var Ce = Ee[Ee.length - 1] || T4.currentElement.tagName || T4.doc.documentElement.tagName || "";
            if (Ce !== _e12[1]) {
              var Re = _e12[1].toLowerCase();
              if (!E2 || Ce.toLowerCase() !== Re)
                return y6.fatalError('Opening and ending tag mismatch: "' + Ce + '" != "' + Le + '"');
            }
            var Ue = Te.pop();
            Ee.pop();
            var qe = Ue.localNSMap;
            if (T4.endElement(Ue.uri, Ue.localName, Ce), qe)
              for (var Ae in qe)
                h4(qe, Ae) && T4.endPrefixMapping(Ae);
            ne++;
            break;
          // end element
          case "?":
            P2 && oe(R3), ne = Z2(l6, R3, T4, y6);
            break;
          case "!":
            P2 && oe(R3), ne = Ne(l6, R3, T4, y6, E2);
            break;
          default:
            P2 && oe(R3);
            var j2 = new we(), Pe = Te[Te.length - 1].currentNSMap, ne = m2(l6, R3, j2, Pe, V2, y6, E2), Ge = j2.length;
            if (j2.closed || (E2 && n2.isHTMLVoidElement(j2.tagName) ? j2.closed = true : Ee.push(j2.tagName)), P2 && Ge) {
              for (var at = de2(P2, {}), Ve = 0; Ve < Ge; Ve++) {
                var ze = j2[Ve];
                oe(ze.offset), ze.locator = de2(P2, {});
              }
              T4.locator = at, _2(j2, T4, Pe) && Te.push(j2), T4.locator = P2;
            } else
              _2(j2, T4, Pe) && Te.push(j2);
            E2 && !j2.closed ? ne = I2(l6, ne, j2.tagName, V2, T4) : ne++;
        }
      } catch (F2) {
        if (F2 instanceof f7)
          throw F2;
        if (F2 instanceof g4)
          throw new f7(F2.name + ": " + F2.message, T4.locator, F2);
        y6.error("element parse error: " + F2), ne = -1;
      }
      ne > ie ? ie = ne : O5(Math.max(R3, ie) + 1);
    }
  }
  function de2(l6, A4) {
    return A4.lineNumber = l6.lineNumber, A4.columnNumber = l6.columnNumber, A4;
  }
  function m2(l6, A4, b4, T4, y6, E2, S3) {
    function V2(oe, Te, Ee) {
      if (h4(b4.attributeNames, oe))
        return E2.fatalError("Attribute " + oe + " redefined");
      if (!S3 && Te.indexOf("<") >= 0)
        return E2.fatalError("Unescaped '<' not allowed in attributes values");
      b4.addValue(
        oe,
        // @see https://www.w3.org/TR/xml/#AVNormalize
        // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
        // - recursive replacement of (DTD) entity references
        // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
        Te.replace(/[\t\n\r]/g, " ").replace(W, y6),
        Ee
      );
    }
    for (var O5, C, w3 = ++A4, x4 = D2; ; ) {
      var P2 = l6.charAt(w3);
      switch (P2) {
        case "=":
          if (x4 === p4)
            O5 = l6.slice(A4, w3), x4 = k4;
          else if (x4 === B2)
            x4 = k4;
          else
            throw new Error("attribute equal must after attrName");
          break;
        case "'":
        case '"':
          if (x4 === k4 || x4 === p4)
            if (x4 === p4 && (E2.warning('attribute value must after "="'), O5 = l6.slice(A4, w3)), A4 = w3 + 1, w3 = l6.indexOf(P2, A4), w3 > 0)
              C = l6.slice(A4, w3), V2(O5, C, A4 - 1), x4 = X2;
            else
              throw new Error("attribute value no end '" + P2 + "' match");
          else if (x4 == Y2)
            C = l6.slice(A4, w3), V2(O5, C, A4), E2.warning('attribute "' + O5 + '" missed start quot(' + P2 + ")!!"), A4 = w3 + 1, x4 = X2;
          else
            throw new Error('attribute value must after "="');
          break;
        case "/":
          switch (x4) {
            case D2:
              b4.setTagName(l6.slice(A4, w3));
            case X2:
            case te:
            case M2:
              x4 = M2, b4.closed = true;
            case Y2:
            case p4:
              break;
            case B2:
              b4.closed = true;
              break;
            //case S_EQ:
            default:
              throw new Error("attribute invalid close char('/')");
          }
          break;
        case "":
          return E2.error("unexpected end of input"), x4 == D2 && b4.setTagName(l6.slice(A4, w3)), w3;
        case ">":
          switch (x4) {
            case D2:
              b4.setTagName(l6.slice(A4, w3));
            case X2:
            case te:
            case M2:
              break;
            //normal
            case Y2:
            //Compatible state
            case p4:
              C = l6.slice(A4, w3), C.slice(-1) === "/" && (b4.closed = true, C = C.slice(0, -1));
            case B2:
              x4 === B2 && (C = O5), x4 == Y2 ? (E2.warning('attribute "' + C + '" missed quot(")!'), V2(O5, C, A4)) : (S3 || E2.warning('attribute "' + C + '" missed value!! "' + C + '" instead!!'), V2(C, C, A4));
              break;
            case k4:
              if (!S3)
                return E2.fatalError(`AttValue: ' or " expected`);
          }
          return w3;
        /*xml space '\x20' | #x9 | #xD | #xA; */
        case "":
          P2 = " ";
        default:
          if (P2 <= " ")
            switch (x4) {
              case D2:
                b4.setTagName(l6.slice(A4, w3)), x4 = te;
                break;
              case p4:
                O5 = l6.slice(A4, w3), x4 = B2;
                break;
              case Y2:
                var C = l6.slice(A4, w3);
                E2.warning('attribute "' + C + '" missed quot(")!!'), V2(O5, C, A4);
              case X2:
                x4 = te;
                break;
            }
          else
            switch (x4) {
              //case S_TAG:void();break;
              //case S_ATTR:void();break;
              //case S_ATTR_NOQUOT_VALUE:void();break;
              case B2:
                S3 || E2.warning('attribute "' + O5 + '" missed value!! "' + O5 + '" instead2!!'), V2(O5, O5, A4), A4 = w3, x4 = p4;
                break;
              case X2:
                E2.warning('attribute space is required"' + O5 + '"!!');
              case te:
                x4 = p4, A4 = w3;
                break;
              case k4:
                x4 = Y2, A4 = w3;
                break;
              case M2:
                throw new Error("elements closed character '/' and '>' must be connected to");
            }
      }
      w3++;
    }
  }
  function _2(l6, A4, b4) {
    for (var T4 = l6.tagName, y6 = null, x4 = l6.length; x4--; ) {
      var E2 = l6[x4], S3 = E2.qName, V2 = E2.value, P2 = S3.indexOf(":");
      if (P2 > 0)
        var O5 = E2.prefix = S3.slice(0, P2), C = S3.slice(P2 + 1), w3 = O5 === "xmlns" && C;
      else
        C = S3, O5 = null, w3 = S3 === "xmlns" && "";
      E2.localName = C, w3 !== false && (y6 == null && (y6 = /* @__PURE__ */ Object.create(null), U4(b4, b4 = /* @__PURE__ */ Object.create(null))), b4[w3] = y6[w3] = V2, E2.uri = v2.XMLNS, A4.startPrefixMapping(w3, V2));
    }
    for (var x4 = l6.length; x4--; )
      E2 = l6[x4], E2.prefix && (E2.prefix === "xml" && (E2.uri = v2.XML), E2.prefix !== "xmlns" && (E2.uri = b4[E2.prefix]));
    var P2 = T4.indexOf(":");
    P2 > 0 ? (O5 = l6.prefix = T4.slice(0, P2), C = l6.localName = T4.slice(P2 + 1)) : (O5 = null, C = l6.localName = T4);
    var oe = l6.uri = b4[O5 || ""];
    if (A4.startElement(oe, C, T4, l6), l6.closed) {
      if (A4.endElement(oe, C, T4), y6)
        for (O5 in y6)
          h4(y6, O5) && A4.endPrefixMapping(O5);
    } else
      return l6.currentNSMap = b4, l6.localNSMap = y6, true;
  }
  function I2(l6, A4, b4, T4, y6) {
    var E2 = s4(b4);
    if (E2 || o5(b4)) {
      var S3 = l6.indexOf("</" + b4 + ">", A4), V2 = l6.substring(A4 + 1, S3);
      return E2 && (V2 = V2.replace(W, T4)), y6.characters(V2, 0, V2.length), S3;
    }
    return A4 + 1;
  }
  function U4(l6, A4) {
    for (var b4 in l6)
      h4(l6, b4) && (A4[b4] = l6[b4]);
  }
  function $3(l6, A4) {
    var b4 = A4;
    function T4(w3) {
      return w3 = w3 || 0, l6.charAt(b4 + w3);
    }
    function y6(w3) {
      w3 = w3 || 1, b4 += w3;
    }
    function E2() {
      for (var w3 = 0; b4 < l6.length; ) {
        var x4 = T4();
        if (x4 !== " " && x4 !== `
` && x4 !== "	" && x4 !== "\r")
          return w3;
        w3++, y6();
      }
      return -1;
    }
    function S3() {
      return l6.substring(b4);
    }
    function V2(w3) {
      return l6.substring(b4, b4 + w3.length) === w3;
    }
    function O5(w3) {
      return l6.substring(b4, b4 + w3.length).toUpperCase() === w3.toUpperCase();
    }
    function C(w3) {
      var x4 = t3.reg("^", w3), P2 = x4.exec(S3());
      return P2 ? (y6(P2[0].length), P2[0]) : null;
    }
    return {
      char: T4,
      getIndex: function() {
        return b4;
      },
      getMatch: C,
      getSource: function() {
        return l6;
      },
      skip: y6,
      skipBlanks: E2,
      substringFromIndex: S3,
      substringStartsWith: V2,
      substringStartsWithCaseInsensitive: O5
    };
  }
  function J2(l6, A4) {
    function b4(V2, O5) {
      var C = t3.PI.exec(V2.substringFromIndex());
      return C ? C[1].toLowerCase() === "xml" ? O5.fatalError(
        "xml declaration is only allowed at the start of the document, but found at position " + V2.getIndex()
      ) : (V2.skip(C[0].length), C[0]) : O5.fatalError("processing instruction is not well-formed at position " + V2.getIndex());
    }
    var T4 = l6.getSource();
    if (l6.char() === "[") {
      l6.skip(1);
      for (var y6 = l6.getIndex(); l6.getIndex() < T4.length; ) {
        if (l6.skipBlanks(), l6.char() === "]") {
          var E2 = T4.substring(y6, l6.getIndex());
          return l6.skip(1), E2;
        }
        var S3 = null;
        if (l6.char() === "<" && l6.char(1) === "!")
          switch (l6.char(2)) {
            case "E":
              l6.char(3) === "L" ? S3 = l6.getMatch(t3.elementdecl) : l6.char(3) === "N" && (S3 = l6.getMatch(t3.EntityDecl));
              break;
            case "A":
              S3 = l6.getMatch(t3.AttlistDecl);
              break;
            case "N":
              S3 = l6.getMatch(t3.NotationDecl);
              break;
            case "-":
              S3 = l6.getMatch(t3.Comment);
              break;
          }
        else if (l6.char() === "<" && l6.char(1) === "?")
          S3 = b4(l6, A4);
        else if (l6.char() === "%")
          S3 = l6.getMatch(t3.PEReference);
        else
          return A4.fatalError("Error detected in Markup declaration");
        if (!S3)
          return A4.fatalError("Error in internal subset at position " + l6.getIndex());
      }
      return A4.fatalError("doctype internal subset is not well-formed, missing ]");
    }
  }
  function Ne(l6, A4, b4, T4, y6) {
    var E2 = $3(l6, A4);
    switch (y6 ? E2.char(2).toUpperCase() : E2.char(2)) {
      case "-":
        var S3 = E2.getMatch(t3.Comment);
        return S3 ? (b4.comment(S3, t3.COMMENT_START.length, S3.length - t3.COMMENT_START.length - t3.COMMENT_END.length), E2.getIndex()) : T4.fatalError("comment is not well-formed at position " + E2.getIndex());
      case "[":
        var V2 = E2.getMatch(t3.CDSect);
        return V2 ? !y6 && !b4.currentElement ? T4.fatalError("CDATA outside of element") : (b4.startCDATA(), b4.characters(V2, t3.CDATA_START.length, V2.length - t3.CDATA_START.length - t3.CDATA_END.length), b4.endCDATA(), E2.getIndex()) : T4.fatalError("Invalid CDATA starting at position " + A4);
      case "D": {
        if (b4.doc && b4.doc.documentElement)
          return T4.fatalError("Doctype not allowed inside or after documentElement at position " + E2.getIndex());
        if (y6 ? !E2.substringStartsWithCaseInsensitive(t3.DOCTYPE_DECL_START) : !E2.substringStartsWith(t3.DOCTYPE_DECL_START))
          return T4.fatalError("Expected " + t3.DOCTYPE_DECL_START + " at position " + E2.getIndex());
        if (E2.skip(t3.DOCTYPE_DECL_START.length), E2.skipBlanks() < 1)
          return T4.fatalError("Expected whitespace after " + t3.DOCTYPE_DECL_START + " at position " + E2.getIndex());
        var O5 = {
          name: void 0,
          publicId: void 0,
          systemId: void 0,
          internalSubset: void 0
        };
        if (O5.name = E2.getMatch(t3.Name), !O5.name)
          return T4.fatalError("doctype name missing or contains unexpected characters at position " + E2.getIndex());
        if (y6 && O5.name.toLowerCase() !== "html" && T4.warning("Unexpected DOCTYPE in HTML document at position " + E2.getIndex()), E2.skipBlanks(), E2.substringStartsWith(t3.PUBLIC) || E2.substringStartsWith(t3.SYSTEM)) {
          var C = t3.ExternalID_match.exec(E2.substringFromIndex());
          if (!C)
            return T4.fatalError("doctype external id is not well-formed at position " + E2.getIndex());
          C.groups.SystemLiteralOnly !== void 0 ? O5.systemId = C.groups.SystemLiteralOnly : (O5.systemId = C.groups.SystemLiteral, O5.publicId = C.groups.PubidLiteral), E2.skip(C[0].length);
        } else if (y6 && E2.substringStartsWithCaseInsensitive(t3.SYSTEM)) {
          if (E2.skip(t3.SYSTEM.length), E2.skipBlanks() < 1)
            return T4.fatalError("Expected whitespace after " + t3.SYSTEM + " at position " + E2.getIndex());
          if (O5.systemId = E2.getMatch(t3.ABOUT_LEGACY_COMPAT_SystemLiteral), !O5.systemId)
            return T4.fatalError(
              "Expected " + t3.ABOUT_LEGACY_COMPAT + " in single or double quotes after " + t3.SYSTEM + " at position " + E2.getIndex()
            );
        }
        return y6 && O5.systemId && !t3.ABOUT_LEGACY_COMPAT_SystemLiteral.test(O5.systemId) && T4.warning("Unexpected doctype.systemId in HTML document at position " + E2.getIndex()), y6 || (E2.skipBlanks(), O5.internalSubset = J2(E2, T4)), E2.skipBlanks(), E2.char() !== ">" ? T4.fatalError("doctype not terminated with > at position " + E2.getIndex()) : (E2.skip(1), b4.startDTD(O5.name, O5.publicId, O5.systemId, O5.internalSubset), b4.endDTD(), E2.getIndex());
      }
      default:
        return T4.fatalError('Not well-formed XML starting with "<!" at position ' + A4);
    }
  }
  function Z2(l6, A4, b4, T4) {
    var y6 = l6.substring(A4).match(t3.PI);
    if (!y6)
      return T4.fatalError("Invalid processing instruction starting at position " + A4);
    if (y6[1].toLowerCase() === "xml") {
      if (A4 > 0)
        return T4.fatalError(
          "processing instruction at position " + A4 + " is an xml declaration which is only at the start of the document"
        );
      if (!t3.XMLDecl.test(l6.substring(A4)))
        return T4.fatalError("xml declaration is not well-formed");
    }
    return b4.processingInstruction(y6[1], y6[2]), A4 + y6[0].length;
  }
  function we() {
    this.attributeNames = /* @__PURE__ */ Object.create(null);
  }
  return we.prototype = {
    setTagName: function(l6) {
      if (!t3.QName_exact.test(l6))
        throw new Error("invalid tagName:" + l6);
      this.tagName = l6;
    },
    addValue: function(l6, A4, b4) {
      if (!t3.QName_exact.test(l6))
        throw new Error("invalid attribute:" + l6);
      this.attributeNames[l6] = this.length, this[this.length++] = { qName: l6, value: A4, offset: b4 };
    },
    length: 0,
    getLocalName: function(l6) {
      return this[l6].localName;
    },
    getLocator: function(l6) {
      return this[l6].locator;
    },
    getQName: function(l6) {
      return this[l6].qName;
    },
    getURI: function(l6) {
      return this[l6].uri;
    },
    getValue: function(l6) {
      return this[l6].value;
    }
    //	,getIndex:function(uri, localName)){
    //		if(localName){
    //
    //		}else{
    //			var qName = uri
    //		}
    //	},
    //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
    //	getType:function(uri,localName){}
    //	getType:function(i){},
  }, ht.XMLReader = q3, ht.parseUtils = $3, ht.parseDoctypeCommentOrCData = Ne, ht;
}
var Mt;
function Ar() {
  if (Mt) return We;
  Mt = 1;
  var n2 = st(), t3 = Xt(), u2 = mt(), s4 = Dr(), c4 = gr(), o5 = t3.DOMImplementation, h4 = n2.hasDefaultHTMLNamespace, v2 = n2.isHTMLMimeType, f7 = n2.isValidMimeType, g4 = n2.MIME_TYPE, D2 = n2.NAMESPACE, p4 = u2.ParseError, B2 = c4.XMLReader;
  function k4(m2) {
    return m2.replace(/\r[\n\u0085]/g, `
`).replace(/[\r\u0085\u2028\u2029]/g, `
`);
  }
  function Y2(m2) {
    if (m2 = m2 || {}, m2.locator === void 0 && (m2.locator = true), this.assign = m2.assign || n2.assign, this.domHandler = m2.domHandler || X2, this.onError = m2.onError || m2.errorHandler, m2.errorHandler && typeof m2.errorHandler != "function")
      throw new TypeError("errorHandler object is no longer supported, switch to onError!");
    m2.errorHandler && m2.errorHandler("warning", "The `errorHandler` option has been deprecated, use `onError` instead!", this), this.normalizeLineEndings = m2.normalizeLineEndings || k4, this.locator = !!m2.locator, this.xmlns = this.assign(/* @__PURE__ */ Object.create(null), m2.xmlns);
  }
  Y2.prototype.parseFromString = function(m2, _2) {
    if (!f7(_2))
      throw new TypeError('DOMParser.parseFromString: the provided mimeType "' + _2 + '" is not valid.');
    var I2 = this.assign(/* @__PURE__ */ Object.create(null), this.xmlns), U4 = s4.XML_ENTITIES, $3 = I2[""] || null;
    h4(_2) ? (U4 = s4.HTML_ENTITIES, $3 = D2.HTML) : _2 === g4.XML_SVG_IMAGE && ($3 = D2.SVG), I2[""] = $3, I2.xml = I2.xml || D2.XML;
    var J2 = new this.domHandler({
      mimeType: _2,
      defaultNamespace: $3,
      onError: this.onError
    }), Ne = this.locator ? {} : void 0;
    this.locator && J2.setDocumentLocator(Ne);
    var Z2 = new B2();
    Z2.errorHandler = J2, Z2.domBuilder = J2;
    var we = !n2.isHTMLMimeType(_2);
    return we && typeof m2 != "string" && Z2.errorHandler.fatalError("source is not a string"), Z2.parse(this.normalizeLineEndings(String(m2)), I2, U4), J2.doc.documentElement || Z2.errorHandler.fatalError("missing root element"), J2.doc;
  };
  function X2(m2) {
    var _2 = m2 || {};
    this.mimeType = _2.mimeType || g4.XML_APPLICATION, this.defaultNamespace = _2.defaultNamespace || null, this.cdata = false, this.currentElement = void 0, this.doc = void 0, this.locator = void 0, this.onError = _2.onError;
  }
  function te(m2, _2) {
    _2.lineNumber = m2.lineNumber, _2.columnNumber = m2.columnNumber;
  }
  X2.prototype = {
    /**
     * Either creates an XML or an HTML document and stores it under `this.doc`.
     * If it is an XML document, `this.defaultNamespace` is used to create it,
     * and it will not contain any `childNodes`.
     * If it is an HTML document, it will be created without any `childNodes`.
     *
     * @see http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
     */
    startDocument: function() {
      var m2 = new o5();
      this.doc = v2(this.mimeType) ? m2.createHTMLDocument(false) : m2.createDocument(this.defaultNamespace, "");
    },
    startElement: function(m2, _2, I2, U4) {
      var $3 = this.doc, J2 = $3.createElementNS(m2, I2 || _2), Ne = U4.length;
      W(this, J2), this.currentElement = J2, this.locator && te(this.locator, J2);
      for (var Z2 = 0; Z2 < Ne; Z2++) {
        var m2 = U4.getURI(Z2), we = U4.getValue(Z2), I2 = U4.getQName(Z2), l6 = $3.createAttributeNS(m2, I2);
        this.locator && te(U4.getLocator(Z2), l6), l6.value = l6.nodeValue = we, J2.setAttributeNode(l6);
      }
    },
    endElement: function(m2, _2, I2) {
      this.currentElement = this.currentElement.parentNode;
    },
    startPrefixMapping: function(m2, _2) {
    },
    endPrefixMapping: function(m2) {
    },
    processingInstruction: function(m2, _2) {
      var I2 = this.doc.createProcessingInstruction(m2, _2);
      this.locator && te(this.locator, I2), W(this, I2);
    },
    ignorableWhitespace: function(m2, _2, I2) {
    },
    characters: function(m2, _2, I2) {
      if (m2 = q3.apply(this, arguments), m2) {
        if (this.cdata)
          var U4 = this.doc.createCDATASection(m2);
        else
          var U4 = this.doc.createTextNode(m2);
        this.currentElement ? this.currentElement.appendChild(U4) : /^\s*$/.test(m2) && this.doc.appendChild(U4), this.locator && te(this.locator, U4);
      }
    },
    skippedEntity: function(m2) {
    },
    endDocument: function() {
      this.doc.normalize();
    },
    /**
     * Stores the locator to be able to set the `columnNumber` and `lineNumber`
     * on the created DOM nodes.
     *
     * @param {Locator} locator
     */
    setDocumentLocator: function(m2) {
      m2 && (m2.lineNumber = 0), this.locator = m2;
    },
    //LexicalHandler
    comment: function(m2, _2, I2) {
      m2 = q3.apply(this, arguments);
      var U4 = this.doc.createComment(m2);
      this.locator && te(this.locator, U4), W(this, U4);
    },
    startCDATA: function() {
      this.cdata = true;
    },
    endCDATA: function() {
      this.cdata = false;
    },
    startDTD: function(m2, _2, I2, U4) {
      var $3 = this.doc.implementation;
      if ($3 && $3.createDocumentType) {
        var J2 = $3.createDocumentType(m2, _2, I2, U4);
        this.locator && te(this.locator, J2), W(this, J2), this.doc.doctype = J2;
      }
    },
    reportError: function(m2, _2) {
      if (typeof this.onError == "function")
        try {
          this.onError(m2, _2, this);
        } catch (I2) {
          throw new p4("Reporting " + m2 + ' "' + _2 + '" caused ' + I2, this.locator);
        }
      else
        console.error("[xmldom " + m2 + "]	" + _2, M2(this.locator));
    },
    /**
     * @see http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
     */
    warning: function(m2) {
      this.reportError("warning", m2);
    },
    error: function(m2) {
      this.reportError("error", m2);
    },
    /**
     * This function reports a fatal error and throws a ParseError.
     *
     * @param {string} message
     * - The message to be used for reporting and throwing the error.
     * @returns {never}
     * This function always throws an error and never returns a value.
     * @throws {ParseError}
     * Always throws a ParseError with the provided message.
     */
    fatalError: function(m2) {
      throw this.reportError("fatalError", m2), new p4(m2, this.locator);
    }
  };
  function M2(m2) {
    if (m2)
      return `
@#[line:` + m2.lineNumber + ",col:" + m2.columnNumber + "]";
  }
  function q3(m2, _2, I2) {
    return typeof m2 == "string" ? m2.substr(_2, I2) : m2.length >= _2 + I2 || _2 ? new java.lang.String(m2, _2, I2) + "" : m2;
  }
  "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(
    /\w+/g,
    function(m2) {
      X2.prototype[m2] = function() {
        return null;
      };
    }
  );
  function W(m2, _2) {
    m2.currentElement ? m2.currentElement.appendChild(_2) : m2.doc.appendChild(_2);
  }
  function ue(m2) {
    if (m2 === "error") throw "onErrorStopParsing";
  }
  function de2() {
    throw "onWarningStopParsing";
  }
  return We.__DOMHandler = X2, We.DOMParser = Y2, We.normalizeLineEndings = k4, We.onErrorStopParsing = ue, We.onWarningStopParsing = de2, We;
}
var xt;
function vr() {
  if (xt) return G;
  xt = 1;
  var n2 = st();
  G.assign = n2.assign, G.hasDefaultHTMLNamespace = n2.hasDefaultHTMLNamespace, G.isHTMLMimeType = n2.isHTMLMimeType, G.isValidMimeType = n2.isValidMimeType, G.MIME_TYPE = n2.MIME_TYPE, G.NAMESPACE = n2.NAMESPACE;
  var t3 = mt();
  G.DOMException = t3.DOMException, G.DOMExceptionName = t3.DOMExceptionName, G.ExceptionCode = t3.ExceptionCode, G.ParseError = t3.ParseError;
  var u2 = Xt();
  G.Attr = u2.Attr, G.CDATASection = u2.CDATASection, G.CharacterData = u2.CharacterData, G.Comment = u2.Comment, G.Document = u2.Document, G.DocumentFragment = u2.DocumentFragment, G.DocumentType = u2.DocumentType, G.DOMImplementation = u2.DOMImplementation, G.Element = u2.Element, G.Entity = u2.Entity, G.EntityReference = u2.EntityReference, G.LiveNodeList = u2.LiveNodeList, G.NamedNodeMap = u2.NamedNodeMap, G.Node = u2.Node, G.NodeList = u2.NodeList, G.Notation = u2.Notation, G.ProcessingInstruction = u2.ProcessingInstruction, G.Text = u2.Text, G.XMLSerializer = u2.XMLSerializer;
  var s4 = Ar();
  return G.DOMParser = s4.DOMParser, G.normalizeLineEndings = s4.normalizeLineEndings, G.onErrorStopParsing = s4.onErrorStopParsing, G.onWarningStopParsing = s4.onWarningStopParsing, G;
}
var It = vr();
var Tr = class {
  constructor({ xml: t3 }) {
    var _a4;
    this.parent = null, this.child = null, this.minval = NaN, this.maxval = NaN, this.origin = new pt(), this.axis = new Oe({
      x: 1,
      y: 0,
      z: 0
    }), this.name = t3.getAttribute(H3.Name) ?? "unknown_name", this.type = t3.getAttribute(H3.Type);
    const u2 = t3.getElementsByTagName(H3.Parent);
    u2[0] && (this.parent = u2[0].getAttribute(H3.Link));
    const s4 = t3.getElementsByTagName(H3.Child);
    s4[0] && (this.child = s4[0].getAttribute(H3.Link));
    const c4 = t3.getElementsByTagName(H3.Limit);
    c4[0] && (this.minval = parseFloat(
      c4[0].getAttribute(H3.Lower) ?? "NaN"
    ), this.maxval = parseFloat(
      c4[0].getAttribute(H3.Upper) ?? "NaN"
    ));
    const o5 = t3.getElementsByTagName(H3.Origin);
    o5[0] && (this.origin = zt(o5[0]));
    const h4 = t3.getElementsByTagName(H3.Axis);
    if (h4[0]) {
      const v2 = (_a4 = h4[0].getAttribute(H3.Xyz)) == null ? void 0 : _a4.split(" ");
      if (!v2 || v2.length !== 3)
        throw new Error(
          "If specified, axis must have an xyz value composed of three numbers"
        );
      const [f7, g4, D2] = v2.map(parseFloat);
      this.axis = new Oe({
        x: f7,
        y: g4,
        z: D2
      });
    }
  }
};
var qr = class {
  constructor({ xml: t3, string: u2 }) {
    this.materials = {}, this.links = {}, this.joints = {};
    let s4 = t3;
    if (u2 && (s4 = new It.DOMParser().parseFromString(u2, It.MIME_TYPE.XML_TEXT).documentElement ?? void 0), !s4)
      throw new Error("No URDF document parsed!");
    this.name = s4.getAttribute(H3.Name);
    const c4 = s4.childNodes;
    for (const o5 of c4)
      if (Ht(o5))
        switch (o5.tagName) {
          case "material": {
            const h4 = new Vt({ xml: o5 });
            if (!Object.hasOwn(this.materials, h4.name)) {
              this.materials[h4.name] = h4;
              break;
            }
            const v2 = this.materials[h4.name];
            (v2 == null ? void 0 : v2.isLink()) ? v2.assign(h4) : console.warn(`Material ${h4.name} is not unique.`);
            break;
          }
          case "link": {
            const h4 = new Er({ xml: o5 });
            if (Object.hasOwn(this.links, h4.name)) {
              console.warn(`Link ${h4.name} is not unique.`);
              break;
            }
            for (const v2 of h4.visuals) {
              const f7 = v2.material;
              if (!(f7 == null ? void 0 : f7.name))
                continue;
              const g4 = this.materials[f7.name];
              g4 ? v2.material = g4 : this.materials[f7.name] = f7;
            }
            this.links[h4.name] = h4;
            break;
          }
          case "joint": {
            const h4 = new Tr({ xml: o5 });
            this.joints[h4.name] = h4;
            break;
          }
        }
  }
};
var Gr = "2.0.0";

export {
  ut,
  Qt,
  _r3 as _r,
  Jt,
  Zt,
  Sr,
  Or,
  Bt,
  Rr,
  Mr,
  xr,
  Ir,
  At,
  Ft,
  Br,
  Fr,
  Lt,
  Pt,
  kt,
  Ut,
  re,
  fe,
  Kt,
  qt,
  er,
  Oe,
  Qe,
  vt,
  tr,
  rr,
  ur,
  Lr,
  nr,
  Pr,
  kr,
  pt,
  Ur,
  ft,
  H3 as H,
  cr,
  lr,
  hr,
  Vt,
  pr,
  fr,
  zt,
  Ht,
  mr,
  Er,
  Tr,
  qr,
  Gr
};
/*! Bundled license information:

pako/dist/pako.esm.mjs:
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)
*/
//# sourceMappingURL=chunk-DEX2YPT6.js.map
