import { S as Sliceable, c as DecodeStreamOptions, M as MtAiValue } from './options-B_2zDXXZ.js';
import './sorts.js';

type ValueGenerator = Generator<MtAiValue, undefined, undefined>;
/**
 * Decode bytes into a stream of events describing the CBOR read from the
 * bytes.  Currently requires a full single CBOR value, with no extra bytes in
 * the input.
 */
declare class DecodeStream implements Sliceable {
    #private;
    static defaultOptions: Required<DecodeStreamOptions>;
    constructor(src: Uint8Array | string, opts?: DecodeStreamOptions);
    /**
     * Get the chunk of this stream from the given position to the current offset.
     *
     * @param begin Position to read from.  Should be <= current offset.
     * @returns Subarray of input stream (not copy).
     */
    toHere(begin: number): Uint8Array;
    /**
     * Get the stream of events describing the CBOR item.  Yields Value tuples.
     *
     * @throws On invalid input or extra data in input.
     * @example
     * ```js
     * const s = new DecodeStream(buffer);
     * for (const [majorType, additionalInfo, value] of s) {
     *  ...
     * }
     * ```
     */
    [Symbol.iterator](): ValueGenerator;
    /**
     * Get a stream of events describing all CBOR items in the input CBOR Sequence
     * consisting of multiple CBOR items. Yields Value tuples.
     *
     * Note that this includes items indicating the start of an array or map, and
     * the end of an indefinite-length item, and tag numbers separate from the tag
     * content. Does not guarantee that the input is valid.
     *
     * Will attempt to read all items in an array or map, even if indefinite.
     * Throws when there is insufficient data to do so. The same applies when
     * reading tagged items, byte strings and text strings.
     *
     * @throws On insufficient data.
     * @example
     * ```js
     * const s = new DecodeStream(buffer);
     * for (const [majorType, additionalInfo, value] of s.seq()) {
     *  ...
     * }
     * ```
     */
    seq(): ValueGenerator;
}

export { DecodeStream, type ValueGenerator };
