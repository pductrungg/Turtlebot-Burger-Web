import { EventEmitter } from 'eventemitter3';
import { RosbridgeMessage, RosbridgeMessageBase } from '../../types/protocol.ts';
/**
 * Because transport implementations may have different event types
 * with varying amounts of information, and we want to be a pass-through
 * of such information, we can't exactly define the event types here.
 */
export type TransportEvent = unknown;
/**
 * Abstraction responsible for sending and receiving messages
 * between the client and the rosbridge server.
 *
 * Inspired by the WebSocket API, which is the default reference implementation.
 */
export interface ITransport {
    on(event: "open" | "close" | "error", listener: (event: TransportEvent) => void): this;
    on(event: "message", listener: (message: RosbridgeMessage) => void): this;
    send(message: RosbridgeMessage): void;
    close(): void;
    isConnecting(): boolean;
    isOpen(): boolean;
    isClosing(): boolean;
    isClosed(): boolean;
}
/**
 * Invoked when the roslib needs a new transport, such as
 * when (re)connecting to the rosbridge server.
 */
export type ITransportFactory = (url: string) => Promise<ITransport>;
/**
 * Abstract base class for all transport implementations.
 * Provides a default implementation for decoding raw rosbridge messages.
 */
export declare abstract class AbstractTransport extends EventEmitter<{
    open: [TransportEvent];
    close: [TransportEvent];
    error: [TransportEvent];
    message: [RosbridgeMessageBase];
}> implements ITransport {
    #private;
    abstract send(message: RosbridgeMessage): void;
    abstract close(): void;
    abstract isConnecting(): boolean;
    abstract isOpen(): boolean;
    abstract isClosing(): boolean;
    abstract isClosed(): boolean;
    /**
     * Decodes a raw message received from the transport
     * and emits it as a RosbridgeMessage over the "message" event.
     * If an error occurs, it is emitted as an "error" event.
     *
     * The default implementation handles multiple compression formats
     * and fragment messages. Subclasses may override this method to provide
     * custom handling of raw messages and when to emit messages.
     */
    protected handleRawMessage(data: unknown): void;
    /**
     * Handles a RosbridgeMessage.
     * If the message is a fragment, it is appended to the fragment buffer.
     * If the message is a PNG, it is decompressed and reprocessed.
     * Otherwise, the message is emitted.
     */
    private handleRosbridgeMessage;
    /**
     * Appends a fragment to the current fragment buffer for the message id.
     * If all fragments are received, the message is reconstructed and processed.
     */
    private handleRosbridgeFragmentMessage;
    /**
     * Decompresses a PNG image expecting the result to be a RosbridgeMessage.
     * It is one technique for compressing JSON data.
     */
    private handleRosbridgePngMessage;
    /**
     * Deserializes a Blob of BSON expecting the result to be a RosbridgeMessage.
     * It is one technique for compressing JSON data.
     */
    private handleBsonMessage;
    /**
     * Deserializes an ArrayBuffer of CBOR expecting the result to be a RosbridgeMessage.
     * It is one technique for compressing JSON data.
     */
    private handleCborMessage;
    /**
     * Deserializes a JSON string expecting the result to be a RosbridgeMessage.
     */
    private handleJsonMessage;
}
